{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hanfor Docs Hanfor h elps an alyzing an d for malizing r equirements. Quickstart # Use Python 3.6.x Install dependencies: pip install -r requirements.txt Copy ./hanfor/config.dist.py to ./hanfor/config.py . Edit the config.py according your needs. Start the app for a fresh session created from input.csv : python app.py <tag> -c path/to/input.csv Point your browser to http://127.0.0.1:<port in config.py> . Introduction # If you have many requirements it gets difficult to check that all of them are, e.g., consistent. No human can manually check >1000 requirements for consistency -- so we do our best with reviews. Also in new projects, what we often see, is that it takes a long time before there is a high test coverage on the requirements -- as the number of requirements increases over the releases, and thus also the test specifications have to cover more and more requirements. However, many defects are found by experience-based testing -- but these technique is often used quite late, as the first priority is to get a reasonable requirement-based coverage. To tackle that problem, Hanfor provides a method that consists of 3 steps: The Requirements Formalization The Requirements Check (on the formalized requirements) The Test Generation (on the formalized requirements) To make it possible for a computer to check a set of requirements for quality criteria, as e.g. consistency, it has to \"understand\" the semantics of the requirements. This could be achieved by using formal languages to express the requirements. However, they are rarely understandable for humans, so we would get requirements that the computer understands - but nearly no stakeholder. In this method we use a simple pattern language. The requirements expressed in the pattern language look like English sentences. Everything you can express in this patterns is then translated in the background into logical formulas. You could also easily translate them into German, Chinese, or other languages. Grammar of the Specification Language # The grammar is the following: REQ ::= ID: SCOPE, PATTERN . SCOPE ::= Globally | Before EXPR | After EXPR | Between EXPR and EXPR | After EXPR until EXPR PATTERN ::= It is never the case that EXPR holds | It is always the case that EXPR holds | It is always the case that if EXPR holds, then EXPR holds as well | Transition to states in which EXPR holds occur at most twice | It is always the case that ORDER | It is always the case that REALTIME ORDER ::= | If EXPR holds, then EXPR previously held | If EXPR holds and is succeded by EXPR, then EXPR previously held | If EXPR holds, then EXPR previously held and was preceeded by EXPR | If EXPR holds, then EXPR eventually holds and is succeeded by EXPR | If EXPR holds and is succeeded by EXPR, then EXPR eventually holds after EXPR | If EXPR holds, then EXPR eventually holds and is succeeded by EXPR where EXPR does not hold between EXPR and EXPR | If EXPR holds, then EXPR toggles EXPR REALTIME ::= Once EXPR becomes satisfied, it holds for at least DURATION | Once EXPR becomes satisfied, it holds for less than DURATION | EXPR holds at least every DURATION | If EXPR holds, then EXPR holds after at most DURATION | If EXPR holds for at least DURATION, then EXPR holds afterwards for at least DURATION | If EXPR holds for at least DURATION, then EXPR holds afterwards | If EXPR holds, then EXPR holds after at most DURATION for at least DURATION | If EXPR holds, then EXPR holds for at least DURATION | If EXPR holds, then there is at least one execution sequence such that EXPR holds after at most DURATION | After EXPR holds for DURATION, then EXPR holds | If EXPR holds, then EXPR toggles EXPR at most DURATION later EXPR is an expression (e.g. vehicleSpeed<10 && Terminal15==ON ). Thus, in a first step the informal requirements are translated into requirements in the specification language shown above. This is done manually. In the background the tool translates the requirements in specification language then into logical formulas. Tool Support # The tool to assist this step is called Hanfor.It looks a little bit like Doors. It takes as input a csv-Export from Doors, and then stores the requirements. There are two IDs, the Hanfor ID and the Doors ID, so that you can synchronize the two databases, and can easily identify changes. Clicking on a requirements you can then specify the requirement in the specification language as visible in the next screenshot. The tool provides both patterns and also a signal database, so that you have a auto-complete function when filling out the variables. The tool checks for the following correctness criteria: Consistency Vacuity rt-Consistency Example Req1: It is always the case that \"IRTest\" holds. Req2: It is never the case that \"IRTest\" holds. Inconsistency can be resolved by erasing requirements changing requirements Example Req1: It is always the case that if \"Signal-A\" holds then \"Signal-B\" holds after at most 10 ms. Req2: It is never the case that \"Signal-A\" holds. These requirements are consistent, but the precondition of Req1 is never true, i.e., Req1 is vacuously satisfied in this set of requirements. Vacuity can be resolved by erasing requirements, or changing requirements Example Erase Req2 or make it less restrictive Change Req2 to Req2': Before \"Startup\", it is never the case that \"Signal-A\" holds. Realtime-Consistency (rt-consistency) # A set of requirements is rt-inconsistent, if there are conflicts between requirements that arise after a certain time. Example Req1: It is always the case that if \u201eIRTest\u201c holds, then \u201eIRLampsOn\u201c holds after at most 10 seconds Req2: It is always the case that if \u201eIRTest\u201c holds, then \u201eNOT(IRLampsOn)\u201c holds for at least 6 seconds. is consistent, but there are assignments with a conflict as shown in the following example. As IRTest gets valid in timepoint t=4, req1 requires, that in the time interval t=[4...14] IRLampsOn gets true as well. As IRTest is still valid in timepoint t=10, req2 requires, that IRLampsOn stays \"false\" until at least t=16. Thus, in t=14 we have a conflict - however the system reacts, one requirement will be violated. Resolve rt-inconsistency by erasing requirements, or changing requirements, or adding requirements Erase Req2, or make it less restrictive \u2013Req2\u2018: It is always the case that if IRTest holds and it did not hold in the last 10 s, then NOT(IRLampsOn) holds for at least 6 s. Or add Req3: Once IRTest appears, it holds for at most 3 seconds. Req4: Once IRTest disappears, it is absent for at least 10 seconds System test case generation # When having the requirements formalized in the specification language, it makes sense to also automatically generate test specifications out of them. There are several reasons to do so: Thus the algorithm has to: Automatically generate system tests only using requirements Generate small set of tests (test suite) Generate one test case per output variable Generate so many tests that every requirement is tested Generate tests that may not lead to false positives Ensure traceability to the requirements (i.e. indicate what requirements are tested by the test) The generated Test (case) consists of Sequence of inputs (Initial state of system, Inputs for steps 1...n) Expected outcome (oracle for step n) Link to the tested requirement Generate a feedback if there are untestable requirements Output: Set of untestable requirements (No seq. of Inputs deterministically causes the output) Example System to be tested: Input Requirements to be tested: req1: Globally, it is always the case that if \u2018A\u2019 holds then \u2018H\u2019 holds after at most \u201810\u2019 time units. req2: Globally, it is always the case that if \u2018B\u2019 holds then \u2018I\u2019 holds after at most \u201810\u2019 time units. req3: Globally, it is always the case that if \u2018H AND I\u2019 holds then \u2018O\u2019 holds after at most \u201810\u2019 time units. Testing requires information about observability. Thus, we need to categorize the variables into Input, Output, and Hidden (i.e. internal variables): Inputs: A, B Outputs: O Hidden: H, I In the Test Generator Tool you can choose the following options: generate System Test (i.e. the tests only speak about system inputs and outputs, but no internal variables) generate System Integration Test (i.e., the tests speak about system input, system outputs and internal variables) Output of the Test Generator Tool Case SystemTest: TestGeneratorResult: Found Test for: [O] Test Vector: Set inputs: A := true, B := true Wait for at most 20 for: O == true, (req3) Case System Integration Test: ------| Test: req3 |----------------------- TestGeneratorResult: Found Test for: [O] Test Vector: Set inputs: A := true, B := true Wait for at most 10 for: H == true (req1) Wait for at most 10 for: I == true (req2) Wait for at most 20 for: O == true, (req3)","title":"Home"},{"location":"#quickstart","text":"Use Python 3.6.x Install dependencies: pip install -r requirements.txt Copy ./hanfor/config.dist.py to ./hanfor/config.py . Edit the config.py according your needs. Start the app for a fresh session created from input.csv : python app.py <tag> -c path/to/input.csv Point your browser to http://127.0.0.1:<port in config.py> .","title":"Quickstart"},{"location":"#introduction","text":"If you have many requirements it gets difficult to check that all of them are, e.g., consistent. No human can manually check >1000 requirements for consistency -- so we do our best with reviews. Also in new projects, what we often see, is that it takes a long time before there is a high test coverage on the requirements -- as the number of requirements increases over the releases, and thus also the test specifications have to cover more and more requirements. However, many defects are found by experience-based testing -- but these technique is often used quite late, as the first priority is to get a reasonable requirement-based coverage. To tackle that problem, Hanfor provides a method that consists of 3 steps: The Requirements Formalization The Requirements Check (on the formalized requirements) The Test Generation (on the formalized requirements) To make it possible for a computer to check a set of requirements for quality criteria, as e.g. consistency, it has to \"understand\" the semantics of the requirements. This could be achieved by using formal languages to express the requirements. However, they are rarely understandable for humans, so we would get requirements that the computer understands - but nearly no stakeholder. In this method we use a simple pattern language. The requirements expressed in the pattern language look like English sentences. Everything you can express in this patterns is then translated in the background into logical formulas. You could also easily translate them into German, Chinese, or other languages.","title":"Introduction"},{"location":"#grammar-of-the-specification-language","text":"The grammar is the following: REQ ::= ID: SCOPE, PATTERN . SCOPE ::= Globally | Before EXPR | After EXPR | Between EXPR and EXPR | After EXPR until EXPR PATTERN ::= It is never the case that EXPR holds | It is always the case that EXPR holds | It is always the case that if EXPR holds, then EXPR holds as well | Transition to states in which EXPR holds occur at most twice | It is always the case that ORDER | It is always the case that REALTIME ORDER ::= | If EXPR holds, then EXPR previously held | If EXPR holds and is succeded by EXPR, then EXPR previously held | If EXPR holds, then EXPR previously held and was preceeded by EXPR | If EXPR holds, then EXPR eventually holds and is succeeded by EXPR | If EXPR holds and is succeeded by EXPR, then EXPR eventually holds after EXPR | If EXPR holds, then EXPR eventually holds and is succeeded by EXPR where EXPR does not hold between EXPR and EXPR | If EXPR holds, then EXPR toggles EXPR REALTIME ::= Once EXPR becomes satisfied, it holds for at least DURATION | Once EXPR becomes satisfied, it holds for less than DURATION | EXPR holds at least every DURATION | If EXPR holds, then EXPR holds after at most DURATION | If EXPR holds for at least DURATION, then EXPR holds afterwards for at least DURATION | If EXPR holds for at least DURATION, then EXPR holds afterwards | If EXPR holds, then EXPR holds after at most DURATION for at least DURATION | If EXPR holds, then EXPR holds for at least DURATION | If EXPR holds, then there is at least one execution sequence such that EXPR holds after at most DURATION | After EXPR holds for DURATION, then EXPR holds | If EXPR holds, then EXPR toggles EXPR at most DURATION later EXPR is an expression (e.g. vehicleSpeed<10 && Terminal15==ON ). Thus, in a first step the informal requirements are translated into requirements in the specification language shown above. This is done manually. In the background the tool translates the requirements in specification language then into logical formulas.","title":"Grammar of the Specification Language"},{"location":"#tool-support","text":"The tool to assist this step is called Hanfor.It looks a little bit like Doors. It takes as input a csv-Export from Doors, and then stores the requirements. There are two IDs, the Hanfor ID and the Doors ID, so that you can synchronize the two databases, and can easily identify changes. Clicking on a requirements you can then specify the requirement in the specification language as visible in the next screenshot. The tool provides both patterns and also a signal database, so that you have a auto-complete function when filling out the variables. The tool checks for the following correctness criteria: Consistency Vacuity rt-Consistency Example Req1: It is always the case that \"IRTest\" holds. Req2: It is never the case that \"IRTest\" holds. Inconsistency can be resolved by erasing requirements changing requirements Example Req1: It is always the case that if \"Signal-A\" holds then \"Signal-B\" holds after at most 10 ms. Req2: It is never the case that \"Signal-A\" holds. These requirements are consistent, but the precondition of Req1 is never true, i.e., Req1 is vacuously satisfied in this set of requirements. Vacuity can be resolved by erasing requirements, or changing requirements Example Erase Req2 or make it less restrictive Change Req2 to Req2': Before \"Startup\", it is never the case that \"Signal-A\" holds.","title":"Tool Support"},{"location":"#realtime-consistency-rt-consistency","text":"A set of requirements is rt-inconsistent, if there are conflicts between requirements that arise after a certain time. Example Req1: It is always the case that if \u201eIRTest\u201c holds, then \u201eIRLampsOn\u201c holds after at most 10 seconds Req2: It is always the case that if \u201eIRTest\u201c holds, then \u201eNOT(IRLampsOn)\u201c holds for at least 6 seconds. is consistent, but there are assignments with a conflict as shown in the following example. As IRTest gets valid in timepoint t=4, req1 requires, that in the time interval t=[4...14] IRLampsOn gets true as well. As IRTest is still valid in timepoint t=10, req2 requires, that IRLampsOn stays \"false\" until at least t=16. Thus, in t=14 we have a conflict - however the system reacts, one requirement will be violated. Resolve rt-inconsistency by erasing requirements, or changing requirements, or adding requirements Erase Req2, or make it less restrictive \u2013Req2\u2018: It is always the case that if IRTest holds and it did not hold in the last 10 s, then NOT(IRLampsOn) holds for at least 6 s. Or add Req3: Once IRTest appears, it holds for at most 3 seconds. Req4: Once IRTest disappears, it is absent for at least 10 seconds","title":"Realtime-Consistency (rt-consistency)"},{"location":"#system-test-case-generation","text":"When having the requirements formalized in the specification language, it makes sense to also automatically generate test specifications out of them. There are several reasons to do so: Thus the algorithm has to: Automatically generate system tests only using requirements Generate small set of tests (test suite) Generate one test case per output variable Generate so many tests that every requirement is tested Generate tests that may not lead to false positives Ensure traceability to the requirements (i.e. indicate what requirements are tested by the test) The generated Test (case) consists of Sequence of inputs (Initial state of system, Inputs for steps 1...n) Expected outcome (oracle for step n) Link to the tested requirement Generate a feedback if there are untestable requirements Output: Set of untestable requirements (No seq. of Inputs deterministically causes the output) Example System to be tested: Input Requirements to be tested: req1: Globally, it is always the case that if \u2018A\u2019 holds then \u2018H\u2019 holds after at most \u201810\u2019 time units. req2: Globally, it is always the case that if \u2018B\u2019 holds then \u2018I\u2019 holds after at most \u201810\u2019 time units. req3: Globally, it is always the case that if \u2018H AND I\u2019 holds then \u2018O\u2019 holds after at most \u201810\u2019 time units. Testing requires information about observability. Thus, we need to categorize the variables into Input, Output, and Hidden (i.e. internal variables): Inputs: A, B Outputs: O Hidden: H, I In the Test Generator Tool you can choose the following options: generate System Test (i.e. the tests only speak about system inputs and outputs, but no internal variables) generate System Integration Test (i.e., the tests speak about system input, system outputs and internal variables) Output of the Test Generator Tool Case SystemTest: TestGeneratorResult: Found Test for: [O] Test Vector: Set inputs: A := true, B := true Wait for at most 20 for: O == true, (req3) Case System Integration Test: ------| Test: req3 |----------------------- TestGeneratorResult: Found Test for: [O] Test Vector: Set inputs: A := true, B := true Wait for at most 10 for: H == true (req1) Wait for at most 10 for: I == true (req2) Wait for at most 20 for: O == true, (req3)","title":"System test case generation"},{"location":"installation/","text":"Installation Preliminaries # Clone the repository: $ git clone https://github.com/ultimate-pa/hanfor.git -b master --single-branch /your/hanfor/destination Hanfor requires Python and is only tested with Python 3.6.x. You can check if you have python already installed from the command line: $ python -- version Python 3 .5.2 We recommend using a virtual environment . Create a new virtual environment with: $ virtualenv hanfor_python And activate it by sourcing: $ source hanfor_python/bin/activate Now the python dependencies needed to be installed into the virtual environment. Inside the repository run: $ pip install -r requirements.txt Configure # Copy ./hanfor/config.dist.py to ./hanfor/config.py . Edit the config.py according your needs. Start # To start a fresh session use $ python app.py <tag> -c <path_to_input_csv>.csv Point your browser to http://127.0.0.1:<port in config.py> Start an existing session: $ python app.py <tag> You can see all available tags using the ''-L'' switch: $ python app.py -L How it works # The app will create a session naming it by the given <tag> argument. A session creation process has the following steps: Create a session in a folder config.py_SESSION_BASE_FOLDER/<tag> . Read the given .csv file containing one requirement each row. Ask the user about a mapping of the csv-header-names for: \"ID\", \"Description\", \"Formalized Requirement\", \"Type\" Create a Hanfor-Requirement for each row in the csv and store it to the session folder. Provide the Web-interface on the port specified in config.py","title":"Installation"},{"location":"installation/#preliminaries","text":"Clone the repository: $ git clone https://github.com/ultimate-pa/hanfor.git -b master --single-branch /your/hanfor/destination Hanfor requires Python and is only tested with Python 3.6.x. You can check if you have python already installed from the command line: $ python -- version Python 3 .5.2 We recommend using a virtual environment . Create a new virtual environment with: $ virtualenv hanfor_python And activate it by sourcing: $ source hanfor_python/bin/activate Now the python dependencies needed to be installed into the virtual environment. Inside the repository run: $ pip install -r requirements.txt","title":"Preliminaries"},{"location":"installation/#configure","text":"Copy ./hanfor/config.dist.py to ./hanfor/config.py . Edit the config.py according your needs.","title":"Configure"},{"location":"installation/#start","text":"To start a fresh session use $ python app.py <tag> -c <path_to_input_csv>.csv Point your browser to http://127.0.0.1:<port in config.py> Start an existing session: $ python app.py <tag> You can see all available tags using the ''-L'' switch: $ python app.py -L","title":"Start"},{"location":"installation/#how-it-works","text":"The app will create a session naming it by the given <tag> argument. A session creation process has the following steps: Create a session in a folder config.py_SESSION_BASE_FOLDER/<tag> . Read the given .csv file containing one requirement each row. Ask the user about a mapping of the csv-header-names for: \"ID\", \"Description\", \"Formalized Requirement\", \"Type\" Create a Hanfor-Requirement for each row in the csv and store it to the session folder. Provide the Web-interface on the port specified in config.py","title":"How it works"},{"location":"Usage/API Queries/","text":"API Queries To generate reports or search for requirements not using the frontend Hanfor can be queried with HTTP requests at http(s)://{{your host}}/{{your URL_PREFIX}}/api/query Show stored Queries # GET /api/query URL Arguments Name Type Description name string Name of the Query to retrieve a single Query. reload bool, optional Reevaluates all stored Queries. Examples # Show all stored Queries $ curl http://localhost:5000/api/query # Show only Queries which are named 'MyQuery' and re-evaluate the stored Query $ curl http://localhost:5000/api/query?name = MyQuery & reload = true # Using jq to parse the JSON response. Show only the name of the query with associated hits. $ curl http://localhost:5000/api/query \\? reload \\= true | jq -r '.data[] | {name: .name, hits: .hits}' Adding new Queries # POST /api/query Content-Type: application/json JSON body parameters Name Type Description name string Name for the Query. Existing ones will be overridden. query string The search Query. Example $ curl -X POST -H 'Content-Type: application/json' \\ --data '{\"name\": \"MyQuery\", \"query\": \"foo:AND:bar\"}' http://localhost:5000/api/query Deleting Queries # DELETE /api/query JSON body parameters Name Type Description name string Name for the Query to be deleted. names list of strings Queries by name to be deleted. Examples # Delete a single Query: $ curl -X DELETE -H 'Content-Type: application/json' \\ --data '{\"name\": \"MyQuery\"}' http://localhost:5000/api/query # Delete multiple Queries: $ curl -X DELETE -H 'Content-Type: application/json' \\ --data '{\"names\": [\"MyQuery\", \"Another\"]' http://localhost:5000/api/query Query syntax # Much like in the frontend the Query syntax supports operators, nesting, exact- exclusive matches and targeting specific attributes. Search Operators You can concatenate search Queries by search_1:OR:search_2 yields the union of search_1 and search_2. search_1:AND:search_2 yields the intersection of search_1 and search_2. :AND: binds stronger than :OR: . To invert the result use :NOT: before your search string. To change the precedence or to nest a Query ( and ) . Exact searches You can get exact search results by using \" to indicate the beginning or end of a sequence. \"fast Includes faster but not breakfast. fast\" Includes breakfast but not faster. \"fast\" Includes only exact matches of fast. Target specific attributes To limit a part of the search Query to one attribute use the syntax :DATA_TARGET:`<the attribute name>` Note: the attribute name must be enclosed with backticks. Get available attributes GET /api/quer?show=targets Example # Show attribute names available for specific search. $ curl http://localhost:5000/api/query?show = targets Default targets: The available targets are composed of [ \"Description\" , \"Formalization\" , \"Id\" , \"Status\" , \"Tags\" , \"Type\" ] Plus the fields available in the associated CSV file the requirements origin from.","title":"API Queries"},{"location":"Usage/API Queries/#show-stored-queries","text":"GET /api/query","title":"Show stored Queries"},{"location":"Usage/API Queries/#adding-new-queries","text":"POST /api/query Content-Type: application/json","title":"Adding new Queries"},{"location":"Usage/API Queries/#deleting-queries","text":"DELETE /api/query","title":"Deleting Queries"},{"location":"Usage/API Queries/#query-syntax","text":"Much like in the frontend the Query syntax supports operators, nesting, exact- exclusive matches and targeting specific attributes.","title":"Query syntax"},{"location":"Usage/FAQ/","text":"FAQ Change description or a field text in requirements table. # Currently there is only one way to achieve this: \u201cCreating a new revision\u201d: Edit the Description in the CSV -> edited.csv . Create a revision with the edited CSV as baseline: python app.py TAG_NAME -c path/to/edited.csv --revision This will check for changes in the CSV against the old one and create a new \u201cVersion\u201d aka. \u201cRevision\u201d.","title":"FAQ"},{"location":"Usage/FAQ/#change-description-or-a-field-text-in-requirements-table","text":"Currently there is only one way to achieve this: \u201cCreating a new revision\u201d: Edit the Description in the CSV -> edited.csv . Create a revision with the edited CSV as baseline: python app.py TAG_NAME -c path/to/edited.csv --revision This will check for changes in the CSV against the old one and create a new \u201cVersion\u201d aka. \u201cRevision\u201d.","title":"Change description or a field text in requirements table."},{"location":"Usage/Requirements/","text":"Requirements Search in requirements table # Searching in the requirements table is accessible via the search tab. Typing in the search input supports autocomplete for extended search triggered by : . Search Operators You can concatenate search queries by search_1:OR:search_2 yields the union of search_1 and search_2. search_1:AND:search_2 yields the intersection of search_1 and search_2. :AND: binds stronger than :OR: . To invert the result use :NOT: before your search string. Exact searches You can get exact search results by using \" to indicate the beginning or end of a sequence. \"fast Includes faster but not breakfast. fast\" Includes breakfast but not faster. \"fast\" Includes only exact matches of fast. Search Target column To target a specific column use :COL_INDEX_02: to target column 2. The column indexes are appended in the requirements table header in parentheses. Mass edit requirements # You can mass edit requirements. Select requirements by clicking on the requirement checkbox in the table. Hold shift for multi select and Ctrl to toggle a single selection. Click on Edit Selected , fill out the form. Empty fields will have no effect.","title":"Requirements"},{"location":"Usage/Requirements/#search-in-requirements-table","text":"Searching in the requirements table is accessible via the search tab. Typing in the search input supports autocomplete for extended search triggered by : .","title":"Search in requirements table"},{"location":"Usage/Requirements/#mass-edit-requirements","text":"You can mass edit requirements. Select requirements by clicking on the requirement checkbox in the table. Hold shift for multi select and Ctrl to toggle a single selection. Click on Edit Selected , fill out the form. Empty fields will have no effect.","title":"Mass edit requirements"}]}