{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the Hanfor Documentation # Hanfor is a tool that h elps an alyzing and fo rmalizing r equirements. To get a short overview about our tool have a look at our intoductory page. Getting Started # If you are new to Hanfor, begin with the installation guide and have a look at the preliminaries , the configuration and the quick start section. Using Hanfor # The usage section provides some information about the workflow of Hanfor, API queries and the handling of requirements . If you wish to find out more about the different patterns that are supported by Hanfor, have a look at the patterns section. Contents # Introduction What is Hanfor? Installation Preliminaries Configuration Quick start Usage API Queries FAQ Requirements Workflow References Duration Calculus Phase Event Automata Patterns Publications Contribute Hanfor Docs Contact Contact","title":"Welcome to the Hanfor Documentation"},{"location":"index.html#welcome-to-the-hanfor-documentation","text":"Hanfor is a tool that h elps an alyzing and fo rmalizing r equirements. To get a short overview about our tool have a look at our intoductory page.","title":"Welcome to the Hanfor Documentation"},{"location":"contact/contact.html","text":"Contact # Most Hanfor developers are students and researchers in the software engineering group of Andreas Podelski at the University of Freiburg . If you have any questions, open a GitHub issue or write a mail to Daniel Dietsch - dietsch@informatik.uni-freiburg.de Vincent Langenfeld - langenfv@informatik.uni-freiburg.de","title":"Contact"},{"location":"contact/contact.html#contact","text":"Most Hanfor developers are students and researchers in the software engineering group of Andreas Podelski at the University of Freiburg . If you have any questions, open a GitHub issue or write a mail to Daniel Dietsch - dietsch@informatik.uni-freiburg.de Vincent Langenfeld - langenfv@informatik.uni-freiburg.de","title":"Contact"},{"location":"contribute/to_docs.html","text":"These are the source files for the Hanfor Documentation . Contribute to this Documentation. # 0. (Optional) setup a virtual environment # $ cd hanfor/documentation $ python3 -m venv venv $ source venv/bin/activate 1. Install MkDocs and all dependencies. # $ pip3 install -r requirements.txt 2. Serve this Documentation locally to track your changes. # $ cd hanfor/documentation $ mkdocs serve Open your Browser at http://127.0.0.1:8000/ . 3. Publish your changes to the staging directory. # $ mkdocs gh-deploy --remote-branch gh-pages-staging This will build the Documentation and commit them to the gh-pages-staging branch and push the gh-pages-staging branch to GitHub. If you have the necessary rights, you can then see the results on https://struebli.informatik.uni-freiburg.de/hanfor-docs-staging. 4. Publish your changes to the live directory # $ mkdocs gh-deploy This will build the Documentation and commit them to the gh-pages branch and push the gh-pages branch to GitHub. They will then be immediately available to the world at https://ultimate-pa.github.io/hanfor.","title":"To docs"},{"location":"contribute/to_docs.html#contribute-to-this-documentation","text":"","title":"Contribute to this Documentation."},{"location":"contribute/to_hanfor.html","text":"To Hanfor # In this guide we are going to talk about required tools to install in order to set up a development environment for Hanfor. However, to contribute, you know the drill, head over to Hanfor's Git repository and fork it, then work in your changes and PR. Environment Setup # Hanfor is a web based tool running on java script on the client side and python on the server side. Backend # Prepare the python environment as described in the installation guide . Additionally install the development requirements pip install -r requirements-dev.txt Frontend # To prepare the client side java script code development (and also some static assets), the java script based module bundler webpack is needed. Note, that webpack has to be executed after changing in the frontend. Install Node.js on your machine (in order to be able to execute java script code). Run the package manager npm (part of the Node.js installation) to install webpack. npm install --save-dev webpack Build and Run # The frontend of Hanfor has to be built before deploying. Frontend # To build the frontend change your path to the static folder, and execute webpack as follows cd static npm run build If you want to debug java-script code in your browser, you can tell webpack to include a source map by running the following command instead. Note: please do not commit the resulting build to the repository. npm run dev-build Backend # Launch a Hanfor session as explained in the installation guide .","title":"To Hanfor"},{"location":"contribute/to_hanfor.html#to-hanfor","text":"In this guide we are going to talk about required tools to install in order to set up a development environment for Hanfor. However, to contribute, you know the drill, head over to Hanfor's Git repository and fork it, then work in your changes and PR.","title":"To Hanfor"},{"location":"contribute/to_hanfor.html#environment-setup","text":"Hanfor is a web based tool running on java script on the client side and python on the server side.","title":"Environment Setup"},{"location":"contribute/to_hanfor.html#build-and-run","text":"The frontend of Hanfor has to be built before deploying.","title":"Build and Run"},{"location":"installation/installation.html","text":"Installation # Prerequisites # Python ( Note : Hanfor is only tested with Python 3.9.x) pip Install Hanfor # To get Hanfor either download the .zip file or clone the repository. Download .zip file # Download Hanfor and unzip it. Rename the root folder hanfor-master to hanfor . Linux Windows mv hanfor-master hanfor move hanfor-master hanfor Clone the repository # git clone https://github.com/ultimate-pa/hanfor.git -b master --single-branch Install dependencies # We recommend using a virtual environment . Linux Windows cd hanfor/hanfor python -m venv hanfor_venv source hanfor_venv/bin/activate cd hanfor \\h anfor python -m venv hanfor_venv hanfor_venv \\S cripts \\a ctivate.bat Install all Python dependencies. pip install -r requirements.txt Install the Z3 Theorem Prover. pysmt-install --z3 Configuration # Copy the default config file config.dist.py to config.py . Linux Windows cp config.dist.py config.py copy config.dist.py config.py The config file config.py allows you to change various parameters -- see the comments in config.dist.py . Launch a Hanfor session # Launch a new session # python app.py <tag> -c <path_to_input_csv> 1. This creates a new session named by <tag> in the SESSION_BASE_FOLDER . 2. It asks the user for a mapping of the following .csv header names. * \"ID\" * \"Description\" * \"Formalized Requirement\" * \"Type\" 3. It reads requirements from the .csv file and stores them in separate files in the SESSION_BASE_FOLDER . 4. It serves the web interface on HOST and PORT . Open the web interface in your web browser at http://<HOST>:<PORT> . Launch an existing session # python app.py <tag> To see all available tags use the -L switch. python app.py -L Open the web interface in your web browser at http://<HOST>:<PORT> . ReqAnalyzer # With Hanfor you can formalize requirements and export them. Ultimate ReqAnalyzer is a tool to analyze the formalized requirements and part of the released tools of Ultimate . Variant 1: Use the latest release # Install Java JRE (11) Download one of the latest nightly builds . Depending on your OS, you need to download UReqCheck-linux.zip or UReqCheck-win32.zip . Variant 2: Build the latest development version # Install Java JDK (11) and Maven (>=3.6) Clone the repository: git clone https://github.com/ultimate-pa/ultimate . Navigate to the release scripts cd ultimate/releaseScripts/default Build the latest binaries by executing ./makeFresh.sh . This also works on Windows if you use a bash shell (e.g., from WSL or GitBash). After a successful build, the binaries are located in UReqCheck-linux and UReqCheck-win32 , respectively. In the Workflow section we explain how to use the tool.","title":"Installation"},{"location":"installation/installation.html#installation","text":"","title":"Installation"},{"location":"installation/installation.html#prerequisites","text":"Python ( Note : Hanfor is only tested with Python 3.9.x) pip","title":"Prerequisites"},{"location":"installation/installation.html#install-hanfor","text":"To get Hanfor either download the .zip file or clone the repository.","title":"Install Hanfor"},{"location":"installation/installation.html#install-dependencies","text":"We recommend using a virtual environment . Linux Windows cd hanfor/hanfor python -m venv hanfor_venv source hanfor_venv/bin/activate cd hanfor \\h anfor python -m venv hanfor_venv hanfor_venv \\S cripts \\a ctivate.bat Install all Python dependencies. pip install -r requirements.txt Install the Z3 Theorem Prover. pysmt-install --z3","title":"Install dependencies"},{"location":"installation/installation.html#configuration","text":"Copy the default config file config.dist.py to config.py . Linux Windows cp config.dist.py config.py copy config.dist.py config.py The config file config.py allows you to change various parameters -- see the comments in config.dist.py .","title":"Configuration"},{"location":"installation/installation.html#launch-a-hanfor-session","text":"","title":"Launch a Hanfor session"},{"location":"installation/installation.html#reqanalyzer","text":"With Hanfor you can formalize requirements and export them. Ultimate ReqAnalyzer is a tool to analyze the formalized requirements and part of the released tools of Ultimate .","title":"ReqAnalyzer"},{"location":"introduction/index.html","text":"What is Hanfor? # Hanfor is a tool that h elps an alyzing and fo rmalizing r equirements. The specification of requirements is a critical activity in software and system development. A defect in a requirement specification can result in a situation where a software or system is delivered that fullfills the given requirements, but does not satisfy the customer's needs due to erroneous requirments. Requirement analysis, as a human activity, is error-prone. Especially for large sets of requirements, it is difficult and time consuming to manually check whether a given property is satisfied or not. Requirement based testing is helpful to increase the efficiency during development. Obtaining a high test coverage on requirements often takes a long time. As the number of requirements increases over the releases, the test specifications have to cover more and more requirements. Hanfor is developed to ease the process of requirement analysis. Its method consists of three major steps to discover requirement defects and obtain test specifications based on a set of informal requirements (Figure 1): Requirement Formalization Requirement Check Test Generation Figure 1: The Hanfor tool discovers requirement defects and derives test specifications from a given set of informal requirements. Requirement Formalization # To make it possible for a computer to check a set of requirements for a given criteria, it has to \"understand\" the semantics of the requirements. This could be achieved by using formal languages, which usually share the fact that they are rarely understandable for humans. In this method we make use of a simple pattern language. The language is based on a restricted English grammar and hence looks like natural language. Requirements formalized in this specification language can automatically be translated into logics. Specification language # The grammar of the specification language is given below. A requirement is defined by an ID, a scope and a pattern. Scope and pattern are parameterised by expressions over system observables and durations. Some patterns require a more detailed description concerning the order or the realtime occurence of events. Note that not all combinations of scope and pattern are supported within the Hanfor tool. For more information, have a look at our pattern section . REQ ::= ID: SCOPE, PATTERN. SCOPE ::= Globally | Before EXPR | After EXPR | Between EXPR and EXPR | After EXPR until EXPR PATTERN ::= It is never the case that EXPR holds | It is always the case that EXPR holds | It is always the case that initially EXPR holds | It is always the case that if EXPR holds, then EXPR holds as well | Transitions to states in which EXPR holds occur at most twice | It is always the case that ORDER | It is always the case that REALTIME ORDER ::= If EXPR holds, then EXPR previously held | If EXPR holds and is succeded by EXPR, then EXPR previously held | If EXPR holds, then EXPR previously held and was preceeded by EXPR | If EXPR holds, then EXPR eventually holds and is succeeded by EXPR | If EXPR holds, then EXPR eventually holds | If EXPR holds, then EXPR eventually holds and is succeeded by EXPR where EXPR does not hold between EXPR and EXPR REALTIME ::= Once EXPR becomes satisfied, it holds for at least DURATION | Once EXPR becomes satisfied, it holds for less than DURATION | Once EXPR becomes satisfied, EXPR holds for at least DURATION | Once EXPR becomes satisfied and holds for at most DURATION, then EXPR holds afterwards | Once EXPR becomes satisfied, EXPR holds after at most DURATION | Once EXPR becomes satisfied, EXPR holds after at most DURATION for at least DURATION | EXPR holds at least every DURATION | EXPR holds after at most DURATION | If EXPR holds, then EXPR holds after at most DURATION | If EXPR holds for at least DURATION, then EXPR holds afterwards for at least DURATION | If EXPR holds for at least DURATION, then EXPR holds after at most DURATION | If EXPR holds for at least DURATION, then EXPR holds afterwards | If EXPR holds, then EXPR holds after at most DURATION for at least DURATION | If EXPR holds, then EXPR holds for at least DURATION | After EXPR holds for at least DURATION and EXPR holds, then EXPR holds | After EXPR holds for at least DURATION and EXPR holds, then EXPR holds after at most DURATION Figure 2 shows the toolchain for the translation of an informal requirement into a formalized version. In the first step, the informal requirement, given in natural language, is translated into the specification language. This process is done manually. The requirement expressed in the specification language is then automatically translated into a formula in realtime logic (the Duration Calculus). Figure 2: A specification language for real-time requirements is used as an intermediate step in the translation from informal to formalized requirements. Requirement Check # The Hanfor tool chain checks requirements for the following three correctness properties: Consistency Realtime-consistency Vacuity Consistency # A set of requirements is inconsistent, if there exists no system satisfying all requirements in the set. Consider the two requirements in the specification language given below. This set of requirements is obviously not consistent as there is no interpretation where the observable 'A' evaluates both to true and to false at each point in time. Example 1: Inconsistent requirements Req1: Globally, it is never the case that 'A' holds. Req2: Globally, it is always the case that 'A' holds. Inconsistency in a set of requirements can be resolved by erasing or changing requirements. Realtime-consistency (rt-consistency) # A set of requirements is rt-inconsistent, if there are conflicts between requirements that arise after a certain time. Example 2: Rt-inconsistent requirements Req3: Globally, it is always the case that if 'B' holds then 'C' holds after at most '5' time units. Req4: Globally, it is always the case that if 'A' holds then '!C' holds for at least '2' time units. Consider the two real-time requirements given above. The set of the two requirements is consistent. Figure 3 gives an example of an interpretation of 'A', 'B', and 'C' (in form of a timing diagram) that satisfies both requirments. Figure 3: Consistency of the set of requirements {Req3, Req4}. 'A' and 'B' occur at the same point in time for one time unit, then '!C' for two time units satisfies Req4, and 'C' occurring at time 5 satisfies Req3. However, there are assignments for which the requirements are in conflict, as depicted in the example trace (Figure 4). If 'A' and 'B'change values as shown in the figure, than at time 5, Req4 would only be satisfied if 'C' remained false while Req3 would only be satisfied if 'C' changed to true . Figure 4: Witness for the rt-inconsistency of the set of requirements {Req3, Req4}. From time 4 on, the system steers toward inevitable rt-inconsistency. There are several possibilities to resolve the rt-inconsistency in a set of requirements, e.g. by erasing, changing or adding requirements. Example 2 (Cont.): Resolving rt-inconsistency Erasing requirements e.g. Erase Req4 Changing requirements e.g. Make Req4 less restrictive: Req4': Globally, it is always the case that if 'A' holds and 'B' did not hold in the last 5 time units, then '!C' holds for at least '2' time units. Adding requirements e.g. Add the following requirement: Req5: Globally, it is always the case that if 'B' holds, '!A' holds for at least 5 time units. Vacuity # A set of requirements is vacuous, if the behaviour specified by the requirements cannot be triggered in a system satisfying all requirements. More intuitively spoken, a vacuous requirement can be imagined as dead code in an implementation: Both a vacouous requirement as well as dead code can be removed without changing the meaning of the remaining part. Consider again the requirements Req1 and Req4 given below. The set of requirements is consistent. However, the precondition of Req4 is never true as this would violate Req1. Req4 is therefore vacuously satisfied in this set of requirements. Example 3: Vacuous requirements Req1: Globally, it is never the case that 'A' holds. Req4: Globally, it is always the case that if 'A' holds then '!C' holds for at least '2' time units. There are several possibilities to resolve vacuity in a set of requirements. Example 3 (cont.): Resolving vacuity Erasing requirements e.g. Erase Req1 Changing requirements e.g. Make Req1 less restrictive: Req2': Before \"Startup\", it is never the case that 'A'holds. Test Generation # Formalized requirements can be used to automatically generate test specifications. An automatic test generation helps to reduce the time needed to write test specifications with a high coverage rate. The efficiency during development can be increased and the maintainability costs can be reduced. Algorithm # Testing requires information about observability. The system variables are therefore categorized into input, output, and hidden (i.e. internal) variables. A sequence of inputs deterministically causes the valuation of the output variable. Figure 5 shows an abstract view of a two-input system with the variables A , B and C . Figure 5: System S with input variables A , B , and output variable C . The test generation algorithm automatically generates system tests that are based only on the formalized requirements (i.e. do not depend on an additional system model). It generates at least one test case per output variable, but as most as many test cases such that every requirement is tested. Each generated test indicates the requirements that it is based on. It is ensured that the generated tests may not lead to false positives (i.e. the test case fails, although the system state is conform with the requirements). In case that there exist untestable requirements, the algorithm lists the set of untestable requirements. Test Cases # The test cases generated by Hanfor contain three sorts of information: A sequence of n inputs: The initial state of the system, as well as the inputs for steps 1 to n . The expected outcome: The expected valuation of the tested output variable. The indication on which requirements the test is based on. Consider the set of requirements given below. The variables A , B are considered to be inputs of the system (Figure 5), H and I are hidden variables, and C represents the output of the system. Example 4: Requirements to be tested Req1: Globally, it is always the case that if \u2018A\u2019 holds then \u2018H\u2019 holds after at most \u201810\u2019 time units. Req2: Globally, it is always the case that if \u2018B\u2019 holds then \u2018I\u2019 holds after at most \u201810\u2019 time units. Req3: Globally, it is always the case that if \u2018H AND I\u2019 holds then \u2018C\u2019 holds after at most \u201810\u2019 time units. The test generation tool outputs the following test case: Case SystemTest: TestGeneratorResult: Found Test for: [C] Test Vector: Set inputs: A := true, B := true Wait for at most 20 for: C == true, (req3) The given test case tests the output variable C based on the third requirement. The input sequence is specified by an initial state only, in which both input variables A and B are set to true . The output variable C is expected to evaluate to true after at most 20 time units. Tool support # Hanfor takes as input an exported .csv file from Doors and stores the requirements. Figure 7 shows a screenshot of requirements imported into a Hanfor session. There are two IDs, the Hanfor ID and the Doors ID, so that the two databases can be synchronized. The informal requirements are listed in the column 'Description'. Once a requirement is formalized in the specification language, it is listed in the column 'Formalization'. Figure 6: Requirements exported into a Hanfor session. Clicking on a requirement opens the modification page of the requirement (Figure 8). The requirement can be formalized in the specification language by using the drop-down lists for both scopes and patterns. The variables can be specified manually by using the autocomplete function of the signal database. Figure 7: Modification window of a single requirement. For more information about the usage of Hanfor, please have a look at the usage section.","title":"What is Hanfor?"},{"location":"introduction/index.html#what-is-hanfor","text":"Hanfor is a tool that h elps an alyzing and fo rmalizing r equirements. The specification of requirements is a critical activity in software and system development. A defect in a requirement specification can result in a situation where a software or system is delivered that fullfills the given requirements, but does not satisfy the customer's needs due to erroneous requirments. Requirement analysis, as a human activity, is error-prone. Especially for large sets of requirements, it is difficult and time consuming to manually check whether a given property is satisfied or not. Requirement based testing is helpful to increase the efficiency during development. Obtaining a high test coverage on requirements often takes a long time. As the number of requirements increases over the releases, the test specifications have to cover more and more requirements. Hanfor is developed to ease the process of requirement analysis. Its method consists of three major steps to discover requirement defects and obtain test specifications based on a set of informal requirements (Figure 1): Requirement Formalization Requirement Check Test Generation Figure 1: The Hanfor tool discovers requirement defects and derives test specifications from a given set of informal requirements.","title":"What is Hanfor?"},{"location":"introduction/index.html#requirement-formalization","text":"To make it possible for a computer to check a set of requirements for a given criteria, it has to \"understand\" the semantics of the requirements. This could be achieved by using formal languages, which usually share the fact that they are rarely understandable for humans. In this method we make use of a simple pattern language. The language is based on a restricted English grammar and hence looks like natural language. Requirements formalized in this specification language can automatically be translated into logics.","title":"Requirement Formalization"},{"location":"introduction/index.html#requirement-check","text":"The Hanfor tool chain checks requirements for the following three correctness properties: Consistency Realtime-consistency Vacuity","title":"Requirement Check"},{"location":"introduction/index.html#test-generation","text":"Formalized requirements can be used to automatically generate test specifications. An automatic test generation helps to reduce the time needed to write test specifications with a high coverage rate. The efficiency during development can be increased and the maintainability costs can be reduced.","title":"Test Generation"},{"location":"introduction/index.html#tool-support","text":"Hanfor takes as input an exported .csv file from Doors and stores the requirements. Figure 7 shows a screenshot of requirements imported into a Hanfor session. There are two IDs, the Hanfor ID and the Doors ID, so that the two databases can be synchronized. The informal requirements are listed in the column 'Description'. Once a requirement is formalized in the specification language, it is listed in the column 'Formalization'. Figure 6: Requirements exported into a Hanfor session. Clicking on a requirement opens the modification page of the requirement (Figure 8). The requirement can be formalized in the specification language by using the drop-down lists for both scopes and patterns. The variables can be specified manually by using the autocomplete function of the signal database. Figure 7: Modification window of a single requirement. For more information about the usage of Hanfor, please have a look at the usage section.","title":"Tool support"},{"location":"references/duration_calculus.html","text":"Duration Calculus # Hanfor automatically translates requirements, that are given in the natural-language-style specification language , into Counterexample Formulae, a small and comprehensible subset of Duration Calculus (DC). This short guide should enable you to read and interpret the Duration Calculus formulae provided within this documentation. It aims to give you an intuitive insight into the small fragment of Duration Calculus that we use in our tool. Duration Calculus uses time intervalls to express sequential behavior. Assuming that you are familiar with the basic concept of Boolean logic, there are only three additional operators that need to be introduced. Everywhere-Operator: \u2308 \u2309 The everywhere-operator applied to an expression describes an interval of arbitrary length (length > 0) in which the embraced expression holds. If the operator is kept empty, it describes a point interval (length = 0). Let 'A' be an expression. Consider the DC-formula: \u2308A\u2309 It describes an interval of arbitrary length (length > 0) in which expression 'A' holds. Length-Operator: \u2113 The length-operator is used to measure the length of an interval. Let 'A' be an expression. Consider the DC-formula: \u2308A\u2309 \u2227 \u2113 = 5 It describes an interval with a length of 5 time units in which expression 'A' holds. Chop-Operator: ; The chop-operator \"chops\" larger time intervals into smaller subintervals. Let 'A', 'B', and 'C' be expressions. Consider the DC-formula: \u2308A\u2309; \u2308B\u2309; \u2308C\u2309 It describes a behavior where first expression 'A' holds , then exprression 'B' holds, and finally expression 'C' holds. Note: All intervals may have an arbitrary length > 0 time units, as there is no explicit constraint on their duration. Counterexample Formulas # Now that we have looked at some necessary building blocks of DC, we can look at counterexample formulas. Counterexample Formula Formally, a counterexample formula \u03a8 is a DC-formula of the form: \u03a8 = (\u2308e1\u2309 \u2227 \u2113 ~ t1); ... ;(\u2308ek\u2309 \u2227 \u2113 ~ tk); true , where e1 to ek represent state expressions, t1 to tk are non-zero durations, and ~ \u220a [\u2264,\u2265] . In other words, the counterexample formula exactly describes the undesired behavior relative to the given requirement. In the following, you find some examples. In each we give a property in the natural-language-style specification language, the counterexample DC-formula describing the undesired behavior, and a short explanation. Example 1: Globally, it is always the case that 'Q' holds. Counterexample: (true; \u2308!Q\u2309; true) The counterexample DC-formula describes all behaviors that violate the given specification. In this example, the requirement is violated if there is an interval in which 'Q' does not hold. Example 2: Before 'Q', it is always the case that 'R' holds at least every '5' time units Counterexample: (\u2308!Q\u2309; \u2308(!Q && !R)\u2309 \u2227 \u2113 > 5; true) The requirement can only be violated within its scope. All countertraces therefore have in common that '!Q' holds until the violation occured. The requirement is violated if '!R' holds longer than 5 time units. Example 3: After 'Q', it is always the case that once 'R' becomes satisfied, it holds for less than '5' time units. Counterexample: (true; \u2308Q\u2309; true; \u2308!R\u2309; \u2308R\u2309 \u2227 \u2113 \u2265 5; true) The requirement can only be violated within its scope. All countertraces therefore have in common that 'Q' must hold before the violation occurs. 'R' becomes satisfied, when it toggles from false to true . The requirement is violated if 'R' holds for at least 5 time units.","title":"Duration Calculus"},{"location":"references/duration_calculus.html#duration-calculus","text":"Hanfor automatically translates requirements, that are given in the natural-language-style specification language , into Counterexample Formulae, a small and comprehensible subset of Duration Calculus (DC). This short guide should enable you to read and interpret the Duration Calculus formulae provided within this documentation. It aims to give you an intuitive insight into the small fragment of Duration Calculus that we use in our tool. Duration Calculus uses time intervalls to express sequential behavior. Assuming that you are familiar with the basic concept of Boolean logic, there are only three additional operators that need to be introduced. Everywhere-Operator: \u2308 \u2309 The everywhere-operator applied to an expression describes an interval of arbitrary length (length > 0) in which the embraced expression holds. If the operator is kept empty, it describes a point interval (length = 0). Let 'A' be an expression. Consider the DC-formula: \u2308A\u2309 It describes an interval of arbitrary length (length > 0) in which expression 'A' holds. Length-Operator: \u2113 The length-operator is used to measure the length of an interval. Let 'A' be an expression. Consider the DC-formula: \u2308A\u2309 \u2227 \u2113 = 5 It describes an interval with a length of 5 time units in which expression 'A' holds. Chop-Operator: ; The chop-operator \"chops\" larger time intervals into smaller subintervals. Let 'A', 'B', and 'C' be expressions. Consider the DC-formula: \u2308A\u2309; \u2308B\u2309; \u2308C\u2309 It describes a behavior where first expression 'A' holds , then exprression 'B' holds, and finally expression 'C' holds. Note: All intervals may have an arbitrary length > 0 time units, as there is no explicit constraint on their duration.","title":"Duration Calculus"},{"location":"references/duration_calculus.html#counterexample-formulas","text":"Now that we have looked at some necessary building blocks of DC, we can look at counterexample formulas. Counterexample Formula Formally, a counterexample formula \u03a8 is a DC-formula of the form: \u03a8 = (\u2308e1\u2309 \u2227 \u2113 ~ t1); ... ;(\u2308ek\u2309 \u2227 \u2113 ~ tk); true , where e1 to ek represent state expressions, t1 to tk are non-zero durations, and ~ \u220a [\u2264,\u2265] . In other words, the counterexample formula exactly describes the undesired behavior relative to the given requirement. In the following, you find some examples. In each we give a property in the natural-language-style specification language, the counterexample DC-formula describing the undesired behavior, and a short explanation. Example 1: Globally, it is always the case that 'Q' holds. Counterexample: (true; \u2308!Q\u2309; true) The counterexample DC-formula describes all behaviors that violate the given specification. In this example, the requirement is violated if there is an interval in which 'Q' does not hold. Example 2: Before 'Q', it is always the case that 'R' holds at least every '5' time units Counterexample: (\u2308!Q\u2309; \u2308(!Q && !R)\u2309 \u2227 \u2113 > 5; true) The requirement can only be violated within its scope. All countertraces therefore have in common that '!Q' holds until the violation occured. The requirement is violated if '!R' holds longer than 5 time units. Example 3: After 'Q', it is always the case that once 'R' becomes satisfied, it holds for less than '5' time units. Counterexample: (true; \u2308Q\u2309; true; \u2308!R\u2309; \u2308R\u2309 \u2227 \u2113 \u2265 5; true) The requirement can only be violated within its scope. All countertraces therefore have in common that 'Q' must hold before the violation occurs. 'R' becomes satisfied, when it toggles from false to true . The requirement is violated if 'R' holds for at least 5 time units.","title":"Counterexample Formulas"},{"location":"references/patterns.html","text":"Patterns # This section provides you with an overview of all the patterns that are currently supported in Hanfor. For each pattern, we give a description in the natural-language-style specification language , its undesired behavior represented as a Duration Calculus formula, and its Phase Event Automaton representation. Ultimate revision on Github that corresponds to this documention: 1801c32f3822548644a719612f8bf96bd982b5d1 Absence # Absence Globally # Globally, it is never the case that \"R\" holds Countertraces # true;\u2308R\u2309;true Phase Event Automata # Positive Examples: Absence - Globally Absence Before # Before \"P\", it is never the case that \"R\" holds Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309;true Phase Event Automata # Positive Examples: Absence - Before Absence After # After \"P\", it is never the case that \"R\" holds Countertraces # true;\u2308P\u2309;true;\u2308R\u2309;true Phase Event Automata # Positive Examples: Absence - After Absence Between # Between \"P\" and \"Q\", it is never the case that \"R\" holds Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: Absence - Between Absence AfterUntil # After \"P\" until \"Q\", it is never the case that \"R\" holds Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;true Phase Event Automata # Positive Examples: Absence - AfterUntil ConstrainedChain # ConstrainedChain Before # Before \"P\", it is always the case that if \"R\" holds, then \"S\" eventually holds and is succeeded by \"T\" where \"U\" does not hold between \"S\" and \"T\" Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309;\u2308(!P && !S)\u2309;\u2308P\u2309;true \u2308!P\u2309;\u2308(!P && R)\u2309;\u2308!P\u2309;\u2308(!P && S)\u2309;\u2308(!P && !T)\u2309;\u2308P\u2309;true \u2308!P\u2309;\u2308(!P && R)\u2309;\u2308!P\u2309;\u2308(!P && S)\u2309;\u2308(!P && !T)\u2309;\u2308(!P && (!T && U))\u2309;\u2308!P\u2309;\u2308(!P && T)\u2309;\u2308!P\u2309;\u2308P\u2309;true Phase Event Automata # ConstrainedChain Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds, then \"S\" eventually holds and is succeeded by \"T\" where \"U\" does not hold between \"S\" and \"T\" Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !S)\u2309;\u2308Q\u2309;true true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308(!Q && S)\u2309;\u2308(!Q && !T)\u2309;\u2308Q\u2309;true true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308(!Q && S)\u2309;\u2308(!Q && !T)\u2309;\u2308(!Q && (!T && U))\u2309;\u2308!Q\u2309;\u2308(!Q && T)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # DurationBoundL # DurationBoundL Globally # Globally, it is always the case that once \"R\" becomes satisfied, it holds for at least \"5\" time units Countertraces # true;\u2308!R\u2309;\u2308R\u2309 \u2227 \u2113 < 5;\u2308!R\u2309;true Phase Event Automata # DurationBoundL Before # Before \"P\", it is always the case that once \"R\" becomes satisfied, it holds for at least \"5\" time units Countertraces # \u2308!P\u2309;\u2308(!P && !R)\u2309;\u2308(!P && R)\u2309 \u2227 \u2113 < 5;\u2308(!P && !R)\u2309;true Phase Event Automata # DurationBoundL After # After \"P\", it is always the case that once \"R\" becomes satisfied, it holds for at least \"5\" time units Countertraces # true;\u2308P\u2309;true;\u2308!R\u2309;\u2308R\u2309 \u2227 \u2113 < 5;\u2308!R\u2309;true Phase Event Automata # DurationBoundL Between # Between \"P\" and \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for at least \"5\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 < 5;\u2308(!Q && !R)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # DurationBoundL AfterUntil # After \"P\" until \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for at least \"5\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 < 5;\u2308(!Q && !R)\u2309;true Phase Event Automata # DurationBoundU # DurationBoundU Globally # Globally, it is always the case that once \"R\" becomes satisfied, it holds for less than \"5\" time units Countertraces # true;\u2308R\u2309 \u2227 \u2113 \u2265 5;true Phase Event Automata # Positive Examples: DurationBoundU - Globally DurationBoundU Before # Before \"P\", it is always the case that once \"R\" becomes satisfied, it holds for less than \"5\" time units Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309 \u2227 \u2113 \u2265 5;true Phase Event Automata # Positive Examples: DurationBoundU - Before DurationBoundU After # After \"P\", it is always the case that once \"R\" becomes satisfied, it holds for less than \"5\" time units Countertraces # true;\u2308P\u2309;true;\u2308R\u2309 \u2227 \u2113 \u2265 5;true Phase Event Automata # Positive Examples: DurationBoundU - After DurationBoundU Between # Between \"P\" and \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for less than \"5\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 5;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: DurationBoundU - Between DurationBoundU AfterUntil # After \"P\" until \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for less than \"5\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 5;true Phase Event Automata # Positive Examples: DurationBoundU - AfterUntil EdgeResponseBoundL2 # EdgeResponseBoundL2 Globally # Globally, it is always the case that once \"R\" becomes satisfied, \"S\" holds for at least \"5\" time units Countertraces # true;\u2308!R\u2309;\u2308R\u2309;\u2308S\u2309 \u2227 \u2113 < 5;\u2308!S\u2309;true true;\u2308!R\u2309;\u2308(R && !S)\u2309;true Phase Event Automata # Positive Examples: EdgeResponseBoundL2 - Globally EdgeResponseBoundL2 Before # Before \"P\", it is always the case that once \"R\" becomes satisfied, \"S\" holds for at least \"5\" time units Countertraces # \u2308!P\u2309;\u2308(!P && !R)\u2309;\u2308(!P && R)\u2309;\u2308(!P && S)\u2309 \u2227 \u2113 < 5;\u2308(!P && !S)\u2309;true \u2308!P\u2309;\u2308(!P && !R)\u2309;\u2308(!P && (R && !S))\u2309;true Phase Event Automata # Positive Examples: EdgeResponseBoundL2 - Before EdgeResponseBoundL2 After # After \"P\", it is always the case that once \"R\" becomes satisfied, \"S\" holds for at least \"5\" time units Countertraces # true;\u2308P\u2309;true;\u2308!R\u2309;\u2308R\u2309;\u2308S\u2309 \u2227 \u2113 < 5;\u2308!S\u2309;true true;\u2308P\u2309;true;\u2308!R\u2309;\u2308(R && !S)\u2309;true Phase Event Automata # Positive Examples: EdgeResponseBoundL2 - After EdgeResponseBoundL2 Between # Between \"P\" and \"Q\", it is always the case that once \"R\" becomes satisfied, \"S\" holds for at least \"5\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && S)\u2309 \u2227 \u2113 < 5;\u2308(!Q && !S)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && (R && !S))\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # EdgeResponseBoundL2 AfterUntil # After \"P\" until \"Q\", it is always the case that once \"R\" becomes satisfied, \"S\" holds for at least \"5\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && S)\u2309 \u2227 \u2113 < 5;\u2308(!Q && !S)\u2309;true true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && (R && !S))\u2309;true Phase Event Automata # Positive Examples: EdgeResponseBoundL2 - AfterUntil EdgeResponseBoundU1 # EdgeResponseBoundU1 Globally # Globally, it is always the case that once \"R\" becomes satisfied and holds for at most \"5\" time units, then \"S\" holds afterwards Countertraces # true;\u2308!R\u2309;\u2308R\u2309 \u2227 \u2113 \u2264 5;\u2308(!R && !S)\u2309;true Phase Event Automata # Positive Examples: EdgeResponseBoundU1 - Globally EdgeResponseBoundU1 Before # Before \"P\", it is always the case that once \"R\" becomes satisfied and holds for at most \"5\" time units, then \"S\" holds afterwards Countertraces # \u2308!P\u2309;\u2308(!P && !R)\u2309;\u2308(!P && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!P && (!R && !S))\u2309;true Phase Event Automata # Positive Examples: EdgeResponseBoundU1 - Before EdgeResponseBoundU1 After # After \"P\", it is always the case that once \"R\" becomes satisfied and holds for at most \"5\" time units, then \"S\" holds afterwards Countertraces # true;\u2308P\u2309;true;\u2308!R\u2309;\u2308R\u2309 \u2227 \u2113 \u2264 5;\u2308(!R && !S)\u2309;true Phase Event Automata # Positive Examples: EdgeResponseBoundU1 - After EdgeResponseBoundU1 Between # Between \"P\" and \"Q\", it is always the case that once \"R\" becomes satisfied and holds for at most \"5\" time units, then \"S\" holds afterwards Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2264 5;\u2308(!Q && (!R && !S))\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: EdgeResponseBoundU1 - Between EdgeResponseBoundU1 AfterUntil # After \"P\" until \"Q\", it is always the case that once \"R\" becomes satisfied and holds for at most \"5\" time units, then \"S\" holds afterwards Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2264 5;\u2308(!Q && (!R && !S))\u2309;true Phase Event Automata # Positive Examples: EdgeResponseBoundU1 - AfterUntil EdgeResponseDelay # EdgeResponseDelay Globally # Globally, it is always the case that once \"R\" becomes satisfied, \"S\" holds after at most \"5\" time units Countertraces # true;\u2308!R\u2309;\u2308(R && !S)\u2309;\u2308!S\u2309 \u2227 \u2113 > 5;true Phase Event Automata # Positive Examples: EdgeResponseDelay - Globally EdgeResponseDelay Before # Before \"P\", it is always the case that once \"R\" becomes satisfied, \"S\" holds after at most \"5\" time units Countertraces # \u2308!P\u2309;\u2308(!P && !R)\u2309;\u2308(!P && (R && !S))\u2309;\u2308(!P && !S)\u2309 \u2227 \u2113 > 5;true Phase Event Automata # EdgeResponseDelay After # After \"P\", it is always the case that once \"R\" becomes satisfied, \"S\" holds after at most \"5\" time units Countertraces # true;\u2308P\u2309;true;\u2308!R\u2309;\u2308(R && !S)\u2309;\u2308!S\u2309 \u2227 \u2113 > 5;true Phase Event Automata # Positive Examples: EdgeResponseDelay - After EdgeResponseDelay Between # Between \"P\" and \"Q\", it is always the case that once \"R\" becomes satisfied, \"S\" holds after at most \"5\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && (R && !S))\u2309;\u2308(!Q && !S)\u2309 \u2227 \u2113 > 5;true;\u2308Q\u2309;true Phase Event Automata # EdgeResponseDelay AfterUntil # After \"P\" until \"Q\", it is always the case that once \"R\" becomes satisfied, \"S\" holds after at most \"5\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && (R && !S))\u2309;\u2308(!Q && !S)\u2309 \u2227 \u2113 > 5;true Phase Event Automata # EdgeResponseDelayBoundL2 # EdgeResponseDelayBoundL2 Globally # Globally, it is always the case that once \"R\" becomes satisfied, \"S\" holds after at most \"5\" time units for at least \"10\" time units Countertraces # true;\u2308!R\u2309;\u2308(R && !S)\u2309;\u2308!S\u2309 \u2227 \u2113 > 5;true true;\u2308!R\u2309;\u2308R\u2309;\u2308true\u2309 \u2227 \u2113 < 5;\u2308S\u2309 \u2227 \u2113 < 10;\u2308!S\u2309;true Phase Event Automata # Positive Examples: EdgeResponseDelayBoundL2 - Globally EdgeResponseDelayBoundL2 Before # Before \"P\", it is always the case that once \"R\" becomes satisfied, \"S\" holds after at most \"5\" time units for at least \"10\" time units Countertraces # \u2308!P\u2309;\u2308(!P && !R)\u2309;\u2308(!P && (R && !S))\u2309;\u2308(!P && !S)\u2309 \u2227 \u2113 > 5;true \u2308!P\u2309;\u2308(!P && !R)\u2309;\u2308(!P && R)\u2309;\u2308!P\u2309 \u2227 \u2113 < 5;\u2308(!P && S)\u2309 \u2227 \u2113 < 10;\u2308(!P && !S)\u2309;true Phase Event Automata # Positive Examples: EdgeResponseDelayBoundL2 - Before EdgeResponseDelayBoundL2 After # After \"P\", it is always the case that once \"R\" becomes satisfied, \"S\" holds after at most \"5\" time units for at least \"10\" time units Countertraces # true;\u2308P\u2309;true;\u2308!R\u2309;\u2308(R && !S)\u2309;\u2308!S\u2309 \u2227 \u2113 > 5;true true;\u2308P\u2309;true;\u2308!R\u2309;\u2308R\u2309;\u2308true\u2309 \u2227 \u2113 < 5;\u2308S\u2309 \u2227 \u2113 < 10;\u2308!S\u2309;true Phase Event Automata # Positive Examples: EdgeResponseDelayBoundL2 - After EdgeResponseDelayBoundL2 Between # Between \"P\" and \"Q\", it is always the case that once \"R\" becomes satisfied, \"S\" holds after at most \"5\" time units for at least \"10\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && (R && !S))\u2309;\u2308(!Q && !S)\u2309 \u2227 \u2113 > 5;true;\u2308Q\u2309;true true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309 \u2227 \u2113 < 5;\u2308(!Q && S)\u2309 \u2227 \u2113 < 10;\u2308(!Q && !S)\u2309;true;\u2308Q\u2309;true Phase Event Automata # EdgeResponseDelayBoundL2 AfterUntil # After \"P\" until \"Q\", it is always the case that once \"R\" becomes satisfied, \"S\" holds after at most \"5\" time units for at least \"10\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && (R && !S))\u2309;\u2308(!Q && !S)\u2309 \u2227 \u2113 > 5;true true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309 \u2227 \u2113 < 5;\u2308(!Q && S)\u2309 \u2227 \u2113 < 10;\u2308(!Q && !S)\u2309;true Phase Event Automata # Positive Examples: EdgeResponseDelayBoundL2 - AfterUntil ExistenceBoundU # ExistenceBoundU Globally # Globally, transitions to states in which \"R\" holds occur at most twice Countertraces # true;\u2308R\u2309;\u2308!R\u2309;\u2308R\u2309;\u2308!R\u2309;\u2308R\u2309;true Phase Event Automata # ExistenceBoundU Before # Before \"P\", transitions to states in which \"R\" holds occur at most twice Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309;\u2308(!P && !R)\u2309;\u2308(!P && R)\u2309;\u2308(!P && !R)\u2309;\u2308(!P && R)\u2309;true Phase Event Automata # ExistenceBoundU After # After \"P\", transitions to states in which \"R\" holds occur at most twice Countertraces # true;\u2308P\u2309;true;\u2308R\u2309;\u2308!R\u2309;\u2308R\u2309;\u2308!R\u2309;\u2308R\u2309;true Phase Event Automata # ExistenceBoundU Between # Between \"P\" and \"Q\", transitions to states in which \"R\" holds occur at most twice Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # ExistenceBoundU AfterUntil # After \"P\" until \"Q\", transitions to states in which \"R\" holds occur at most twice Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;true Phase Event Automata # Initialization # Initialization Globally # Globally, it is always the case that initially \"R\" holds Countertraces # \u2308!R\u2309;true Phase Event Automata # Initialization Before # Before \"P\", it is always the case that initially \"R\" holds Countertraces # \u2308(!P && !R)\u2309;true Phase Event Automata # Initialization After # After \"P\", it is always the case that initially \"R\" holds Countertraces # true;\u2308P\u2309;\u2308!R\u2309;true Phase Event Automata # Positive Examples: Initialization - After Initialization Between # Between \"P\" and \"Q\", it is always the case that initially \"R\" holds Countertraces # true;\u2308(P && !Q)\u2309;\u2308(!Q && !R)\u2309;true;\u2308Q\u2309;true Phase Event Automata # Positive Examples: Initialization - Between Initialization AfterUntil # After \"P\" until \"Q\", it is always the case that initially \"R\" holds Countertraces # true;\u2308P\u2309;\u2308(!Q && !R)\u2309;true Phase Event Automata # Positive Examples: Initialization - AfterUntil Invariance # Invariance Globally # Globally, it is always the case that if \"R\" holds, then \"S\" holds as well Countertraces # true;\u2308(R && !S)\u2309;true Phase Event Automata # Positive Examples: Invariance - Globally Invariance Before # Before \"P\", it is always the case that if \"R\" holds, then \"S\" holds as well Countertraces # \u2308!P\u2309;\u2308(!P && (R && !S))\u2309;true Phase Event Automata # Positive Examples: Invariance - Before Invariance After # After \"P\", it is always the case that if \"R\" holds, then \"S\" holds as well Countertraces # true;\u2308P\u2309;true;\u2308(R && !S)\u2309;true Phase Event Automata # Positive Examples: Invariance - After Invariance Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds, then \"S\" holds as well Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && (R && !S))\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: Invariance - Between Invariance AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds, then \"S\" holds as well Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && (R && !S))\u2309;true Phase Event Automata # Positive Examples: Invariance - AfterUntil InvarianceBoundL2 # InvarianceBoundL2 Globally # Globally, it is always the case that if \"R\" holds, then \"S\" holds for at least \"5\" time units Countertraces # true;\u2308R\u2309;\u2308true\u2309 \u2227 \u2113 < 5;\u2308!S\u2309;true Phase Event Automata # Positive Examples: InvarianceBoundL2 - Globally InvarianceBoundL2 Before # Before \"P\", it is always the case that if \"R\" holds, then \"S\" holds for at least \"5\" time units Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309;\u2308!P\u2309 \u2227 \u2113 < 5;\u2308(!P && !S)\u2309;true Phase Event Automata # Positive Examples: InvarianceBoundL2 - Before InvarianceBoundL2 After # After \"P\", it is always the case that if \"R\" holds, then \"S\" holds for at least \"5\" time units Countertraces # true;\u2308P\u2309;true;\u2308R\u2309;\u2308true\u2309 \u2227 \u2113 < 5;\u2308!S\u2309;true Phase Event Automata # Positive Examples: InvarianceBoundL2 - After InvarianceBoundL2 Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds, then \"S\" holds for at least \"5\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309 \u2227 \u2113 < 5;\u2308(!Q && !S)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: InvarianceBoundL2 - Between InvarianceBoundL2 AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds, then \"S\" holds for at least \"5\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309 \u2227 \u2113 < 5;\u2308(!Q && !S)\u2309;true Phase Event Automata # Positive Examples: InvarianceBoundL2 - AfterUntil Persistence # Persistence Globally # Globally, it is always the case that if \"R\" holds, then it holds persistently Countertraces # true;\u2308R\u2309;\u2308!R\u2309;true Phase Event Automata # Persistence Before # Before \"P\", it is always the case that if \"R\" holds, then it holds persistently Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309;\u2308(!P && !R)\u2309;true Phase Event Automata # Persistence After # After \"P\", it is always the case that if \"R\" holds, then it holds persistently Countertraces # true;\u2308P\u2309;true;\u2308R\u2309;\u2308!R\u2309;true Phase Event Automata # Persistence Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds, then it holds persistently Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # Persistence AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds, then it holds persistently Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;true Phase Event Automata # Precedence # Precedence Globally # Globally, it is always the case that if \"R\" holds, then \"S\" previously held Countertraces # \u2308!S\u2309;\u2308R\u2309;true Phase Event Automata # Positive Examples: Precedence - Globally Precedence Before # Before \"P\", it is always the case that if \"R\" holds, then \"S\" previously held Countertraces # \u2308(!P && !S)\u2309;\u2308(!P && R)\u2309;true Phase Event Automata # Positive Examples: Precedence - Before Precedence After # After \"P\", it is always the case that if \"R\" holds, then \"S\" previously held Countertraces # true;\u2308P\u2309;\u2308!S\u2309;\u2308R\u2309;true Phase Event Automata # Positive Examples: Precedence - After Precedence Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds, then \"S\" previously held Countertraces # true;\u2308(P && (!Q && !S))\u2309;\u2308(!Q && !S)\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: Precedence - Between Precedence AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds, then \"S\" previously held Countertraces # true;\u2308P\u2309;\u2308(!Q && !S)\u2309;\u2308(!Q && R)\u2309;true Phase Event Automata # Positive Examples: Precedence - AfterUntil PrecedenceChain12 # PrecedenceChain12 Globally # Globally, it is always the case that if \"R\" holds and is succeeded by \"S\", then \"T\" previously held Countertraces # \u2308!T\u2309;\u2308R\u2309;true;\u2308S\u2309;true Phase Event Automata # Positive Examples: PrecedenceChain12 - Globally PrecedenceChain12 Before # Before \"P\", it is always the case that if \"R\" holds and is succeeded by \"S\", then \"T\" previously held Countertraces # \u2308(!P && !T)\u2309;\u2308(!P && R)\u2309;\u2308!P\u2309;\u2308(!P && S)\u2309;true Phase Event Automata # Positive Examples: PrecedenceChain12 - Before PrecedenceChain12 After # After \"P\", it is always the case that if \"R\" holds and is succeeded by \"S\", then \"T\" previously held Countertraces # true;\u2308P\u2309;\u2308!T\u2309;\u2308R\u2309;true;\u2308S\u2309;true Phase Event Automata # Positive Examples: PrecedenceChain12 - After PrecedenceChain12 Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds and is succeeded by \"S\", then \"T\" previously held Countertraces # true;\u2308(P && !Q)\u2309;\u2308(!Q && !T)\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308(!Q && S)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: PrecedenceChain12 - Between PrecedenceChain12 AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds and is succeeded by \"S\", then \"T\" previously held Countertraces # true;\u2308P\u2309;\u2308(!Q && !T)\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308(!Q && S)\u2309;true Phase Event Automata # Positive Examples: PrecedenceChain12 - AfterUntil PrecedenceChain21 # PrecedenceChain21 Globally # Globally, it is always the case that if \"R\" holds, then \"S\" previously held and was preceded by \"T\" Countertraces # \u2308!T\u2309;\u2308R\u2309;true \u2308!S\u2309;\u2308R\u2309;true \u2308!T\u2309;\u2308(S && !T)\u2309;\u2308!T\u2309;\u2308(!S && T)\u2309;\u2308!S\u2309;\u2308R\u2309;true Phase Event Automata # Positive Examples: PrecedenceChain21 - Globally PrecedenceChain21 Before # Before \"P\", it is always the case that if \"R\" holds, then \"S\" previously held and was preceded by \"T\" Countertraces # \u2308(!P && !T)\u2309;\u2308(!P && R)\u2309;true \u2308(!P && !S)\u2309;\u2308(!P && R)\u2309;true \u2308(!P && !T)\u2309;\u2308(!P && (S && !T))\u2309;\u2308(!P && !T)\u2309;\u2308(!P && (!S && T))\u2309;\u2308(!P && !S)\u2309;\u2308(!P && R)\u2309;true Phase Event Automata # Positive Examples: PrecedenceChain21 - Before PrecedenceChain21 After # After \"P\", it is always the case that if \"R\" holds, then \"S\" previously held and was preceded by \"T\" Countertraces # true;\u2308P\u2309;\u2308!T\u2309;\u2308R\u2309;true true;\u2308P\u2309;\u2308!S\u2309;\u2308R\u2309;true true;\u2308P\u2309;\u2308!T\u2309;\u2308(S && !T)\u2309;\u2308!T\u2309;\u2308(!S && T)\u2309;\u2308!S\u2309;\u2308R\u2309;true Phase Event Automata # Positive Examples: PrecedenceChain21 - After PrecedenceChain21 Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds, then \"S\" previously held and was preceded by \"T\" Countertraces # true;\u2308(P && !Q)\u2309;\u2308(!Q && !T)\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true true;\u2308(P && !Q)\u2309;\u2308(!Q && !S)\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true true;\u2308(P && !Q)\u2309;\u2308(!Q && !T)\u2309;\u2308(!Q && (S && !T))\u2309;\u2308(!Q && !T)\u2309;\u2308(!Q && (!S && T))\u2309;\u2308(!Q && !S)\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # PrecedenceChain21 AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds, then \"S\" previously held and was preceded by \"T\" Countertraces # true;\u2308P\u2309;\u2308(!Q && !T)\u2309;\u2308(!Q && R)\u2309;true true;\u2308P\u2309;\u2308(!Q && !S)\u2309;\u2308(!Q && R)\u2309;true true;\u2308P\u2309;\u2308(!Q && !T)\u2309;\u2308(!Q && (S && !T))\u2309;\u2308(!Q && !T)\u2309;\u2308(!Q && (!S && T))\u2309;\u2308(!Q && !S)\u2309;\u2308(!Q && R)\u2309;true Phase Event Automata # Positive Examples: PrecedenceChain21 - AfterUntil ReccurrenceBoundL # ReccurrenceBoundL Globally # Globally, it is always the case that \"R\" holds at least every \"5\" time units Countertraces # true;\u2308!R\u2309 \u2227 \u2113 > 5;true Phase Event Automata # ReccurrenceBoundL Before # Before \"P\", it is always the case that \"R\" holds at least every \"5\" time units Countertraces # \u2308!P\u2309;\u2308(!P && !R)\u2309 \u2227 \u2113 > 5;true Phase Event Automata # ReccurrenceBoundL After # After \"P\", it is always the case that \"R\" holds at least every \"5\" time units Countertraces # true;\u2308P\u2309;true;\u2308!R\u2309 \u2227 \u2113 > 5;true Phase Event Automata # ReccurrenceBoundL Between # Between \"P\" and \"Q\", it is always the case that \"R\" holds at least every \"5\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309 \u2227 \u2113 > 5;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: ReccurrenceBoundL - Between ReccurrenceBoundL AfterUntil # After \"P\" until \"Q\", it is always the case that \"R\" holds at least every \"5\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309 \u2227 \u2113 > 5;true Phase Event Automata # Response # Response Before # Before \"P\", it is always the case that if \"R\" holds, then \"S\" eventually holds Countertraces # \u2308!P\u2309;\u2308(!P && (R && !S))\u2309;\u2308(!P && !S)\u2309;\u2308P\u2309;true Phase Event Automata # Positive Examples: Response - Before Response Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds, then \"S\" eventually holds Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && (R && !S))\u2309;\u2308(!Q && !S)\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: Response - Between Response AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds, then \"S\" eventually holds Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && (R && !S))\u2309;\u2308(!Q && !S)\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: Response - AfterUntil ResponseBoundL1 # ResponseBoundL1 Globally # Globally, it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds afterwards Countertraces # true;\u2308R\u2309 \u2227 \u2113 \u2265 5;\u2308!S\u2309;true Phase Event Automata # Positive Examples: ResponseBoundL1 - Globally ResponseBoundL1 Before # Before \"P\", it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds afterwards Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!P && !S)\u2309;true Phase Event Automata # Positive Examples: ResponseBoundL1 - Before ResponseBoundL1 After # After \"P\", it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds afterwards Countertraces # true;\u2308P\u2309;true;\u2308R\u2309 \u2227 \u2113 \u2265 5;\u2308!S\u2309;true Phase Event Automata # Positive Examples: ResponseBoundL1 - After ResponseBoundL1 Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds afterwards Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!Q && !S)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: ResponseBoundL1 - Between ResponseBoundL1 AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds afterwards Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!Q && !S)\u2309;true Phase Event Automata # Positive Examples: ResponseBoundL1 - AfterUntil ResponseBoundL12 # ResponseBoundL12 Globally # Globally, it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds afterwards for at least \"10\" time units Countertraces # true;\u2308R\u2309 \u2227 \u2113 \u2265 5;\u2308S\u2309 \u2227 \u2113 <\u2080 10;\u2308!S\u2309;true Phase Event Automata # Positive Examples: ResponseBoundL12 - Globally ResponseBoundL12 Before # Before \"P\", it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds afterwards for at least \"10\" time units Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!P && S)\u2309 \u2227 \u2113 <\u2080 10;\u2308(!P && !S)\u2309;true Phase Event Automata # Positive Examples: ResponseBoundL12 - Before ResponseBoundL12 After # After \"P\", it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds afterwards for at least \"10\" time units Countertraces # true;\u2308P\u2309;\u2308R\u2309 \u2227 \u2113 \u2265 5;\u2308S\u2309 \u2227 \u2113 <\u2080 10;\u2308!S\u2309;true Phase Event Automata # Positive Examples: ResponseBoundL12 - After ResponseBoundL12 Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds afterwards for at least \"10\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!Q && S)\u2309 \u2227 \u2113 <\u2080 10;\u2308(!Q && !S)\u2309;true;\u2308Q\u2309;true Phase Event Automata # ResponseBoundL12 AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds afterwards for at least \"10\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!Q && S)\u2309 \u2227 \u2113 <\u2080 10;\u2308(!Q && !S)\u2309;true Phase Event Automata # Positive Examples: ResponseBoundL12 - AfterUntil ResponseChain12 # ResponseChain12 Before # Before \"P\", it is always the case that if \"R\" holds, then \"S\" eventually holds and is succeeded by \"T\" Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309;\u2308(!P && !S)\u2309;\u2308P\u2309;true \u2308!P\u2309;\u2308(!P && R)\u2309;\u2308!P\u2309;\u2308(!P && S)\u2309;\u2308(!P && !T)\u2309;\u2308P\u2309;true Phase Event Automata # Positive Examples: ResponseChain12 - Before ResponseChain12 Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds, then \"S\" eventually holds and is succeeded by \"T\" Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !S)\u2309;\u2308Q\u2309;true true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308(!Q && S)\u2309;\u2308(!Q && !T)\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: ResponseChain12 - Between ResponseChain12 AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds, then \"S\" eventually holds and is succeeded by \"T\" Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !S)\u2309;\u2308Q\u2309;true true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308(!Q && S)\u2309;\u2308(!Q && !T)\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: ResponseChain12 - AfterUntil ResponseDelay # ResponseDelay Globally # Globally, it is always the case that if \"R\" holds, then \"S\" holds after at most \"5\" time units Countertraces # true;\u2308(R && !S)\u2309;\u2308!S\u2309 \u2227 \u2113 > 5;true Phase Event Automata # Positive Examples: ResponseDelay - Globally ResponseDelay Before # Before \"P\", it is always the case that if \"R\" holds, then \"S\" holds after at most \"5\" time units Countertraces # \u2308!P\u2309;\u2308(!P && (R && !S))\u2309;\u2308(!P && !S)\u2309 \u2227 \u2113 > 5;true Phase Event Automata # ResponseDelay After # After \"P\", it is always the case that if \"R\" holds, then \"S\" holds after at most \"5\" time units Countertraces # true;\u2308P\u2309;true;\u2308(R && !S)\u2309;\u2308!S\u2309 \u2227 \u2113 > 5;true Phase Event Automata # Positive Examples: ResponseDelay - After ResponseDelay Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds, then \"S\" holds after at most \"5\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && (R && !S))\u2309;\u2308(!Q && !S)\u2309 \u2227 \u2113 > 5;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # ResponseDelay AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds, then \"S\" holds after at most \"5\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && (R && !S))\u2309;\u2308(!Q && !S)\u2309 \u2227 \u2113 > 5;true Phase Event Automata # ResponseDelayBoundL1 # ResponseDelayBoundL1 Globally # Globally, it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds after at most \"10\" time units Countertraces # true;\u2308R\u2309 \u2227 \u2113 \u2265 5;\u2308!S\u2309 \u2227 \u2113 > 10;true Phase Event Automata # Positive Examples: ResponseDelayBoundL1 - Globally ResponseDelayBoundL1 Before # Before \"P\", it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds after at most \"10\" time units Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!P && !S)\u2309 \u2227 \u2113 > 10;true Phase Event Automata # ResponseDelayBoundL1 After # After \"P\", it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds after at most \"10\" time units Countertraces # true;\u2308P\u2309;true;\u2308R\u2309 \u2227 \u2113 \u2265 5;\u2308!S\u2309 \u2227 \u2113 > 10;true Phase Event Automata # Positive Examples: ResponseDelayBoundL1 - After ResponseDelayBoundL1 Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds after at most \"10\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!Q && !S)\u2309 \u2227 \u2113 > 10;true;\u2308Q\u2309;true Phase Event Automata # ResponseDelayBoundL1 AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds for at least \"5\" time units, then \"S\" holds after at most \"10\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!Q && !S)\u2309 \u2227 \u2113 > 10;true Phase Event Automata # ResponseDelayBoundL2 # ResponseDelayBoundL2 Globally # Globally, it is always the case that if \"R\" holds, then \"S\" holds after at most \"5\" time units for at least \"10\" time units Countertraces # true;\u2308R\u2309;\u2308!S\u2309 \u2227 \u2113 > 5;true true;\u2308R\u2309;\u2308!S\u2309 \u2227 \u2113 <\u2080 5;\u2308S\u2309 \u2227 \u2113 < 10;\u2308!S\u2309;true Phase Event Automata # Positive Examples: ResponseDelayBoundL2 - Globally ResponseDelayBoundL2 Before # Before \"P\", it is always the case that if \"R\" holds, then \"S\" holds after at most \"5\" time units for at least \"10\" time units Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309;\u2308(!P && !S)\u2309 \u2227 \u2113 > 5;true \u2308!P\u2309;\u2308(!P && R)\u2309;\u2308(!P && !S)\u2309 \u2227 \u2113 <\u2080 5;\u2308(!P && S)\u2309 \u2227 \u2113 < 10;\u2308(!P && !S)\u2309;true Phase Event Automata # Positive Examples: ResponseDelayBoundL2 - Before ResponseDelayBoundL2 After # After \"P\", it is always the case that if \"R\" holds, then \"S\" holds after at most \"5\" time units for at least \"10\" time units Countertraces # true;\u2308P\u2309;true;\u2308R\u2309;\u2308!S\u2309 \u2227 \u2113 > 5;true true;\u2308P\u2309;true;\u2308R\u2309;\u2308!S\u2309 \u2227 \u2113 <\u2080 5;\u2308S\u2309 \u2227 \u2113 < 10;\u2308!S\u2309;true Phase Event Automata # Positive Examples: ResponseDelayBoundL2 - After ResponseDelayBoundL2 Between # Between \"P\" and \"Q\", it is always the case that if \"R\" holds, then \"S\" holds after at most \"5\" time units for at least \"10\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !S)\u2309 \u2227 \u2113 > 5;true;\u2308Q\u2309;true true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !S)\u2309 \u2227 \u2113 <\u2080 5;\u2308(!Q && S)\u2309 \u2227 \u2113 < 10;\u2308(!Q && !S)\u2309;true;\u2308Q\u2309;true Phase Event Automata # ResponseDelayBoundL2 AfterUntil # After \"P\" until \"Q\", it is always the case that if \"R\" holds, then \"S\" holds after at most \"5\" time units for at least \"10\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !S)\u2309 \u2227 \u2113 > 5;true true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !S)\u2309 \u2227 \u2113 <\u2080 5;\u2308(!Q && S)\u2309 \u2227 \u2113 < 10;\u2308(!Q && !S)\u2309;true Phase Event Automata # Positive Examples: ResponseDelayBoundL2 - AfterUntil TriggerResponseBoundL1 # TriggerResponseBoundL1 Globally # Globally, it is always the case that after \"R\" holds for at least \"5\" time units and \"S\" holds, then \"T\" holds Countertraces # true;\u2308R\u2309 \u2227 \u2113 \u2265 5;\u2308(R && (S && !T))\u2309;true Phase Event Automata # Positive Examples: TriggerResponseBoundL1 - Globally TriggerResponseBoundL1 Before # Before \"P\", it is always the case that after \"R\" holds for at least \"5\" time units and \"S\" holds, then \"T\" holds Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!P && (R && (S && !T)))\u2309;true Phase Event Automata # Positive Examples: TriggerResponseBoundL1 - Before TriggerResponseBoundL1 After # After \"P\", it is always the case that after \"R\" holds for at least \"5\" time units and \"S\" holds, then \"T\" holds Countertraces # true;\u2308P\u2309;true;\u2308R\u2309 \u2227 \u2113 \u2265 5;\u2308(R && (S && !T))\u2309;true Phase Event Automata # Positive Examples: TriggerResponseBoundL1 - After TriggerResponseBoundL1 Between # Between \"P\" and \"Q\", it is always the case that after \"R\" holds for at least \"5\" time units and \"S\" holds, then \"T\" holds Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!Q && (R && (S && !T)))\u2309;true;\u2308Q\u2309;true Phase Event Automata # Positive Examples: TriggerResponseBoundL1 - Between TriggerResponseBoundL1 AfterUntil # After \"P\" until \"Q\", it is always the case that after \"R\" holds for at least \"5\" time units and \"S\" holds, then \"T\" holds Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!Q && (R && (S && !T)))\u2309;true Phase Event Automata # Positive Examples: TriggerResponseBoundL1 - AfterUntil TriggerResponseDelayBoundL1 # TriggerResponseDelayBoundL1 Globally # Globally, it is always the case that after \"R\" holds for at least \"5\" time units and \"S\" holds, then \"T\" holds after at most \"10\" time units Countertraces # true;\u2308R\u2309 \u2227 \u2113 \u2265 5;\u2308(R && (S && !T))\u2309;\u2308!T\u2309 \u2227 \u2113 > 10;true Phase Event Automata # Positive Examples: TriggerResponseDelayBoundL1 - Globally TriggerResponseDelayBoundL1 Before # Before \"P\", it is always the case that after \"R\" holds for at least \"5\" time units and \"S\" holds, then \"T\" holds after at most \"10\" time units Countertraces # \u2308!P\u2309;\u2308(!P && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!P && (R && (S && !T)))\u2309;\u2308(!P && !T)\u2309 \u2227 \u2113 > 10;true Phase Event Automata # TriggerResponseDelayBoundL1 After # After \"P\", it is always the case that after \"R\" holds for at least \"5\" time units and \"S\" holds, then \"T\" holds after at most \"10\" time units Countertraces # true;\u2308P\u2309;true;\u2308R\u2309 \u2227 \u2113 \u2265 5;\u2308(R && (S && !T))\u2309;\u2308!T\u2309 \u2227 \u2113 > 10;true Phase Event Automata # Positive Examples: TriggerResponseDelayBoundL1 - After TriggerResponseDelayBoundL1 Between # Between \"P\" and \"Q\", it is always the case that after \"R\" holds for at least \"5\" time units and \"S\" holds, then \"T\" holds after at most \"10\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!Q && (R && (S && !T)))\u2309;\u2308(!Q && !T)\u2309 \u2227 \u2113 > 10;true;\u2308Q\u2309;true Phase Event Automata # TriggerResponseDelayBoundL1 AfterUntil # After \"P\" until \"Q\", it is always the case that after \"R\" holds for at least \"5\" time units and \"S\" holds, then \"T\" holds after at most \"10\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 5;\u2308(!Q && (R && (S && !T)))\u2309;\u2308(!Q && !T)\u2309 \u2227 \u2113 > 10;true Phase Event Automata # Universality # Universality Globally # Globally, it is always the case that \"R\" holds Countertraces # true;\u2308!R\u2309;true Phase Event Automata # Positive Examples: Universality - Globally Universality Before # Before \"P\", it is always the case that \"R\" holds Countertraces # \u2308!P\u2309;\u2308(!P && !R)\u2309;true Phase Event Automata # Positive Examples: Universality - Before Universality After # After \"P\", it is always the case that \"R\" holds Countertraces # true;\u2308P\u2309;true;\u2308!R\u2309;true Phase Event Automata # Positive Examples: Universality - After Universality Between # Between \"P\" and \"Q\", it is always the case that \"R\" holds Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # Positive Examples: Universality - Between Universality AfterUntil # After \"P\" until \"Q\", it is always the case that \"R\" holds Countertraces # true;\u2308P\u2309;\u2308!Q\u2309;\u2308(!Q && !R)\u2309;true Phase Event Automata # Positive Examples: Universality - AfterUntil UniversalityDelay # UniversalityDelay Globally # Globally, it is always the case that \"R\" holds after at most \"5\" time units Countertraces # \u2308true\u2309 \u2227 \u2113 \u2265 5;\u2308!R\u2309;true Phase Event Automata # Positive Examples: UniversalityDelay - Globally UniversalityDelay Before # Before \"P\", it is always the case that \"R\" holds after at most \"5\" time units Countertraces # \u2308!P\u2309 \u2227 \u2113 \u2265 5;\u2308(!P && !R)\u2309;true Phase Event Automata # Positive Examples: UniversalityDelay - Before UniversalityDelay After # After \"P\", it is always the case that \"R\" holds after at most \"5\" time units Countertraces # true;\u2308P\u2309;\u2308true\u2309 \u2227 \u2113 \u2265 5;\u2308!R\u2309;true Phase Event Automata # Positive Examples: UniversalityDelay - After UniversalityDelay Between # Between \"P\" and \"Q\", it is always the case that \"R\" holds after at most \"5\" time units Countertraces # true;\u2308(P && !Q)\u2309;\u2308!Q\u2309 \u2227 \u2113 \u2265 5;\u2308(!Q && !R)\u2309;true;\u2308Q\u2309;true Phase Event Automata # Positive Examples: UniversalityDelay - Between UniversalityDelay AfterUntil # After \"P\" until \"Q\", it is always the case that \"R\" holds after at most \"5\" time units Countertraces # true;\u2308P\u2309;\u2308!Q\u2309 \u2227 \u2113 \u2265 5;\u2308(!Q && !R)\u2309;true Phase Event Automata # Positive Examples: UniversalityDelay - AfterUntil","title":"Patterns"},{"location":"references/patterns.html#patterns","text":"This section provides you with an overview of all the patterns that are currently supported in Hanfor. For each pattern, we give a description in the natural-language-style specification language , its undesired behavior represented as a Duration Calculus formula, and its Phase Event Automaton representation. Ultimate revision on Github that corresponds to this documention: 1801c32f3822548644a719612f8bf96bd982b5d1","title":"Patterns"},{"location":"references/patterns.html#absence","text":"","title":"Absence"},{"location":"references/patterns.html#constrainedchain","text":"","title":"ConstrainedChain"},{"location":"references/patterns.html#durationboundl","text":"","title":"DurationBoundL"},{"location":"references/patterns.html#durationboundu","text":"","title":"DurationBoundU"},{"location":"references/patterns.html#edgeresponseboundl2","text":"","title":"EdgeResponseBoundL2"},{"location":"references/patterns.html#edgeresponseboundu1","text":"","title":"EdgeResponseBoundU1"},{"location":"references/patterns.html#edgeresponsedelay","text":"","title":"EdgeResponseDelay"},{"location":"references/patterns.html#edgeresponsedelayboundl2","text":"","title":"EdgeResponseDelayBoundL2"},{"location":"references/patterns.html#existenceboundu","text":"","title":"ExistenceBoundU"},{"location":"references/patterns.html#initialization","text":"","title":"Initialization"},{"location":"references/patterns.html#invariance","text":"","title":"Invariance"},{"location":"references/patterns.html#invarianceboundl2","text":"","title":"InvarianceBoundL2"},{"location":"references/patterns.html#persistence","text":"","title":"Persistence"},{"location":"references/patterns.html#precedence","text":"","title":"Precedence"},{"location":"references/patterns.html#precedencechain12","text":"","title":"PrecedenceChain12"},{"location":"references/patterns.html#precedencechain21","text":"","title":"PrecedenceChain21"},{"location":"references/patterns.html#reccurrenceboundl","text":"","title":"ReccurrenceBoundL"},{"location":"references/patterns.html#response","text":"","title":"Response"},{"location":"references/patterns.html#responseboundl1","text":"","title":"ResponseBoundL1"},{"location":"references/patterns.html#responseboundl12","text":"","title":"ResponseBoundL12"},{"location":"references/patterns.html#responsechain12","text":"","title":"ResponseChain12"},{"location":"references/patterns.html#responsedelay","text":"","title":"ResponseDelay"},{"location":"references/patterns.html#responsedelayboundl1","text":"","title":"ResponseDelayBoundL1"},{"location":"references/patterns.html#responsedelayboundl2","text":"","title":"ResponseDelayBoundL2"},{"location":"references/patterns.html#triggerresponseboundl1","text":"","title":"TriggerResponseBoundL1"},{"location":"references/patterns.html#triggerresponsedelayboundl1","text":"","title":"TriggerResponseDelayBoundL1"},{"location":"references/patterns.html#universality","text":"","title":"Universality"},{"location":"references/patterns.html#universalitydelay","text":"","title":"UniversalityDelay"},{"location":"references/pea.html","text":"Phase Event Automata # A phase event automaton (PEA) is a special automaton that allows to measure time. In Hanfor, PEAs are used to model the requirements that are already translated into DC-Counterexample Formulae . PEAs are used as an intermediate step between the formalized requirements and the requirements check respectively test generation procedure. In this documentation, we included the PEA representation of the available patterns as it often helps to get a more precise idea of what the exact meaning of a pattern is. Although a restricted english grammar is used to express requirements, it may happen that people have different interpretations of one and the same requirement. The PEA representation of a requirement however is unambiguous. This short guide should give you an intuitive understanding of how to interpret the phase event automata given in the pattern section of this documentation. If you are interested in a formal description of phase event automata, please refer to our paper \" Scalable Analysis of Real-Time Requirements \". Representation of PEAs # Figure 1 shows a phase event automaton representing the following requirement: req1: Globally, it is always the case that if \"R\" holds for at least \"5\" time units, then \"Q\" holds afterwards. First we will have a look at the different components that are used to depict a PEA. Variables: The variables and time constants that occur in the PEA are directly coming from the corresponding requirement. req1 contains two boolean variables, namely \"R\" and \"Q\", and the timing constant \"5\". Each timing constant is related to a unique clock variable. The timing constant and its corresponding clock variable can be found in the PEA as a boolean time constraint, e.g. \"c0<5\". The boolean variables can occur as unprimed variables (e.g. Q) and primed variables (e.g. Q'). Unprimed variables are related to the current point in time whereas primed variables are related to a point in time in the future. Phases: The PEA consists of locations or phases, and edges representing transistions between the phases. Each phase of the PEA consists of a unique name, a phase invariant and a clock invariant. E.g. consider the PEA phase given in Figure 2. The name is \"st01W\", the phase invariant is given by the expression \"R\" and the clock invariant by the time constraint \"c0<=5\". If a phase has an incoming edge that has no source, we call it \"initial\". Transitions: Each transition between phases is labeled with a boolean expression called \"guard\" and may additionally carry a clock reset statement. The guard may contain primed and unprimed variables as well as timing constraints. A transition from one phase to another can only be taken if the guarding expression is satisfied: This means that the guarding expression must evaluate to true under the current valuation (for unprimed variables and the clock constraint) together with the subsequent valuation (for the primed variables). If there is no constraint the guard is trivially satisfied and hence set to true . Run of a PEA # Next we want to be able to describe the behavior that is (not) included in a PEA. Other than most types of automata, a PEA has no explicit acceptance condition. A configuration of a PEA contains a location, a valuation of the variables and clocks, and a duration. A run of a PEA is a sequence of configurations such that the following conditions are satisfied: The location of the first configuration is initial. In each configuration, the valuation of variables fulfils the phase invariant of the corresponding location. In each configuration, the valuation of clocks and the clocks increased by the duration fulfils the clock invariant of the corresponding location. For every pair of consecutive configurations, there is an edge from the location of the predecessor configuration to the location of the consecutive configuration such that the guard is fulfilled. Example 1: Configurations of a PEA Consider the PEA for req1 (Figure 1). It contains the variables \"R, Q\", the clock variable \"c0\", and the locations \"st0, st01W, st01\". Below you find some configurations of the given PEA: (st0, {R= true , Q= false }, {c0=2}, 2) (st01W, {R= true , Q= true }, {c0=4}, 6) (st01, {R= false , Q= true }, {c0=7}, 3) Example 2: Run of a PEA Consider the PEA for req1 (Figure 1). It contains the variables \"R, Q\", the clock variable \"c0\", and the locations \"st0, st01W, st01\". The following sequence of three configurations describes a run of the given PEA: (st0, {R= false , Q= false }, {c0=2}, 4); (st01W, {R= true , Q= true }, {c0=4}, 1); (st01, {R= true , Q= true }, {c0=7}, 3) Let us check whether the conditions for a run are satisfied for all configurations in the sequence: 1. Configuration: The location \"st0\" is initial as it has an incoming edge without source. The phase invariant \"!R\" is fulfilled by the valuation \"R= false \". The clock invariant true can not be violated. There is an edge from location \"st0\" to the location \"st01W\" of the second configuration. The guard is true and can not be violated. 2. Configuration: The phase invariant \"R\" is fulfilled by the valuation \"R= true \". The clock invariant \"c0<=5\" is fulfilled by the clock valuation \"c0=4\" and also holds for the entire duration of \"1\". There is an edge from location \"st01W\" to the location \"st01\" of the third configuration with the guarding expression \"c0>=5\". The guard is fulfilled by the clock valuation increased by the duration. 3. Configuration: The phase invariant \"Q && R\" is fulfilled by the valuation \"R= true , Q= true \". The clock invariant is \" true \" and hence trivially satisfied. Example 3: Not-included Run of a PEA Consider the PEA for req1 (Figure 1). It contains the variables \"R, Q\", the clock variable \"c0\", and the locations \"st0, st01W, st01\". The following sequence of two configurations is not included in the given PEA: (st01W, {R= true , Q= true }, {c0=2}, 3); (st01, {R= true , Q= false }, {c0=7}, 32) Let us check whether the conditions for a run are satisfied for all configurations in the sequence: 1. Configuration: The location \"st01W\" is initial as it has an incoming edge without source. The phase invariant \"R\" is fulfilled by the valuation \"R= true \". The clock invariant \"c0<=5\" is fulfilled by the clock valuation \"c0=2\" and also holds for the entire duration of \"3\". There is an edge from location \"st01W\" to the location \"st01\" of the second configuration with the guarding expression \"c0>=5\". The guard is fulfilled by the clock valuation increased by the duration. 2. Configuration: The phase invariant \"Q && R\" is violated by the valuation \"Q= false \". The clock invariant is \" true \" and hence trivially satisfied. As the phase invariant conditio is violated in the second configuration, the given sequence is not included in the given PEA. Timing Diagram # As the tupel representation of a run is not necessarily intuitive, we often depict a run in form of a timing diagram. Below you find the timing diagram representation of the (not) included runs described in Example 1 and Example 2.","title":"Phase Event Automata"},{"location":"references/pea.html#phase-event-automata","text":"A phase event automaton (PEA) is a special automaton that allows to measure time. In Hanfor, PEAs are used to model the requirements that are already translated into DC-Counterexample Formulae . PEAs are used as an intermediate step between the formalized requirements and the requirements check respectively test generation procedure. In this documentation, we included the PEA representation of the available patterns as it often helps to get a more precise idea of what the exact meaning of a pattern is. Although a restricted english grammar is used to express requirements, it may happen that people have different interpretations of one and the same requirement. The PEA representation of a requirement however is unambiguous. This short guide should give you an intuitive understanding of how to interpret the phase event automata given in the pattern section of this documentation. If you are interested in a formal description of phase event automata, please refer to our paper \" Scalable Analysis of Real-Time Requirements \".","title":"Phase Event Automata"},{"location":"references/pea.html#representation-of-peas","text":"Figure 1 shows a phase event automaton representing the following requirement: req1: Globally, it is always the case that if \"R\" holds for at least \"5\" time units, then \"Q\" holds afterwards. First we will have a look at the different components that are used to depict a PEA. Variables: The variables and time constants that occur in the PEA are directly coming from the corresponding requirement. req1 contains two boolean variables, namely \"R\" and \"Q\", and the timing constant \"5\". Each timing constant is related to a unique clock variable. The timing constant and its corresponding clock variable can be found in the PEA as a boolean time constraint, e.g. \"c0<5\". The boolean variables can occur as unprimed variables (e.g. Q) and primed variables (e.g. Q'). Unprimed variables are related to the current point in time whereas primed variables are related to a point in time in the future. Phases: The PEA consists of locations or phases, and edges representing transistions between the phases. Each phase of the PEA consists of a unique name, a phase invariant and a clock invariant. E.g. consider the PEA phase given in Figure 2. The name is \"st01W\", the phase invariant is given by the expression \"R\" and the clock invariant by the time constraint \"c0<=5\". If a phase has an incoming edge that has no source, we call it \"initial\". Transitions: Each transition between phases is labeled with a boolean expression called \"guard\" and may additionally carry a clock reset statement. The guard may contain primed and unprimed variables as well as timing constraints. A transition from one phase to another can only be taken if the guarding expression is satisfied: This means that the guarding expression must evaluate to true under the current valuation (for unprimed variables and the clock constraint) together with the subsequent valuation (for the primed variables). If there is no constraint the guard is trivially satisfied and hence set to true .","title":"Representation of PEAs"},{"location":"references/pea.html#run-of-a-pea","text":"Next we want to be able to describe the behavior that is (not) included in a PEA. Other than most types of automata, a PEA has no explicit acceptance condition. A configuration of a PEA contains a location, a valuation of the variables and clocks, and a duration. A run of a PEA is a sequence of configurations such that the following conditions are satisfied: The location of the first configuration is initial. In each configuration, the valuation of variables fulfils the phase invariant of the corresponding location. In each configuration, the valuation of clocks and the clocks increased by the duration fulfils the clock invariant of the corresponding location. For every pair of consecutive configurations, there is an edge from the location of the predecessor configuration to the location of the consecutive configuration such that the guard is fulfilled. Example 1: Configurations of a PEA Consider the PEA for req1 (Figure 1). It contains the variables \"R, Q\", the clock variable \"c0\", and the locations \"st0, st01W, st01\". Below you find some configurations of the given PEA: (st0, {R= true , Q= false }, {c0=2}, 2) (st01W, {R= true , Q= true }, {c0=4}, 6) (st01, {R= false , Q= true }, {c0=7}, 3) Example 2: Run of a PEA Consider the PEA for req1 (Figure 1). It contains the variables \"R, Q\", the clock variable \"c0\", and the locations \"st0, st01W, st01\". The following sequence of three configurations describes a run of the given PEA: (st0, {R= false , Q= false }, {c0=2}, 4); (st01W, {R= true , Q= true }, {c0=4}, 1); (st01, {R= true , Q= true }, {c0=7}, 3) Let us check whether the conditions for a run are satisfied for all configurations in the sequence: 1. Configuration: The location \"st0\" is initial as it has an incoming edge without source. The phase invariant \"!R\" is fulfilled by the valuation \"R= false \". The clock invariant true can not be violated. There is an edge from location \"st0\" to the location \"st01W\" of the second configuration. The guard is true and can not be violated. 2. Configuration: The phase invariant \"R\" is fulfilled by the valuation \"R= true \". The clock invariant \"c0<=5\" is fulfilled by the clock valuation \"c0=4\" and also holds for the entire duration of \"1\". There is an edge from location \"st01W\" to the location \"st01\" of the third configuration with the guarding expression \"c0>=5\". The guard is fulfilled by the clock valuation increased by the duration. 3. Configuration: The phase invariant \"Q && R\" is fulfilled by the valuation \"R= true , Q= true \". The clock invariant is \" true \" and hence trivially satisfied. Example 3: Not-included Run of a PEA Consider the PEA for req1 (Figure 1). It contains the variables \"R, Q\", the clock variable \"c0\", and the locations \"st0, st01W, st01\". The following sequence of two configurations is not included in the given PEA: (st01W, {R= true , Q= true }, {c0=2}, 3); (st01, {R= true , Q= false }, {c0=7}, 32) Let us check whether the conditions for a run are satisfied for all configurations in the sequence: 1. Configuration: The location \"st01W\" is initial as it has an incoming edge without source. The phase invariant \"R\" is fulfilled by the valuation \"R= true \". The clock invariant \"c0<=5\" is fulfilled by the clock valuation \"c0=2\" and also holds for the entire duration of \"3\". There is an edge from location \"st01W\" to the location \"st01\" of the second configuration with the guarding expression \"c0>=5\". The guard is fulfilled by the clock valuation increased by the duration. 2. Configuration: The phase invariant \"Q && R\" is violated by the valuation \"Q= false \". The clock invariant is \" true \" and hence trivially satisfied. As the phase invariant conditio is violated in the second configuration, the given sequence is not included in the given PEA.","title":"Run of a PEA"},{"location":"references/pea.html#timing-diagram","text":"As the tupel representation of a run is not necessarily intuitive, we often depict a run in form of a timing diagram. Below you find the timing diagram representation of the (not) included runs described in Example 1 and Example 2.","title":"Timing Diagram"},{"location":"references/publications.html","text":"Publications # Hanfor: Semantic Requirements Review at Scale # Samuel Becker, Daniel Dietsch, Nico Hauff, Elisabeth Henkel, Vincent Langenfeld, Andreas Podelski, Bernd Westphal. Hanfor: Semantic Requirements Review at Scale. In REFSQ Workshops 2021 . image/svg+xml DOI PDF Cite @inproceedings{DBLP:conf/refsq/BeckerDHHLPW21, author = {Samuel Becker and Daniel Dietsch and Nico Hauff and Elisabeth Henkel and Vincent Langenfeld and Andreas Podelski and Bernd Westphal}, title = {Hanfor: Semantic Requirements Review at Scale}, booktitle = {{REFSQ} Workshops}, series = {{CEUR} Workshop Proceedings}, volume = {2857}, publisher = {CEUR-WS.org}, year = {2021} } Formal Requirements in an Informal World # Daniel Dietsch, Vincent Langenfeld, Bernd Westphal. Formal Requirements in an Informal World. In IEEE Workshop on Formal Requirements (FORMREQ) 2020 . image/svg+xml DOI PDF Cite @inproceedings{9224533, author={Daniel Dietsch and Vincent Langenfeld and Bernd Westphal}, title={Formal Requirements in an Informal World}, booktitle={2020 IEEE Workshop on Formal Requirements (FORMREQ)}, year={2020}, pages={14-20} doi={10.1109/FORMREQ51202.2020.00010}} Scalable Analysis of Real-Time Requirements # Vincent Langenfeld, Daniel Dietsch, Bernd Westphal, Jochen Hoenicke, and Amalinda Post. Scalable Analysis of Real-Time Requirements. image/svg+xml DOI PDF Cite @inproceedings{DBLP:conf/re/LangenfeldDWHP19, author = {Vincent Langenfeld and Daniel Dietsch and Bernd Westphal and Jochen Hoenicke and Amalinda Post}, title = {Scalable Analysis of Real-Time Requirements}, booktitle = {{RE}}, pages = {234--244}, publisher = {{IEEE}}, year = {2019} } Formalization and Analysis of Real-Time Requirements: a Feasibility Study at BOSCH # Amalinda Post and Jochen Hoenicke. Formalization and Analysis of Real-Time Requirements: a Feasibility Study at BOSCH. In VSTTE 12 , pp. 225\u2013240. Springer, 2012. image/svg+xml DOI PDF Cite @inproceedings{DBLP:conf/vstte/PostH12, author = {Amalinda Post and Jochen Hoenicke}, title = {Formalization and Analysis of Real-Time Requirements: {A} Feasibility Study at {BOSCH}}, booktitle = {{VSTTE}}, series = {Lecture Notes in Computer Science}, volume = {7152}, pages = {225--240}, publisher = {Springer}, year = {2012} } Vacuous real-time requirements # Amalinda Post, Jochen Hoenicke, and Andreas Podelski. Vacuous real-time requirements. In RE 11 , pp. 153\u2013162. IEEE, 2011. image/svg+xml DOI PDF Cite @inproceedings{DBLP:conf/re/PostHP11, author = {Amalinda Post and Jochen Hoenicke and Andreas Podelski}, title = {Vacuous real-time requirements}, booktitle = {{RE}}, pages = {153--162}, publisher = {{IEEE} Computer Society}, year = {2011} } rt-Inconsistency: A New Property for Real-Time Requirements # Amalinda Post, Jochen Hoenicke, and Andreas Podelski. rt-Inconsistency: A New Property for Real-Time Requirements. In FASE 2011 , volume 6603 in LNCS, pp. 34\u201349. Springer, 2011. image/svg+xml DOI PDF Cite @inproceedings{DBLP:conf/fase/PostHP11, author = {Amalinda Post and Jochen Hoenicke and Andreas Podelski}, title = {rt-Inconsistency: {A} New Property for Real-Time Requirements}, booktitle = {{FASE}}, series = {Lecture Notes in Computer Science}, volume = {6603}, pages = {34--49}, publisher = {Springer}, year = {2011} } Applying Restricted English Grammar on Automotive Requirements\u2014Does it Work? A Case Study # Amalinda Post, Igor Menzel, and Andreas Podelski. Applying Restricted English Grammar on Automotive Requirements\u2014Does it Work? A Case Study. In REFSQ 2011 , volume 6606 in LNCS, pp. 166\u2013180. Springer, 2011. image/svg+xml DOI PDF Cite @inproceedings{DBLP:conf/refsq/PostMP11, author = {Amalinda Post and Igor Menzel and Andreas Podelski}, title = {Applying Restricted English Grammar on Automotive Requirements - Does it Work? {A} Case Study}, booktitle = {{REFSQ}}, series = {Lecture Notes in Computer Science}, volume = {6606}, pages = {166--180}, publisher = {Springer}, year = {2011} }","title":"Publications"},{"location":"references/publications.html#publications","text":"","title":"Publications"},{"location":"references/publications.html#hanfor-semantic-requirements-review-at-scale","text":"Samuel Becker, Daniel Dietsch, Nico Hauff, Elisabeth Henkel, Vincent Langenfeld, Andreas Podelski, Bernd Westphal. Hanfor: Semantic Requirements Review at Scale. In REFSQ Workshops 2021 . image/svg+xml DOI PDF Cite @inproceedings{DBLP:conf/refsq/BeckerDHHLPW21, author = {Samuel Becker and Daniel Dietsch and Nico Hauff and Elisabeth Henkel and Vincent Langenfeld and Andreas Podelski and Bernd Westphal}, title = {Hanfor: Semantic Requirements Review at Scale}, booktitle = {{REFSQ} Workshops}, series = {{CEUR} Workshop Proceedings}, volume = {2857}, publisher = {CEUR-WS.org}, year = {2021} }","title":"Hanfor: Semantic Requirements Review at Scale"},{"location":"references/publications.html#formal-requirements-in-an-informal-world","text":"Daniel Dietsch, Vincent Langenfeld, Bernd Westphal. Formal Requirements in an Informal World. In IEEE Workshop on Formal Requirements (FORMREQ) 2020 . image/svg+xml DOI PDF Cite @inproceedings{9224533, author={Daniel Dietsch and Vincent Langenfeld and Bernd Westphal}, title={Formal Requirements in an Informal World}, booktitle={2020 IEEE Workshop on Formal Requirements (FORMREQ)}, year={2020}, pages={14-20} doi={10.1109/FORMREQ51202.2020.00010}}","title":"Formal Requirements in an Informal World"},{"location":"references/publications.html#scalable-analysis-of-real-time-requirements","text":"Vincent Langenfeld, Daniel Dietsch, Bernd Westphal, Jochen Hoenicke, and Amalinda Post. Scalable Analysis of Real-Time Requirements. image/svg+xml DOI PDF Cite @inproceedings{DBLP:conf/re/LangenfeldDWHP19, author = {Vincent Langenfeld and Daniel Dietsch and Bernd Westphal and Jochen Hoenicke and Amalinda Post}, title = {Scalable Analysis of Real-Time Requirements}, booktitle = {{RE}}, pages = {234--244}, publisher = {{IEEE}}, year = {2019} }","title":"Scalable Analysis of Real-Time Requirements"},{"location":"references/publications.html#formalization-and-analysis-of-real-time-requirements-a-feasibility-study-at-bosch","text":"Amalinda Post and Jochen Hoenicke. Formalization and Analysis of Real-Time Requirements: a Feasibility Study at BOSCH. In VSTTE 12 , pp. 225\u2013240. Springer, 2012. image/svg+xml DOI PDF Cite @inproceedings{DBLP:conf/vstte/PostH12, author = {Amalinda Post and Jochen Hoenicke}, title = {Formalization and Analysis of Real-Time Requirements: {A} Feasibility Study at {BOSCH}}, booktitle = {{VSTTE}}, series = {Lecture Notes in Computer Science}, volume = {7152}, pages = {225--240}, publisher = {Springer}, year = {2012} }","title":"Formalization and Analysis of Real-Time Requirements: a Feasibility Study at BOSCH"},{"location":"references/publications.html#vacuous-real-time-requirements","text":"Amalinda Post, Jochen Hoenicke, and Andreas Podelski. Vacuous real-time requirements. In RE 11 , pp. 153\u2013162. IEEE, 2011. image/svg+xml DOI PDF Cite @inproceedings{DBLP:conf/re/PostHP11, author = {Amalinda Post and Jochen Hoenicke and Andreas Podelski}, title = {Vacuous real-time requirements}, booktitle = {{RE}}, pages = {153--162}, publisher = {{IEEE} Computer Society}, year = {2011} }","title":"Vacuous real-time requirements"},{"location":"references/publications.html#rt-inconsistency-a-new-property-for-real-time-requirements","text":"Amalinda Post, Jochen Hoenicke, and Andreas Podelski. rt-Inconsistency: A New Property for Real-Time Requirements. In FASE 2011 , volume 6603 in LNCS, pp. 34\u201349. Springer, 2011. image/svg+xml DOI PDF Cite @inproceedings{DBLP:conf/fase/PostHP11, author = {Amalinda Post and Jochen Hoenicke and Andreas Podelski}, title = {rt-Inconsistency: {A} New Property for Real-Time Requirements}, booktitle = {{FASE}}, series = {Lecture Notes in Computer Science}, volume = {6603}, pages = {34--49}, publisher = {Springer}, year = {2011} }","title":"rt-Inconsistency: A New Property for Real-Time Requirements"},{"location":"references/publications.html#applying-restricted-english-grammar-on-automotive-requirementsdoes-it-work-a-case-study","text":"Amalinda Post, Igor Menzel, and Andreas Podelski. Applying Restricted English Grammar on Automotive Requirements\u2014Does it Work? A Case Study. In REFSQ 2011 , volume 6606 in LNCS, pp. 166\u2013180. Springer, 2011. image/svg+xml DOI PDF Cite @inproceedings{DBLP:conf/refsq/PostMP11, author = {Amalinda Post and Igor Menzel and Andreas Podelski}, title = {Applying Restricted English Grammar on Automotive Requirements - Does it Work? {A} Case Study}, booktitle = {{REFSQ}}, series = {Lecture Notes in Computer Science}, volume = {6606}, pages = {166--180}, publisher = {Springer}, year = {2011} }","title":"Applying Restricted English Grammar on Automotive Requirements\u2014Does it Work? A Case Study"},{"location":"references/patterns/ConstrainedChainPattern.html","text":"ConstrainedChainPattern # ConstrainedChainPattern Before # Before \"Q\", it is always the case that if \"W\" holds, then \"V\" eventually holds and is succeeded by \"U\" where \"T\" does not hold between \"V\" and \"U\" Countertraces # \u2308!Q\u2309;\u2308(!Q && W)\u2309;\u2308(!Q && !V)\u2309;\u2308Q\u2309;true \u2308!Q\u2309;\u2308(!Q && W)\u2309;\u2308!Q\u2309;\u2308(!Q && V)\u2309;\u2308(!Q && !U)\u2309;\u2308Q\u2309;true \u2308!Q\u2309;\u2308(!Q && W)\u2309;\u2308!Q\u2309;\u2308(!Q && V)\u2309;\u2308(!Q && !U)\u2309;\u2308(!Q && (T && !U))\u2309;\u2308!Q\u2309;\u2308(!Q && U)\u2309;\u2308!Q\u2309;\u2308Q\u2309;true Phase Event Automata # Examples # ConstrainedChainPattern Between # Between \"Q\" and \"R\", it is always the case that if \"X\" holds, then \"W\" eventually holds and is succeeded by \"V\" where \"U\" does not hold between \"W\" and \"V\" Countertraces # true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && X)\u2309;\u2308(!R && !W)\u2309;\u2308R\u2309;true true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && X)\u2309;\u2308!R\u2309;\u2308(!R && W)\u2309;\u2308(!R && !V)\u2309;\u2308R\u2309;true true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && X)\u2309;\u2308!R\u2309;\u2308(!R && W)\u2309;\u2308(!R && !V)\u2309;\u2308(!R && (U && !V))\u2309;\u2308!R\u2309;\u2308(!R && V)\u2309;\u2308!R\u2309;\u2308R\u2309;true Phase Event Automata # Examples # ConstrainedChainPattern AfterUntil # After \"Q\" until \"R\", it is always the case that if \"X\" holds, then \"W\" eventually holds and is succeeded by \"V\" where \"U\" does not hold between \"W\" and \"V\" Countertraces # true;\u2308Q\u2309;\u2308!R\u2309;\u2308(!R && X)\u2309;\u2308(!R && !W)\u2309;\u2308R\u2309;true true;\u2308Q\u2309;\u2308!R\u2309;\u2308(!R && X)\u2309;\u2308!R\u2309;\u2308(!R && W)\u2309;\u2308(!R && !V)\u2309;\u2308R\u2309;true true;\u2308Q\u2309;\u2308!R\u2309;\u2308(!R && X)\u2309;\u2308!R\u2309;\u2308(!R && W)\u2309;\u2308(!R && !V)\u2309;\u2308(!R && (U && !V))\u2309;\u2308!R\u2309;\u2308(!R && V)\u2309;\u2308!R\u2309;\u2308R\u2309;true Phase Event Automata # Examples #","title":"ConstrainedChainPattern"},{"location":"references/patterns/ConstrainedChainPattern.html#constrainedchainpattern","text":"","title":"ConstrainedChainPattern"},{"location":"usage/api_queries.html","text":"API queries # To generate reports or search for requirements not using the frontend Hanfor can be queried with HTTP requests at http(s)://{{your host}}/{{your URL_PREFIX}}/api/query Show stored queries # GET /api/query URL arguments # Name Type Description name string Name of the Query to retrieve a single Query. reload bool, optional Reevaluates all stored Queries. Examples # # Show all stored Queries curl http://localhost:5000/api/query # Show only Queries which are named 'MyQuery' and re-evaluate the stored Query curl http://localhost:5000/api/query?name = MyQuery & reload = true # Using jq to parse the JSON response. Show only the name of the query with associated hits. curl http://localhost:5000/api/query \\? reload \\= true | jq -r '.data[] | {name: .name, hits: .hits}' Adding new queries # POST /api/query Content-Type: application/json JSON body parameters # Name Type Description name string Name for the Query. Existing ones will be overridden. query string The search Query. Examples # curl -X POST -H 'Content-Type: application/json' \\ --data '{\"name\": \"MyQuery\", \"query\": \"foo:AND:bar\"}' http://localhost:5000/api/query Deleting queries # DELETE /api/query JSON body parameters # Name Type Description name string Name for the Query to be deleted. names list of strings Queries by name to be deleted. Examples # # Delete a single Query: curl -X DELETE -H 'Content-Type: application/json' \\ --data '{\"name\": \"MyQuery\"}' http://localhost:5000/api/query # Delete multiple Queries: curl -X DELETE -H 'Content-Type: application/json' \\ --data '{\"names\": [\"MyQuery\", \"Another\"]' http://localhost:5000/api/query Query syntax # Much like in the frontend the Query syntax supports operators, nesting, exact- exclusive matches and targeting specific attributes. Search operators # You can concatenate search Queries by search_1:OR:search_2 yields the union of search_1 and search_2. search_1:AND:search_2 yields the intersection of search_1 and search_2. :AND: binds stronger than :OR: . To invert the result use :NOT: before your search string. To change the precedence or to nest a Query ( and ) . Exact searches # You can get exact search results by using \" to indicate the beginning or end of a sequence. \"fast Includes faster but not breakfast. fast\" Includes breakfast but not faster. \"fast\" Includes only exact matches of fast. Target specific attributes # To limit a part of the search Query to one attribute use the syntax :DATA_TARGET:<the attribute name> Note: the attribute name must be enclosed with backticks. Get available attributes # GET /api/quer?show=targets Example # # Show attribute names available for specific search. curl http://localhost:5000/api/query?show = targets Default targets: The available targets are composed of [ \"Description\" , \"Formalization\" , \"Id\" , \"Status\" , \"Tags\" , \"Type\" ] Plus the fields available in the associated CSV file the requirements origin from.","title":"API queries"},{"location":"usage/api_queries.html#api-queries","text":"To generate reports or search for requirements not using the frontend Hanfor can be queried with HTTP requests at http(s)://{{your host}}/{{your URL_PREFIX}}/api/query","title":"API queries"},{"location":"usage/api_queries.html#show-stored-queries","text":"GET /api/query","title":"Show stored queries"},{"location":"usage/api_queries.html#adding-new-queries","text":"POST /api/query Content-Type: application/json","title":"Adding new queries"},{"location":"usage/api_queries.html#deleting-queries","text":"DELETE /api/query","title":"Deleting queries"},{"location":"usage/api_queries.html#query-syntax","text":"Much like in the frontend the Query syntax supports operators, nesting, exact- exclusive matches and targeting specific attributes.","title":"Query syntax"},{"location":"usage/faq.html","text":"FAQ # Add, remove, change patterns available. # The patterns available in hanfor are defined in the config.py file at the Available patterns section. Change the order the patterns appear in hanfors frontend pattern selection. # Patterns can be ordered by assigned groups or within their group. Assign a Pattern to a Group: Edit PATTERNS in the config.py Set PATTERN['Pattern_name']['group'] = 'your group name' . Change the order of the Groups: Edit PATTERNS_GROUP_ORDER in the config.py file. The order the groups appear in the list PATTERNS_GROUP_ORDER determine how they are ordered in the frontend. Change the order of pattern within groups Edit PATTERNS in the config.py file. Set PATTERN['Pattern_name']['pattern_order'] = 5 all patterns will be ordered ascending with respect to this setting. Change description or a field text in requirements table. # Currently there is only one way to achieve this: \u201cCreating a new revision\u201d: Edit the Description in the CSV -> edited.csv . Create a revision with the edited CSV as baseline: python app.py TAG_NAME -c path/to/edited.csv --revision This will check for changes in the CSV against the old one and create a new \u201cVersion\u201d aka. \u201cRevision\u201d.","title":"FAQ"},{"location":"usage/faq.html#faq","text":"","title":"FAQ"},{"location":"usage/faq.html#add-remove-change-patterns-available","text":"The patterns available in hanfor are defined in the config.py file at the Available patterns section.","title":"Add, remove, change patterns available."},{"location":"usage/faq.html#change-the-order-the-patterns-appear-in-hanfors-frontend-pattern-selection","text":"Patterns can be ordered by assigned groups or within their group. Assign a Pattern to a Group: Edit PATTERNS in the config.py Set PATTERN['Pattern_name']['group'] = 'your group name' . Change the order of the Groups: Edit PATTERNS_GROUP_ORDER in the config.py file. The order the groups appear in the list PATTERNS_GROUP_ORDER determine how they are ordered in the frontend. Change the order of pattern within groups Edit PATTERNS in the config.py file. Set PATTERN['Pattern_name']['pattern_order'] = 5 all patterns will be ordered ascending with respect to this setting.","title":"Change the order the patterns appear in hanfors frontend pattern selection."},{"location":"usage/faq.html#change-description-or-a-field-text-in-requirements-table","text":"Currently there is only one way to achieve this: \u201cCreating a new revision\u201d: Edit the Description in the CSV -> edited.csv . Create a revision with the edited CSV as baseline: python app.py TAG_NAME -c path/to/edited.csv --revision This will check for changes in the CSV against the old one and create a new \u201cVersion\u201d aka. \u201cRevision\u201d.","title":"Change description or a field text in requirements table."},{"location":"usage/requirements.html","text":"Requirements # Search in requirements table # Searching in the requirements table is accessible via the search tab. Typing in the search input supports autocomplete for extended search triggered by : . Search Operators # You can concatenate search queries by search_1:OR:search_2 yields the union of search_1 and search_2. search_1:AND:search_2 yields the intersection of search_1 and search_2. :AND: binds stronger than :OR: . To invert the result use :NOT: before your search string. Exact searches # You can get exact search results by using \" to indicate the beginning or end of a sequence. \"fast Includes faster but not breakfast. fast\" Includes breakfast but not faster. \"fast\" Includes only exact matches of fast. Search Target column To target a specific column use :COL_INDEX_02: to target column 2. The column indexes are appended in the requirements table header in parentheses. Mass edit requirements # You can mass edit requirements. Select requirements by clicking on the requirement checkbox in the table. Hold shift for multi select and Ctrl to toggle a single selection. Click on Edit Selected , fill out the form. Empty fields will have no effect.","title":"Requirements"},{"location":"usage/requirements.html#requirements","text":"","title":"Requirements"},{"location":"usage/requirements.html#search-in-requirements-table","text":"Searching in the requirements table is accessible via the search tab. Typing in the search input supports autocomplete for extended search triggered by : .","title":"Search in requirements table"},{"location":"usage/requirements.html#mass-edit-requirements","text":"You can mass edit requirements. Select requirements by clicking on the requirement checkbox in the table. Hold shift for multi select and Ctrl to toggle a single selection. Click on Edit Selected , fill out the form. Empty fields will have no effect.","title":"Mass edit requirements"},{"location":"usage/workflow.html","text":"Workflow # Example input # The CSV file example_intput/example_input.csv contains requirements: ID,Description,Type META1,This is an example for some requirements,meta META2,Next we define some requirements,meta REQ1,var1 is always greater than 5 ,requirement REQ2,var2 is always smaller than 10 ,requirement REQ3,constraint1 always holds,requirement REQ4,constraint2 always holds,requirement REQ5,var1 is always smaller than 5 ,requirement REQ6,constraint1 and constraint2 never hold at the same time,requirement REQ7,if var3 = True then var4 : = 1 ,requirement REQ8,if var3 = True then var4 : = 0 ,requirement In this case every row consists of the fields ID , Description , and Type . ID is a unique identifier, Description is the description , Type , is a type, in this example meta or requirement , where rows with type meta contain some meta-information and rows with type requirement contain actual requirements of the module you want to formalize. Start Hanfor # Configure Hanfor as explained in Installation Start Hanfor: cd hanfor python3 app.py -c ../example_input/example_input.csv awesome_tag -c example_input.csv specifies the csv input file we pass. example_tag is some meaningful tag you want to give this session. If you start Hanfor later with the same tag, you'll start exactly this session. Currently the startup of Hanfor is interactive and looks like this: ( venv ) bree@titan:~/repos/hanfor/hanfor$ python3 app.py -c ../example_input/example_input.csv awesome_tag 2019 -10-10 13 :55:17,845: [ DEBUG ] : Enabled logging. 2019 -10-10 13 :55:17,858: [ INFO ] : Hanfor starts creating a revision. 2019 -10-10 13 :55:17,858: [ INFO ] : No revisions for ` awesome_tag ` . Creating initial revision. 2019 -10-10 13 :55:17,858: [ INFO ] : Load Input : example/example_input.csv 2019 -10-10 13 :55:17,862: [ INFO ] : Could not guess .csv dialect, assuming defaults Select ID header \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 -> 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [ Choice or Enter for -> default ] > 1 Select requirements description header \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [ Choice or Enter for -> default ] > 0 Select formalization header \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u2551 3 \u2551 Add new Formalization \u2551 \u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [ Choice or Enter for -> default ] > 3 Select type header. \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [ Choice or Enter for -> default ] > 2 Alternatively you can directly pass the header definition, using --header : python3 app.py -c example_input/example_input.csv --header = '{\"csv_id_header\": \"ID\", \"csv_desc_header\": \"Description\", \"csv_formal_header\": \"Hanfor_Formalization\", \"csv_type_header\" : \"Type\"}' awesome_tag you can now reach Hanfor by visiting http://127.0.0.1:5000 Preprocessing # By default, all rows now have the status Todo . It might be the case that you want to change this for a certain set of rows to another status. In this example we want to set every row of type meta to the status Done . To accomplish this we use the Search Query Language . In Hanfor, search :COL_INDEX_04:meta . This will search for rows which match \"meta\" in the 4. coloumn (Type). You should now only see the rows of type meta . Select all rows by clicking All . Click Edit selected and select Done in the field Set status . Finally, click Apply changes to selected requirements Formalization # Order your requirement overview by Pos , by clicking on the table column. REQ1 # To formalize this requirement, we click on the ID REQ1 to open then formalization-modal: Click on + to add a new formalization and then on ..(click to open) We now have to select a Scope and a Pattern . The scope is Globally , because the requirement states that \"var1 is always greater than 5\". The pattern is it is always the case that {R} holds . For {R} we insert the condition: var1 > 5 Set the status to Review and then press save changes . If you save a requirement, Hanfor will automatically create the used variables and derive their type. You can examine and even alter them in the section Variables , for the case that Hanfor did not derive a variable-type correctly. The same procedure can be applied to REQ2 - REQ6 REQ7 and REQ8 # REQ7 and REQ8 are different. Consider REQ7: if var3 = True then var4 := 0 . The scope is still Globally The pattern is it is always the case that if \"{R}\" holds, then \"{S}\" holds after at most \"{T}\" time units , because in a realtime-system a variable assignment does not happen instantly, there can be delays. For {R} we insert var3 , because the variable type is boolean. For {S} insert var4 == 0 , For {T} we need a certain amount of time units, for example 50. We do not want to hardcode values, we introduce a new variable and insert MAX_TIME . We end up with the following: Globally, it is always the case that if \"var3\" holds, then \"var4 == 0\" holds after at most \"MAX_TIME\" time units. Save the formalization. You will now recognize that Hanfor automatically added a new Tag Type_inference_error to your freshly formalized requirement. To fix that, to go the Variables section and open the MAX_TIME variable. You see that Hanfor derived the type bool , but we actually want it to be of type CONST as the variable represents time units. Change the type and also assign a value, for example 50 . For REQ8 you should have: Globally, it is always the case that if \"var3\" holds, then \"var4 == 1\" holds after at most \"MAX_TIME\" time units. Exporting the formalized requirements. # Once you are done with all requirements, it is time to analyze them using a tool like Ultimate (TODO:ref to git). Preparing the export. # You might want to filter out some rows, for example, all of type meta or all that have a certain tag. Again, use the Search Query Language to select only the requirements you want. For example, if we only rows of type requirement which are not on status Todo we search: :COL_INDEX_04:requirement:AND::COL_INDEX_06::NOT:Todo Export # To export requirements, press Tools , then choose either .req or .csv . If you want to analyze the requirements using Ultimate, choose Generate .req file from (filtered) requirements table and then save it. You should end up with the following: CONST MAX_TIME IS 50.0 Input constraint1 IS bool Input constraint2 IS bool Input var1 IS int Input var2 IS int Input var3 IS bool Input var4 IS int REQ1_0: Globally, it is always the case that \"var1 > 5\" holds REQ2_0: Globally, it is always the case that \"var2 < 10\" holds REQ3_0: Globally, it is always the case that \"constraint1\" holds REQ4_0: Globally, it is always the case that \"constraint2\" holds REQ5_0: Globally, it is always the case that \"var1 < 5\" holds REQ6_0: Globally, it is never the case that \"constraint1 && constraint2 \" holds REQ7_0: Globally, it is always the case that if \"var3\" holds, then \"var4 == 1\" holds after at most \"MAX_TIME\" time units REQ8_0: Globally, it is always the case that if \"var3\" holds, then \"var4 == 0\" holds after at most \"MAX_TIME \" time units Analysis using Ultimate. # Get ReqAnalyzer # First of all you need the Ultimate tool ReqAnalyzer . See how in the ReqAnalyzer section. Perform the complete analysis. # We wrote a script, which perform a complete analysis, including the extraction of relevant information. The script is located in UReqCheck-linux . You have to configure run_complete_analysis.sh , which is used to run the complete analysis. The script takes several arguments: run_complete_analysis.sh <req_file> <req_repo_folder> <req_folder> [ <rt_inconsistency_range> <timeout_per_assertion> ] Where: * req_file is the Requirements file you generated using Hanfor. * req_repo_folder is the path to the repository, which contains the requirements-folder * req_folder is the path to the requirements-folder * rt_inconsistency_range (default: 2) is the amount of requirements which are checked together for RT-inconsistency. Careful with this parameter, it will blow up the amount of checks really fast. * timeout_per_assertion (default: 900) The time how long a singles assertion is checked. Use Ultimate # Execute the run_complete_analysis.sh script. cd /path/to/UReqCheck-linux ./run_complete_analysis.sh path/to/repo/example_input/example_input.req path/to/repo/example_input path/to/repo/example_input This will start Ultimate and run an analysis. The analysis checks for rt-inconsistency and vacuity and logs are be generated: hanfor/example/example_input.req.log hanfor/example/example_input.req.testgen.log hanfor/example/logs/example_input/example_input.req.relevant.log hanfor/example/logs/example_input/example_input.req.testgen.log Evaluate # In hanfor/example/example_input.req.log we can see that Ultimate reports: --- Results --- * Results from de.uni_freiburg.informatik.ultimate.pea2boogie: - RequirementInconsistentErrorResult: Requirements set is inconsistent. Requirements set is inconsistent. Some invariants are already infeasible. Responsible requirements: REQ6_0, REQ3_0, REQ4_0 Now, if we investigate REQ3, REQ4 and REQ6: REQ3_0: Globally, it is always the case that \"constraint1\" holds REQ4_0: Globally, it is always the case that \"constraint2\" holds REQ6_0: Globally, it is never the case that \"constraint1 && constraint2 \" holds We directly see what the problem is: On one hand, our invariants demand that constraint1 and constraint2 always holds, but on the other hand there is another invariant which demands that constraint1 and constraint2 never hold at the same time. Think about this as: constraint1 && constraint2 && ((constraint1 && !constraint2) || (!constraint1 && constraint2)) this is clearly unsatisfiable. Alter your requirements # We found an inconsistency in our requirements, that has to be fixed. Let's assume you review your requirements and you recognize REQ4 was defined wrong in the csv, where REQ4,constraint2 always holds,requirement should be REQ4,constraint2 never holds,requirement . While reading over the requirements, you also recognize that REQ1 and REQ5 collide and you find out that REQ5 shall be deleted. When we apply this changes, we end up with the following changes: Alter REQ4,constraint2 always holds,requirement to REQ4,constraint2 never holds,requirement Remove REQ5 and our csv file now looks as follows: ID,Description,Type META1,This is an example for some requirements,meta META2,Next we define some requirements,meta REQ1,var1 is always greater than 5 ,requirement REQ2,var2 is always smaller than 10 ,requirement REQ3,constraint1 always holds,requirement REQ4,constraint2 never holds,requirement REQ6,constraint1 and constraint2 never hold at the same time,requirement REQ7,if var3 = True then var4 = 0 ,requirement REQ8,if var3 = True then var4 = 1 ,requirement Time for a new revision. # We altered our requirements, we now need to create a new revision in Hanfor and change our formalizations. Execute: cd hanfor python3 app.py -r -c example/example_input.csv example_tag Hanfor will then ask: \"Which revision should I use as a base?\" , we choose revision_0 (as it is the only one, usually you want your latest revision). Then, Hanfor asks Should I use the csv header mapping from base revision? , as we did not change the csv header, we just keep the current one. A quick recap what happens when creating a revision: * New requirements get the tag revision_0_to_revision_1_new_requirement * Changed requirements get the tag revision_0_to_revision_1_data_changed and revision_0_to_revision_1_description_changed * Requirements where the formalization migrated to the new revision get the tag revision_0_to_revision_1_migrated_formalized We now have to alter the requirements which have changed, that's only REQ4 . Open the formalization of REQ4 and correct it to Globally, it is never the case that \"constraint2\" holds . Ultimate Analysis #2 # Export your requirements as before with the name example_input_revision1.req Run Ultimate on the new requirements file. You can now examine the log created in hanfor/example/logs/example_input/example_input.req.relevant.log , which contains the following: - ReqCheckFailResult [Line: -1]: Requirements REQ8_0, REQ7_0 are rt-inconsistent A ReqCheckFailResult usually implies that something is broken, Ultimate found that requirements REQ7 and REQ8 are rt-inconsistent, let's analyze this result: REQ7,if var3 = True then var4 = 0,requirement REQ8,if var3 = True then var4 = 1,requirement These two requirements collide, because they assign different values to var4 when var3 holds. This is especially bad in a realtime system, because it can happen that var4 == 0 holds after a certain amount of time, and var4 == 1 holds at a later point of time or vice versa. Why is this bad? - because it can cause unexpected behaviour when a change propagates through the system. Conclusion # You are now able to: Setup hanfor, Formalize requirements, Filter requirements, Export them to a .req file Run Ultimate on a .req file Interpret the results of Ultimate Create new revisions in hanfor to fix mistakes in requirements.","title":"Workflow"},{"location":"usage/workflow.html#workflow","text":"","title":"Workflow"},{"location":"usage/workflow.html#example-input","text":"The CSV file example_intput/example_input.csv contains requirements: ID,Description,Type META1,This is an example for some requirements,meta META2,Next we define some requirements,meta REQ1,var1 is always greater than 5 ,requirement REQ2,var2 is always smaller than 10 ,requirement REQ3,constraint1 always holds,requirement REQ4,constraint2 always holds,requirement REQ5,var1 is always smaller than 5 ,requirement REQ6,constraint1 and constraint2 never hold at the same time,requirement REQ7,if var3 = True then var4 : = 1 ,requirement REQ8,if var3 = True then var4 : = 0 ,requirement In this case every row consists of the fields ID , Description , and Type . ID is a unique identifier, Description is the description , Type , is a type, in this example meta or requirement , where rows with type meta contain some meta-information and rows with type requirement contain actual requirements of the module you want to formalize.","title":"Example input"},{"location":"usage/workflow.html#start-hanfor","text":"Configure Hanfor as explained in Installation Start Hanfor: cd hanfor python3 app.py -c ../example_input/example_input.csv awesome_tag -c example_input.csv specifies the csv input file we pass. example_tag is some meaningful tag you want to give this session. If you start Hanfor later with the same tag, you'll start exactly this session. Currently the startup of Hanfor is interactive and looks like this: ( venv ) bree@titan:~/repos/hanfor/hanfor$ python3 app.py -c ../example_input/example_input.csv awesome_tag 2019 -10-10 13 :55:17,845: [ DEBUG ] : Enabled logging. 2019 -10-10 13 :55:17,858: [ INFO ] : Hanfor starts creating a revision. 2019 -10-10 13 :55:17,858: [ INFO ] : No revisions for ` awesome_tag ` . Creating initial revision. 2019 -10-10 13 :55:17,858: [ INFO ] : Load Input : example/example_input.csv 2019 -10-10 13 :55:17,862: [ INFO ] : Could not guess .csv dialect, assuming defaults Select ID header \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 -> 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [ Choice or Enter for -> default ] > 1 Select requirements description header \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [ Choice or Enter for -> default ] > 0 Select formalization header \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u2551 3 \u2551 Add new Formalization \u2551 \u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [ Choice or Enter for -> default ] > 3 Select type header. \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [ Choice or Enter for -> default ] > 2 Alternatively you can directly pass the header definition, using --header : python3 app.py -c example_input/example_input.csv --header = '{\"csv_id_header\": \"ID\", \"csv_desc_header\": \"Description\", \"csv_formal_header\": \"Hanfor_Formalization\", \"csv_type_header\" : \"Type\"}' awesome_tag you can now reach Hanfor by visiting http://127.0.0.1:5000","title":"Start Hanfor"},{"location":"usage/workflow.html#preprocessing","text":"By default, all rows now have the status Todo . It might be the case that you want to change this for a certain set of rows to another status. In this example we want to set every row of type meta to the status Done . To accomplish this we use the Search Query Language . In Hanfor, search :COL_INDEX_04:meta . This will search for rows which match \"meta\" in the 4. coloumn (Type). You should now only see the rows of type meta . Select all rows by clicking All . Click Edit selected and select Done in the field Set status . Finally, click Apply changes to selected requirements","title":"Preprocessing"},{"location":"usage/workflow.html#formalization","text":"Order your requirement overview by Pos , by clicking on the table column.","title":"Formalization"},{"location":"usage/workflow.html#exporting-the-formalized-requirements","text":"Once you are done with all requirements, it is time to analyze them using a tool like Ultimate (TODO:ref to git).","title":"Exporting the formalized requirements."},{"location":"usage/workflow.html#analysis-using-ultimate","text":"","title":"Analysis using Ultimate."}]}