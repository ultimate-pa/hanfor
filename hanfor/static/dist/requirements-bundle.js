/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./js/requirements.js":
/*!****************************!*\
  !*** ./js/requirements.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var $ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n__webpack_require__(/*! gasparesganga-jquery-loading-overlay */ \"./node_modules/gasparesganga-jquery-loading-overlay/dist/loadingoverlay.min.js\")\nconst { Collapse, Modal } = __webpack_require__(/*! bootstrap */ \"./node_modules/bootstrap/dist/js/bootstrap.esm.js\")\n__webpack_require__(/*! datatables.net-bs5 */ \"./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs\")\n__webpack_require__(/*! datatables.net-select-bs5 */ \"./node_modules/datatables.net-select-bs5/js/select.bootstrap5.mjs\")\n__webpack_require__(/*! jquery-ui/ui/widgets/autocomplete */ \"./node_modules/jquery-ui/ui/widgets/autocomplete.js\")\n__webpack_require__(/*! jquery-ui/ui/effects/effect-highlight */ \"./node_modules/jquery-ui/ui/effects/effect-highlight.js\")\n__webpack_require__(/*! ./bootstrap-tokenfield.js */ \"./js/bootstrap-tokenfield.js\")\n__webpack_require__(/*! awesomplete */ \"./node_modules/awesomplete/awesomplete.js\")\n__webpack_require__(/*! awesomplete/awesomplete.css */ \"./node_modules/awesomplete/awesomplete.css\")\n//require('datatables.net-bs5-colreorderwithresize-npm');\n__webpack_require__(/*! datatables.net-colreorder-bs5 */ \"./node_modules/datatables.net-colreorder-bs5/js/colReorder.bootstrap5.mjs\")\n__webpack_require__(/*! ./bootstrap-confirm-button */ \"./js/bootstrap-confirm-button.js\")\n\nlet utils = __webpack_require__(/*! ./hanfor-utils */ \"./js/hanfor-utils.js\")\nconst autosize = __webpack_require__(/*! autosize/dist/autosize */ \"./node_modules/autosize/dist/autosize.js\")\n\n// Globals\nconst { SearchNode } = __webpack_require__(/*! ./datatables-advanced-search.js */ \"./js/datatables-advanced-search.js\")\nconst { init_simulator_tab } = __webpack_require__(/*! ./simulator-tab.js */ \"./js/simulator-tab.js\")\nconst { sendTelemetry } = __webpack_require__(/*! ../../telemetry/static/telemetry */ \"../telemetry/static/telemetry.js\")\n\nconst { Textcomplete } = __webpack_require__(/*! @textcomplete/core */ \"./node_modules/@textcomplete/core/dist/index.js\")\nconst { TextareaEditor } = __webpack_require__(/*! @textcomplete/textarea */ \"./node_modules/@textcomplete/textarea/dist/index.js\")\n\n//const {Modal} = require(\"bootstrap\");\n\nlet Fuse = __webpack_require__(/*! fuse.js */ \"./node_modules/fuse.js/dist/fuse.cjs\")\nlet fuse = new Fuse([], {})\n\nlet available_tags = [\"\", \"has_formalization\"]\nlet available_status = [\"\", \"Todo\", \"Review\", \"Done\"]\nlet search_autocomplete = [\n  \":AND:\",\n  \":OR:\",\n  \":NOT:\",\n  \":COL_INDEX_01:\",\n  \":COL_INDEX_02:\",\n  \":COL_INDEX_03:\",\n  \":COL_INDEX_04:\",\n  \":COL_INDEX_05:\",\n  \":COL_INDEX_06:\",\n  \":COL_INDEX_07:\",\n]\nlet available_types = [\"\"]\nlet available_vars = [\"\"]\nlet available_reports = []\nlet visible_columns = [true, true, true, true, true, true]\nlet filter_search_array = []\nlet get_query = JSON.parse(search_query) // search_query is set in layout.html\nlet tag_colors = {}\nlet type_inference_errors = []\nlet req_search_string = sessionStorage.getItem(\"req_search_string\")\nlet filter_status_string = sessionStorage.getItem(\"filter_status_string\")\nlet filter_tag_string = sessionStorage.getItem(\"filter_tag_string\")\nlet filter_type_string = sessionStorage.getItem(\"filter_type_string\")\nlet search_tree = undefined\nlet filter_tree = undefined\n\n/**\n * INDEX\n * =====================================================================================================================\n */\n$(document).ready(function () {\n  load_tags()\n  initialise_search_bar()\n  load_datatable()\n  init_modal()\n  update_logs()\n  init_report_generation()\n  init_simulator_tab()\n\n  let body = $(\"body\")\n  // Bind formalization deletion.\n  // body.confirmation({\n  //     rootSelector: '.delete_formalization',\n  //     selector: '.delete_formalization',\n  //     onConfirm: function () {\n  //         delete_formalization($(this).attr('name'), $(this).closest('.card'));\n  //     }\n  // });\n\n  $(\"body\").bootstrapConfirmButton({\n    selector: \".delete_formalization\",\n    onConfirm: function () {\n      delete_formalization($(this).attr(\"name\"), $(this).closest(\".accordion-item\"))\n    },\n  })\n\n  body.on(\"click\", \".delete_formalization1\", function () {\n    bootstrapConfirmation({\n      yesCallBack: function () {\n        console.log(\"yes\")\n      },\n      noCallBack: function () {\n        console.log(\"no\")\n      },\n      config: {\n        closeIcon: true,\n        message: \"This is an example.\",\n        title: \"Example\",\n        no: {\n          class: \"btn btn-danger\",\n          text: \"No\",\n        },\n        yes: {\n          class: \"btn btn-success\",\n          text: \"Yes\",\n        },\n      },\n    })\n  })\n\n  body.on(\"click\", \".copy_formalization\", function () {\n    copy_formalization($(this).attr(\"name\"))\n    $(this).addClass(\"animate-success\")\n    setTimeout(() => {\n      $(this).removeClass(\"animate-success\")\n    }, 600)\n  })\n\n  // Bind formalization update.\n  body.on(\"change\", \".formalization_selector, .reqirement-variable, .req_var_type\", function () {\n    update_formalization()\n  })\n  // Bind formalization variable update.\n  body.on(\"change\", \".formalization_selector\", function () {\n    update_vars()\n  })\n\n  /*\n    body.on('shown.bs.modal', '#requirement_modal', function () {\n        $(this).find('textarea').each(function () {\n            autosize($(this));\n            autosize.update($(this));\n        });\n    });\n    */\n\n  const requirement_modal = document.getElementById(\"requirement_modal\")\n  requirement_modal.addEventListener(\"shown.bs.modal\", function () {\n    $(this)\n      .find(\"textarea\")\n      .each(function () {\n        autosize($(this))\n        autosize.update($(this))\n      })\n  })\n\n  body.on(\"change focus\", \"textarea\", function () {\n    autosize($(this))\n    autosize.update($(this))\n  })\n  bind_tag_field_events()\n})\n\n/**\n * Fetch requirements from hanfor api and build the requirements table.\n * Apply search queries to table\n * Bind button/links to events.\n * @param columnDefs predefined columDefs (https://datatables.net/reference/option/columnDefs)\n */\nfunction init_datatable(columnDefs) {\n  let table = $(\"#requirements_table\").DataTable({\n    language: {\n      emptyTable: \"Loading data.\",\n    },\n    paging: true,\n    stateSave: true,\n    select: {\n      style: \"os\",\n      selector: \"td:first-child\",\n    },\n    order: [[1, \"asc\"]],\n    pageLength: 50,\n    lengthMenu: [\n      [10, 50, 100, 500, -1],\n      [10, 50, 100, 500, \"All\"],\n    ],\n    dom: 'rt<\"container\"<\"row\"<\"col-md-6\"li><\"col-md-6\"p>>>',\n    ajax: \"api/req/gets\",\n    deferRender: true,\n    columnDefs: columnDefs,\n    createdRow: function (row, data) {\n      if (data[\"type\"] === \"Heading\") {\n        $(row).addClass(\"bg-primary\")\n      }\n      if (data[\"type\"] === \"Information\") {\n        $(row).addClass(\"table-info\")\n      }\n      if (data[\"type\"] === \"Requirement\") {\n        $(row).addClass(\"table-warning\")\n      }\n      if (data[\"type\"] === \"not set\") {\n        $(row).addClass(\"table-light\")\n      }\n    },\n    infoCallback: function (settings, start, end, max, total) {\n      let api = this.api()\n      let pageInfo = api.page.info()\n\n      $(\"#clear-all-filters-text\").html(\"Showing \" + total + \"/\" + pageInfo.recordsTotal + \". Clear all.\")\n\n      let result = \"Showing \" + start + \" to \" + end + \" of \" + total + \" entries\"\n      result += \" (filtered from \" + pageInfo.recordsTotal + \" total entries).\"\n\n      return result\n    },\n    initComplete: function () {\n      $(\"#search_bar\").val(req_search_string)\n      $(\"#type-filter-input\").val(filter_type_string)\n      $(\"#tag-filter-input\").val(filter_tag_string)\n      $(\"#status-filter-input\").val(filter_status_string)\n\n      let requirements_table = this.api()\n      bind_requirement_id_to_modals(requirements_table)\n      init_datatable_manipulators(requirements_table)\n      for (const f of init_table_connection_functions) {\n        f(requirements_table)\n      }\n\n      utils.process_url_query(get_query)\n      update_search()\n      update_filter()\n\n      // Enable Hanfor specific requirements table filtering.\n      $.fn.dataTable.ext.search.push(function (settings, data) {\n        // data contains the row. data[0] is the content of the first column in the actual row.\n        // Return true to include the row into the data. false to exclude.\n        return evaluate_search(data)\n      })\n\n      this.api().draw()\n    },\n  })\n  new $.fn.dataTable.ColReorder(table, {})\n}\n\nfunction evaluate_search(data) {\n  return search_tree.evaluate(data, visible_columns) && filter_tree.evaluate(data, visible_columns)\n}\n\n/**\n * Bind the requirements table manipulators to the table.\n * Initialize manipulators behaviour.\n * @param requirements_table The requirements table\n */\nfunction init_datatable_manipulators(requirements_table) {\n  // Headers extension: Add index to address in search.\n  requirements_table.columns().every(function (index) {\n    if (index > 0)\n      requirements_table\n        .column(index)\n        .header()\n        .append(\" (\" + index + \")\")\n  })\n\n  // Save button\n  $(\"#save_requirement_modal\").click(function () {\n    store_requirement(requirements_table)\n  })\n\n  // Table Search related stuff.\n  // Bind big custom searchbar to search the table.\n  $(\"#search_bar\").keypress(function (e) {\n    if (e.which === 13) {\n      // Search on enter.\n      update_search()\n      requirements_table.draw()\n    }\n  })\n\n  // Table filters.\n  $(\"#type-filter-input\").autocomplete({\n    minLength: 0,\n    source: available_types,\n    delay: 100,\n  })\n\n  $(\"#status-filter-input\").autocomplete({\n    minLength: 0,\n    source: available_status,\n    delay: 100,\n  })\n\n  $(\"#tag-filter-input\").autocomplete({\n    minLength: 0,\n    source: available_tags,\n    delay: 100,\n  })\n\n  $(\"#tag-filter-input, #status-filter-input, #type-filter-input\")\n    .on(\"focus\", function () {\n      $(this).keydown()\n    })\n    .on(\"keypress\", function (e) {\n      if (e.which === 13) {\n        // Search on Enter.\n        update_filter()\n        requirements_table.draw()\n      }\n    })\n\n  $(\"#table-filter-toggle\").click(function () {\n    $(\"#tag-filter-input\").autocomplete({ source: available_tags })\n    $(\"#type-filter-input\").autocomplete({ source: available_types })\n  })\n\n  // Clear all applied searches.\n  $(\".clear-all-filters\").click(function () {\n    clear_all_search_filter_inputs()\n    requirements_table.draw()\n  })\n\n  // Listen for tool section triggers.\n  $(\"#gen-req-from-selection\").click(function () {\n    let req_ids = []\n    requirements_table.rows({ search: \"applied\" }).every(function () {\n      let d = this.data()\n      req_ids.push(d[\"id\"])\n    })\n    $(\"#selected_requirement_ids\").val(JSON.stringify(req_ids))\n    $(\"#generate_req_form\").submit()\n  })\n\n  $(\"#gen-csv-from-selection\").click(function () {\n    let req_ids = []\n    requirements_table.rows({ search: \"applied\" }).every(function () {\n      let d = this.data()\n      req_ids.push(d[\"id\"])\n    })\n    $(\"#selected_csv_requirement_ids\").val(JSON.stringify(req_ids))\n    $(\"#generate_csv_form\").submit()\n  })\n\n  $(\"#gen-xls-from-selection\").click(function () {\n    let req_ids = []\n    requirements_table.rows({ search: \"applied\" }).every(function () {\n      let d = this.data()\n      req_ids.push(d[\"id\"])\n    })\n    $(\"#selected_xls_requirement_ids\").val(JSON.stringify(req_ids))\n    $(\"#generate_xls_form\").submit()\n  })\n\n  // Column toggling\n  $(\".column-toggle-button\").on(\"click\", function (e) {\n    e.preventDefault()\n\n    // Get the column API object\n    let column = requirements_table.column($(this).attr(\"data-column\"))\n\n    // Toggle the visibility\n    column.visible(!column.visible())\n    update_visible_columns_information()\n  })\n\n  $(\".reset-column-toggle\").on(\"click\", function (e) {\n    e.preventDefault()\n    requirements_table.columns(\".default-col\").visible(true)\n    requirements_table.columns(\".extra-col\").visible(false)\n    update_visible_columns_information()\n  })\n  update_visible_columns_information()\n\n  // Select rows\n  $(\".select-all-button\").on(\"click\", function () {\n    // Toggle selection on\n    if ($(this).hasClass(\"btn-secondary\")) {\n      requirements_table.rows({ page: \"current\" }).select()\n    } else {\n      // Toggle selection off\n      requirements_table.rows({ page: \"current\" }).deselect()\n    }\n    // Toggle button state.\n    $(\".select-all-button\").toggleClass(\"btn-secondary btn-primary\")\n  })\n\n  // Toggle \"Select all rows to `off` on user specific selection.\"\n  requirements_table.on(\"user-select\", function () {\n    let select_buttons = $(\".select-all-button\")\n    select_buttons.removeClass(\"btn-primary\")\n    select_buttons.addClass(\"btn-secondary \")\n  })\n\n  // Bind autocomplete for \"edit-selected\" inputs\n  $(\"#multi-add-tag-input, #multi-remove-tag-input\")\n    .autocomplete({\n      minLength: 0,\n      source: available_tags,\n      delay: 100,\n    })\n    .on(\"focus\", function () {\n      $(this).keydown()\n    })\n    .val(\"\")\n\n  $(\"#multi-set-status-input\")\n    .autocomplete({\n      minLength: 0,\n      source: available_status,\n      delay: 100,\n    })\n    .on(\"focus\", function () {\n      $(this).keydown()\n    })\n    .val(\"\")\n\n  $(\".apply-multi-edit\").click(function () {\n    apply_multi_edit(requirements_table)\n  })\n\n  // $('.add_top_guess_button').confirmation({\n  //     rootSelector: '.add_top_guess_button'\n  // }).click(function () {\n  //     add_top_guess_to_selected_requirements(requirements_table);\n  // });\n\n  $(\".add_top_guess_button\").bootstrapConfirmButton({\n    onConfirm: function () {\n      add_top_guess_to_selected_requirements(requirements_table)\n    },\n  })\n}\n\n/**\n * Stores the active (in modal) requirement and updates the row in the requirements table.\n * @param {DataTable} requirements_table\n */\nfunction store_requirement(requirements_table) {\n  let requirement_modal_content = $(\".modal-content\")\n  requirement_modal_content.LoadingOverlay(\"show\")\n\n  const req_id = $(\"#requirement_id\").val()\n  const req_status = $(\"#requirement_status\").val()\n  const updated_formalization = $(\"#requirement_modal\").data(\"updated_formalization\")\n  const associated_row_id = parseInt($(\"#modal_associated_row_index\").val())\n\n  // Fetch the formalizations\n  let formalizations = {}\n  $(\".formalization_card\").each(function () {\n    // Scope and Pattern\n    let formalization = {}\n    formalization[\"id\"] = $(this).attr(\"title\")\n    $(this)\n      .find(\"select\")\n      .each(function () {\n        if ($(this).hasClass(\"scope_selector\")) {\n          formalization[\"scope\"] = $(this).val()\n        }\n        if ($(this).hasClass(\"pattern_selector\")) {\n          formalization[\"pattern\"] = $(this).val()\n        }\n      })\n\n    // Expressions\n    formalization[\"expression_mapping\"] = {}\n    $(this)\n      .find(\"textarea.reqirement-variable\")\n      .each(function () {\n        if ($(this).attr(\"title\") !== \"\") formalization[\"expression_mapping\"][$(this).attr(\"title\")] = $(this).val()\n      })\n\n    formalizations[formalization[\"id\"]] = formalization\n  })\n\n  let tag_comments = new Map()\n  $(\"#tags_comments_table tr:gt(0)\").each(function () {\n    let tag = $(this).find(\"td:eq(0)\").text()\n    let comment = $(this).find(\"textarea:eq(0)\").val()\n    tag_comments.set(tag, comment)\n  })\n\n  sendTelemetry(\"requirements\", req_id, \"save\")\n  // Store the requirement.\n  $.post(\n    \"api/req/update\",\n    {\n      id: req_id,\n      row_idx: associated_row_id,\n      update_formalization: updated_formalization,\n      tags: JSON.stringify(Object.fromEntries(tag_comments)),\n      status: req_status,\n      formalizations: JSON.stringify(formalizations),\n    }, // Update requirements table on success or show an error message.\n    function (data) {\n      requirement_modal_content.LoadingOverlay(\"hide\", true)\n      if (data[\"success\"] === false) {\n        alert(data[\"errormsg\"])\n      } else {\n        requirements_table.row(associated_row_id).data(data)\n\n        //$('#requirement_modal').data('unsaved_changes', false).modal('hide');\n        $(\"#requirement_modal\").data(\"unsaved_changes\", false)\n\n        const requirement_modal = document.querySelector(\"#requirement_modal\")\n        Modal.getOrCreateInstance(requirement_modal).hide()\n      }\n    },\n  ).done(function () {\n    update_logs()\n  })\n}\n\n/**\n * Load requirements datatable definitions. Trigger build of a fresh requirement datatable.\n */\nfunction load_datatable() {\n  // Initialize the Column defs.\n  // First set the static colum definitions.\n  let columnDefs = [\n    {\n      orderable: false,\n      className: \"select-checkbox\",\n      targets: [0],\n      data: null,\n      defaultContent: \"\",\n    },\n    {\n      targets: [1],\n      data: \"pos\",\n    },\n    {\n      targets: [2],\n      data: \"id\",\n      render: function (data) {\n        return '<a href=\"#\">' + utils.escapeHtml(data) + \"</a>\"\n      },\n    },\n    {\n      targets: [3],\n      data: \"desc\",\n      render: function (data) {\n        return '<div class=\"white-space-pre\">' + utils.escapeHtml(data) + \"</div>\"\n      },\n    },\n    {\n      targets: [4],\n      data: \"type\",\n      render: function (data) {\n        if (available_types.indexOf(data) <= -1) {\n          available_types.push(data)\n        }\n        return utils.escapeHtml(data)\n      },\n    },\n    {\n      targets: [5],\n      data: \"tags\",\n      render: function (data, type, row) {\n        let result = \"\"\n        $(data).each(function (id, tag) {\n          if (tag.length > 0) {\n            result +=\n              '<span class=\"badge\" style=\"background-color: ' +\n              get_tag_color(tag) +\n              '\">' +\n              utils.escapeHtml(tag) +\n              \"</span></br>\" +\n              \" \"\n          }\n        })\n        return result\n      },\n    },\n    {\n      targets: [6],\n      data: \"status\",\n      render: function (data) {\n        return '<span class=\"badge bg-info\">' + data + \"</span></br>\"\n      },\n    },\n    {\n      targets: [7],\n      data: \"formal\",\n      render: function (data, type, row) {\n        let result = \"\"\n        if (row.formal.length > 0) {\n          $(data).each(function (id, formalization) {\n            if (formalization.length > 0) {\n              result += '<div class=\"white-space-pre\">' + utils.escapeHtml(formalization) + \"</div>\"\n            }\n          })\n        }\n        return result\n      },\n    },\n  ]\n  // Load generic colums.\n  $.get(\"api/req/colum_defs\", \"\", function (data) {\n    const dataLength = data[\"col_defs\"].length\n    for (let i = 0; i < dataLength; i++) {\n      columnDefs.push({\n        targets: [parseInt(data[\"col_defs\"][i][\"target\"])],\n        data: data[\"col_defs\"][i][\"csv_name\"],\n        visible: false,\n        searchable: true,\n      })\n    }\n  }).done(function () {\n    init_datatable(columnDefs)\n  })\n}\n\n/**\n * Bind the Links to open a requirement modal.\n * Implement Behaviour:\n *  * Load and show requirement data\n * @param requirements_table\n */\nfunction bind_requirement_id_to_modals(requirements_table) {\n  // Add listener for clicks on the Rows.\n  $(\"#requirements_table\")\n    .find(\"tbody\")\n    .on(\"click\", \"a\", function (event) {\n      // prevent body to be scrolled to the top.\n      event.preventDefault()\n      let row_idx = requirements_table.row($(this).closest(\"tr\")).index()\n      load_requirement(row_idx)\n    })\n}\n\n/**\n * Get the color for a tag\n */\nfunction get_tag_color(tag_name) {\n  return tag_colors.hasOwnProperty(tag_name) ? tag_colors[tag_name] : \"var(--bs-info)\"\n}\n\n/**\n * SEARCH TAB\n * =====================================================================================================================\n */\n\n/**\n * Load the hanfor frontend meta settings.\n */\nfunction initialise_search_bar() {\n  let search_bar = $(\"#search_bar\")\n  new Awesomplete(search_bar[0], {\n    filter: function (text, input) {\n      let result = false\n      // If we have an uneven number of \":\"\n      // We check if we have a match in the input tail starting from the last \":\"\n      if ((input.split(\":\").length - 1) % 2 === 1) {\n        result = Awesomplete.FILTER_CONTAINS(text, input.match(/[^:]*$/)[0])\n      }\n      return result\n    },\n    item: function (text, input) {\n      // Match inside \":\" enclosed item.\n      return Awesomplete.ITEM(text, input.match(/(:)([\\S]*$)/)[2])\n    },\n    replace: function (text) {\n      // Cut of the tail starting from the last \":\" and replace by item text.\n      const before = this.input.value.match(/(.*)(:(?!.*:).*$)/)[1]\n      this.input.value = before + text\n    },\n    list: search_autocomplete,\n    minChars: 1,\n    autoFirst: true,\n  })\n}\n\n/**\n * Update the search expression tree.\n */\nfunction update_search() {\n  req_search_string = $(\"#search_bar\").val().trim()\n  sessionStorage.setItem(\"req_search_string\", req_search_string)\n  search_tree = SearchNode.fromQuery(req_search_string)\n}\n\n/**\n * Clear all user input in filters and search bar. Reload the table.\n */\nfunction clear_all_search_filter_inputs() {\n  $(\"#status-filter-input\").val(\"\").effect(\"highlight\", { color: \"green\" }, 500)\n  $(\"#tag-filter-input\").val(\"\").effect(\"highlight\", { color: \"green\" }, 500)\n  $(\"#type-filter-input\").val(\"\").effect(\"highlight\", { color: \"green\" }, 500)\n  $(\"#search_bar\").val(\"\").effect(\"highlight\", { color: \"green\" }, 500)\n  update_filter()\n  update_search()\n}\n\n/**\n * FILTER TAB\n * =====================================================================================================================\n */\n\n/**\n * Update the filter search tree used to filter the table by the values from the Filter tab.\n */\nfunction update_filter() {\n  filter_search_array = []\n\n  function pad_with_parantheses(array) {\n    return [\"(\"].concat(array, [\")\"])\n  }\n\n  function add_query(array, query, target) {\n    if (query.length > 0) {\n      if (array.length > 0) {\n        array = array.concat([\":AND:\"])\n      }\n      array = array.concat(pad_with_parantheses(SearchNode.awesomeQuerySplitt0r(query, target)))\n    }\n    return array\n  }\n\n  filter_status_string = $(\"#status-filter-input\").val()\n  filter_tag_string = $(\"#tag-filter-input\").val()\n  filter_type_string = $(\"#type-filter-input\").val()\n\n  sessionStorage.setItem(\"filter_status_string\", filter_status_string)\n  sessionStorage.setItem(\"filter_tag_string\", filter_tag_string)\n  sessionStorage.setItem(\"filter_type_string\", filter_type_string)\n\n  filter_search_array = add_query(filter_search_array, filter_type_string, 4)\n  filter_search_array = add_query(filter_search_array, filter_tag_string, 5)\n  filter_search_array = add_query(filter_search_array, filter_status_string, 6)\n\n  filter_tree = SearchNode.searchArrayToTree(filter_search_array)\n}\n\n/**\n * COLUMNS TAB\n * =====================================================================================================================\n */\n\n/**\n * Update the color of the column toggle buttons.\n * Column visible -> Button blue (btn-info).\n * Column not visible -> Button grey (btn-secondary).\n * Update visible_columns\n */\nfunction update_visible_columns_information() {\n  let requirements_table = $(\"#requirements_table\").DataTable()\n  let new_visible_columns = []\n  $.each(requirements_table.columns().visible(), function (key, value) {\n    if (value === false) {\n      $(\"#col_toggle_button_\" + key)\n        .removeClass(\"btn-info\")\n        .addClass(\"btn-secondary\")\n      new_visible_columns.push(false)\n    } else {\n      $(\"#col_toggle_button_\" + key)\n        .removeClass(\"btn-secondary\")\n        .addClass(\"btn-info\")\n      new_visible_columns.push(true)\n    }\n  })\n  visible_columns = new_visible_columns\n}\n\n/**\n * EDIT SELECTED TAB\n * =====================================================================================================================\n */\n\n/**\n * @param requirements_table\n * @returns {Array} User selected requirement ids.\n */\nfunction get_selected_requirement_ids(requirements_table) {\n  let selected_ids = []\n  requirements_table.rows({ selected: true }).every(function () {\n    let d = this.data()\n    selected_ids.push(d[\"id\"])\n  })\n\n  return selected_ids\n}\n\nfunction apply_multi_edit(requirements_table) {\n  let page = $(\"body\")\n  page.LoadingOverlay(\"show\")\n  let add_tag = $(\"#multi-add-tag-input\").val().trim()\n  let remove_tag = $(\"#multi-remove-tag-input\").val().trim()\n  let set_status = $(\"#multi-set-status-input\").val().trim()\n  let selected_ids = get_selected_requirement_ids(requirements_table)\n\n  $.post(\n    \"api/req/multi_update\",\n    {\n      add_tag: add_tag,\n      remove_tag: remove_tag,\n      set_status: set_status,\n      selected_ids: JSON.stringify(selected_ids),\n    }, // Update requirements table on success or show an error message.\n    function (data) {\n      page.LoadingOverlay(\"hide\", true)\n      if (data[\"success\"] === false) {\n        alert(data[\"errormsg\"])\n      } else {\n        location.reload()\n      }\n    },\n  )\n}\n\nfunction add_top_guess_to_selected_requirements(requirements_table) {\n  let page = $(\"body\")\n  page.LoadingOverlay(\"show\")\n  let selected_ids = get_selected_requirement_ids(requirements_table)\n  let insert_mode = $(\"#top_guess_append_mode\").val()\n\n  $.post(\n    \"api/req/multi_add_top_guess\",\n    {\n      selected_ids: JSON.stringify(selected_ids),\n      insert_mode: insert_mode,\n    }, // Update requirements table on success or show an error message.\n    function (data) {\n      page.LoadingOverlay(\"hide\", true)\n      if (data[\"success\"] === false) {\n        alert(data[\"errormsg\"])\n      } else {\n        location.reload()\n      }\n    },\n  )\n}\n\n/**\n * LOG TAB\n * =====================================================================================================================\n */\n\n/**\n * Refresh the hanfor frontend logs.\n */\nfunction update_logs() {\n  $.get(\"api/logs/get\", \"\", function (data) {\n    $(\"#log_textarea\").html(data)\n  }).done(function () {\n    // Bind direct requirement links to load the modal.\n    $(\".req_direct_link\").click(function () {\n      load_requirement(get_rowidx_by_reqid($(this).data(\"rid\")))\n    })\n    $(\"#log_textarea\").scrollTop(100000)\n  })\n}\n\n/**\n * Find the datatable row index for a requirement by its requirement id.\n * @param {number} rid the requirement id.\n * @returns {number} row_index the datatables row index.\n */\nfunction get_rowidx_by_reqid(rid) {\n  let requirement_table = $(\"#requirements_table\").DataTable()\n  let result = -1\n  requirement_table.data().filter(function (value, index) {\n    if (String(value.id) === String(rid)) {\n      result = index\n      return true\n    }\n    return false\n  })\n  return result\n}\n\n/**\n * REQUIREMENT MODAL\n * =====================================================================================================================\n */\n\n/**\n * Initialize the requirement modal behaviour.\n */\nfunction init_modal() {\n  let requirement_modal = $(\"#requirement_modal\")\n  // Initialize tag autocomplete filed in the requirements modal.\n  $(\"#requirement_tag_field\")\n    .tokenfield({\n      autocomplete: {\n        source: available_tags,\n        delay: 100,\n      },\n      showAutocompleteOnFocus: true,\n    })\n    .change(function () {\n      requirement_modal.data(\"unsaved_changes\", true)\n    })\n\n  $(\"#requirement_status\").change(function () {\n    $(\"#requirement_modal\").data(\"unsaved_changes\", true)\n  })\n\n  //requirement_modal.on('hide.bs.modal', function (event) {\n  requirement_modal[0].addEventListener(\"hide.bs.modal\", function (event) {\n    modal_closing_routine(event)\n  })\n\n  // Handle ESC key\n  $(document).keyup(function (e) {\n    // If modal is open and ESC pressed (ESC maps to keyCode \"27\")\n    if ($(\".modal:visible\").length && e.keyCode === 27) {\n      let focused_input = $(\"input[type=text], textarea, select\").filter(\":focus\")\n      // If no input elements in focus => Close modal.\n      if (focused_input.length === 0) {\n        // First hide the autoguess modal\n        if ($(\"#requirement_guess_modal:visible\").length) {\n          //$('#requirement_guess_modal').modal('hide');\n          Modal.getOrCreateInstance(\"#requirement_guess_modal\").hide()\n        } else {\n          //$('#requirement_modal').modal('hide');\n          Modal.getOrCreateInstance(\"#requirement_modal\").hide()\n        }\n      } else {\n        // Defocus input elements.\n        focused_input.each(function () {\n          $(this).blur()\n        })\n      }\n    }\n  })\n\n  // Clear the Modal after closing modal.\n  // In case of stacked modals and on modal closing:\n  // Prevent removal of modal-open class from body if a modal remains. This will keep the scrollbar intact.\n  requirement_modal.on(\"hidden.bs.modal\", function () {\n    $(\"#requirement_tag_field\").val(\"\")\n    $(\"#requirement_tag_field-tokenfield\").val(\"\")\n  })\n\n  // Listener for adding new formalizations.\n  $(\"#add_formalization\").click(function () {\n    add_formalization()\n  })\n\n  // Listener for adding new guessed formalizations.\n  $(\"#add_gussed_formalization\").click(function () {\n    fetch_available_guesses()\n  })\n\n  window.addEventListener(\"storage\", (event) => {\n    if (event.key === \"cookieUpdate\") {\n      setCopyBtnEnable()\n    }\n  })\n\n  $(\"#add_copied_formalization\").click(function () {\n    const cookie = getCookie(\"copied_formalization\")\n    let formalization = {}\n    if (cookie) {\n      formalization = JSON.parse(cookie)\n    }\n    console.log(formalization)\n\n    add_formalization(formalization)\n  })\n\n  $(\".modal\").on(\"hidden.bs.modal\", function () {\n    if ($(\".modal:visible\").length) {\n      $(\"body\").addClass(\"modal-open\")\n    } else {\n      $(\"textarea\").each(function () {\n        autosize.destroy($(this))\n      })\n    }\n  })\n\n  $(\"#formalization_accordion\").on(\"shown.bs.collapse\", \".card\", function () {\n    $(this)\n      .find(\"textarea\")\n      .each(function () {\n        autosize($(this))\n        autosize.update($(this))\n      })\n  })\n\n  // Initialize variables.\n  update_vars()\n}\n\nfunction getCookie(name) {\n  const value = `; ${document.cookie}`\n  const parts = value.split(`; ${name}=`)\n  if (parts.length === 2) return parts.pop().split(\";\").shift()\n}\n\nfunction setCopyBtnEnable() {\n  const cookie = getCookie(\"copied_formalization\")\n  const button = document.getElementById(\"add_copied_formalization\")\n  button.disabled = !cookie\n}\n\n/**\n * Handle requirement modal hiding event.\n * Prevent hiding on unsaved changes by asking user feedback (discard, save, back to edit).\n * @param event | the modal hiding event.\n */\nfunction modal_closing_routine(event) {\n  const unsaved_changes = $(\"#requirement_modal\").data(\"unsaved_changes\")\n  if (unsaved_changes === true) {\n    const force_close = confirm(\"You have unsaved changes, do you really want to close?\")\n    if (force_close !== true) {\n      event.preventDefault()\n    } else {\n      sendTelemetry(\"requirements\", $(\"#requirement_id\").val(), \"close_without_save\")\n    }\n  } else {\n    sendTelemetry(\"requirements\", $(\"#requirement_id\").val(), \"close\")\n  }\n}\n\nfunction load_requirement(row_idx) {\n  if (row_idx === -1) {\n    alert(\"Requirement not found.\")\n    return\n  }\n\n  load_tags()\n\n  // Get row data\n  let data = $(\"#requirements_table\").DataTable().row(row_idx).data()\n\n  // Prepare requirement Modal\n  let requirement_modal_content = $(\".modal-content\")\n\n  //$('#requirement_modal').modal('show');\n  Modal.getOrCreateInstance(\"#requirement_modal\").show()\n\n  requirement_modal_content.LoadingOverlay(\"show\")\n  $(\"#formalization_accordion\").html(\"\")\n\n  // Set available tags.\n  $(\"#requirement_tag_field\").data(\"bs.tokenfield\").$input.autocomplete({ source: available_tags })\n\n  // Get the requirement data and set the modal.\n  $.get(\"api/req/get\", { id: data[\"id\"], row_idx: row_idx }, function (data) {\n    if (data.success === false) {\n      alert(\"Could Not load the Requirement: \" + data.errormsg)\n      return\n    }\n    // Meta information\n    $(\"#requirement_id\").val(data.id)\n    $(\"#modal_associated_row_index\").val(row_idx)\n    available_vars = data.available_vars\n    available_vars = available_vars.concat(data.additional_static_available_vars)\n    type_inference_errors = data.type_inference_errors\n    update_fuse()\n\n    // Visible information\n    $(\"#requirement_modal_title\").html(data.id + \": \" + data.type)\n    $(\"#description_textarea\").text(data.desc).change()\n    $(\"#add_guess_description\").text(data.desc).change()\n\n    // Parse the formalizations\n    $(\"#formalization_accordion\").html(data.formalizations_html)\n\n    $(\"#requirement_scope\").val(data.scope)\n    $(\"#requirement_pattern\").val(data.pattern)\n\n    // remove all lines from the tag comment table\n    $(\"#tags_comments_table\").find(\"tr:gt(0)\").remove()\n    // set Tag field and comments in Table (table rows are created via event)\n    $(\"#requirement_tag_field\").tokenfield(\"setTokens\", data.tags)\n    $(\"#tags_comments_table tr:gt(0)\").each(function () {\n      let tag = $(this).find(\"td:eq(0)\").text()\n      $(this).find(\"textarea:eq(0)\").val(data.tags_comments[tag])\n    })\n\n    $(\"#requirement_status\").val(data.status)\n    // Set csv_data\n    let csv_row_content = $(\"#csv_content_accordion\")\n    csv_row_content.html(\"\")\n\n    let csv_data = data.csv_data\n    for (const key in csv_data) {\n      if (csv_data.hasOwnProperty(key)) {\n        const value = csv_data[key]\n        csv_row_content.append(\"<p><strong>\" + key + \":</strong>\" + value + \"</p>\")\n      }\n    }\n\n    // Set revision diff data.\n    let revision_diff_link = $(\"#show_revision_diff\")\n    if ($.isEmptyObject(data.revision_diff)) {\n      revision_diff_link.hide()\n    } else {\n      revision_diff_link.show()\n    }\n\n    let revision_diff_content = $(\"#revision_diff_accordion\")\n    revision_diff_content.html(\"\")\n\n    let revision_diff = data.revision_diff\n    for (const key in revision_diff) {\n      if (revision_diff.hasOwnProperty(key)) {\n        const value = revision_diff[key]\n        revision_diff_content.append(\"<p><strong>\" + key + \":</strong><pre>\" + value + \"</pre></p>\")\n      }\n    }\n\n    // Set used variables data.\n    let used_variables_accordion = $(\"#used_variables_accordion\")\n    used_variables_accordion.html(\"\")\n\n    data.vars.forEach(function (var_name) {\n      let query = \"?command=search&col=1&q=%5C%22\" + var_name + \"%5C%22\"\n      used_variables_accordion.append(\n        '<span class=\"badge bg-info\">' +\n          '<a href=\"./variables' +\n          query +\n          '\" target=\"_blank\">' +\n          var_name +\n          \"</a>\" +\n          \"</span>&numsp;\",\n      )\n    })\n  }).done(function () {\n    update_vars()\n    bind_var_autocomplete()\n    update_formalization()\n    $(\"#requirement_modal\").data({\n      unsaved_changes: false,\n      updated_formalization: false,\n    })\n    requirement_modal_content.LoadingOverlay(\"hide\", true)\n    sendTelemetry(\"requirements\", data.id, \"open\")\n    setCopyBtnEnable()\n  })\n}\n\n/**\n * Reload fuse the fuzzy search provider used for autocomplete.\n * fuse will be reloaded with available_vars.\n */\nfunction update_fuse() {\n  let options = {\n    shouldSort: true,\n    threshold: 0.6,\n    location: 0,\n    distance: 100,\n    maxPatternLength: 12,\n    minMatchCharLength: 1,\n    keys: [],\n  }\n\n  fuse = new Fuse(available_vars, options)\n}\n\n/**\n * Search term in the fuse fuzzy search provider.\n * Fuse is initialized with the available_vars.\n * @param term\n */\nfunction fuzzy_search(term) {\n  return fuse.search(term)\n}\n\n/**\n * Bind autocomplete trigger to all formalization input textareas.\n *\n */\nfunction bind_var_autocomplete() {\n  $(\".reqirement-variable\").each(function () {\n    add_var_autocomplete(this)\n  })\n}\n\n/**\n * Adds the variable autocompletion to a textarea given by dom_obj.\n * @param dom_obj\n */\nfunction add_var_autocomplete(dom_obj) {\n  const textcomplete = new Textcomplete(\n    new TextareaEditor(dom_obj),\n    [\n      {\n        match: /(|\\s|[!=&\\|>]+)(\\w+)$/,\n        index: 2,\n        search: function (term, callback, match) {\n          let include_elems = fuzzy_search(term)\n          let result = []\n          // TODO: Maybe just use include_elems[i].item\n          for (let i = 0; i < Math.min(10, include_elems.length); i++) {\n            result.push(available_vars[include_elems[i].refIndex])\n          }\n          callback(result)\n        },\n        replace: function (result) {\n          return \"$1\" + result + \" \"\n        },\n      },\n    ],\n    {\n      dropdown: {\n        className: \"dropdown-menu textcomplete-dropdown\",\n        maxCount: 10,\n        style: {\n          display: \"none\",\n          position: \"absolute\",\n          zIndex: \"9999\",\n        }, // parent: dom_obj.parentNode, // Does not work in modal.\n        item: {\n          className: \"dropdown-item\",\n          activeClassName: \"dropdown-item active\",\n        },\n      },\n    },\n  )\n\n  $(document).on(\"click\", function (event) {\n    if (textcomplete !== event.target) {\n      textcomplete.hide()\n    }\n  })\n}\n\nfunction add_formalization(formalizationData = {}) {\n  // Request a new Formalization. And add its edit elements to the modal.\n  let requirement_modal_content = $(\".modal-content\")\n  requirement_modal_content.LoadingOverlay(\"show\")\n\n  const req_id = $(\"#requirement_id\").val()\n  $.post(\n    \"api/req/new_formalization\",\n    {\n      id: req_id,\n      formalization: JSON.stringify(formalizationData),\n    },\n    function (data) {\n      requirement_modal_content.LoadingOverlay(\"hide\", true)\n      if (data[\"success\"] === false) {\n        alert(data[\"errormsg\"])\n      } else {\n        let formalization = $(data[\"html\"])\n        formalization.find(\".reqirement-variable\").each(function () {\n          add_var_autocomplete(this)\n        })\n        formalization.appendTo(\"#formalization_accordion\")\n      }\n    },\n  ).done(function () {\n    update_vars()\n    update_formalization()\n    update_logs()\n  })\n}\n\nfunction delete_formalization(formal_id, card) {\n  let requirement_modal_content = $(\".modal-content\")\n  requirement_modal_content.LoadingOverlay(\"show\")\n  const req_id = $(\"#requirement_id\").val()\n  $.post(\n    \"api/req/del_formalization\",\n    {\n      requirement_id: req_id,\n      formalization_id: formal_id,\n    },\n    function (data) {\n      requirement_modal_content.LoadingOverlay(\"hide\", true)\n      if (data[\"success\"] === false) {\n        alert(data[\"errormsg\"])\n      } else {\n        card.remove()\n      }\n    },\n  ).done(function () {\n    update_vars()\n    update_formalization()\n    update_logs()\n  })\n}\n\nfunction copy_formalization(formal_id) {\n  let formalization = {}\n  $(\".formalization_card\").each(function () {\n    if ($(this).attr(\"title\") === formal_id) {\n      formalization[\"id\"] = $(this).attr(\"title\")\n      $(this)\n        .find(\"select\")\n        .each(function () {\n          if ($(this).hasClass(\"scope_selector\")) {\n            formalization[\"scope\"] = $(this).val()\n          }\n          if ($(this).hasClass(\"pattern_selector\")) {\n            formalization[\"pattern\"] = $(this).val()\n          }\n        })\n\n      // Expressions\n      formalization[\"expression_mapping\"] = {}\n      $(this)\n        .find(\"textarea.reqirement-variable\")\n        .each(function () {\n          if ($(this).attr(\"title\") !== \"\") formalization[\"expression_mapping\"][$(this).attr(\"title\")] = $(this).val()\n        })\n    }\n  })\n\n  const d = new Date()\n  d.setTime(d.getTime() + 8 * 3600 * 1000)\n  let expires = \"expires=\" + d.toUTCString()\n  document.cookie = \"copied_formalization=\" + JSON.stringify(formalization) + \";\" + expires + \";path=/\"\n  localStorage.setItem(\"cookieUpdate\", Date.now())\n  setCopyBtnEnable()\n  // TODO give some feedback\n}\n\n/**\n * Updates the formalization textarea based on the selected scope and expressions in P, Q, R, S, T, ... .\n */\nfunction update_formalization() {\n  $(\".formalization_card\").each(function () {\n    // Fetch attributes\n    const formalization_id = $(this).attr(\"title\")\n\n    let formalization = \"\"\n    let formalization_textarea = $(\"#current_formalization_textarea\" + formalization_id)\n    const selected_scope = $(\"#requirement_scope\" + formalization_id)\n      .find(\"option:selected\")\n      .text()\n      .replace(/\\s\\s+/g, \" \")\n    const selected_pattern = $(\"#requirement_pattern\" + formalization_id)\n      .find(\"option:selected\")\n      .text()\n      .replace(/\\s\\s+/g, \" \")\n\n    if (selected_scope !== \"None\" && selected_pattern !== \"None\") {\n      formalization = selected_scope + \", \" + selected_pattern + \".\"\n    }\n\n    // Update formalization with variables.\n    let var_p = $(\"#formalization_var_p\" + formalization_id).val()\n    let var_q = $(\"#formalization_var_q\" + formalization_id).val()\n    let var_r = $(\"#formalization_var_r\" + formalization_id).val()\n    let var_s = $(\"#formalization_var_s\" + formalization_id).val()\n    let var_t = $(\"#formalization_var_t\" + formalization_id).val()\n    let var_u = $(\"#formalization_var_u\" + formalization_id).val()\n    let var_v = $(\"#formalization_var_v\" + formalization_id).val()\n\n    if (var_p.length > 0) {\n      formalization = formalization.replace(/{P}/g, parse_vars_to_link(var_p))\n    }\n    if (var_q.length > 0) {\n      formalization = formalization.replace(/{Q}/g, parse_vars_to_link(var_q))\n    }\n    if (var_r.length > 0) {\n      formalization = formalization.replace(/{R}/g, parse_vars_to_link(var_r))\n    }\n    if (var_s.length > 0) {\n      formalization = formalization.replace(/{S}/g, parse_vars_to_link(var_s))\n    }\n    if (var_t.length > 0) {\n      formalization = formalization.replace(/{T}/g, parse_vars_to_link(var_t))\n    }\n    if (var_u.length > 0) {\n      formalization = formalization.replace(/{U}/g, parse_vars_to_link(var_u))\n    }\n    if (var_v.length > 0) {\n      formalization = formalization.replace(/{V}/g, parse_vars_to_link(var_v))\n    }\n\n    formalization_textarea.html(formalization)\n    autosize.update(formalization_textarea)\n  })\n  $(\"#requirement_modal\").data({\n    unsaved_changes: true,\n    updated_formalization: true,\n  })\n}\n\n/**\n * Replace variables in a formalization string by links to that variable.\n * Only if variable is available in the global \"available_vars\" array.\n * Example: foo || bar -> <a href ...>foo</a> || <a href ...>bar</a>\n * @param formal_string\n * @returns {string}\n */\nfunction parse_vars_to_link(formal_string) {\n  let result = \"\"\n\n  // Split the formalization string on possible variable delimiters given by the boogie grammar.\n  // We enclose the regular expression by /()/g to yield the delimiters itself: We want to keep them in the result.\n  formal_string.split(/([\\s&<>!()=:\\[\\]{}\\-|+*,])/g).forEach(function (chunk) {\n    if (available_vars.includes(chunk)) {\n      let query = \"?command=search&col=1&q=%5C%22\" + chunk + \"%5C%22\"\n      result +=\n        '<a href=\"./variables' +\n        query +\n        '\" target=\"_blank\"' +\n        '  title=\"Go to declaration of ' +\n        chunk +\n        '\" class=\"alert-link\">' +\n        chunk +\n        \"</a>\"\n    } else {\n      // We need to escape potential HTML special chars to prevent a broken display.\n      result += utils.escapeHtml(chunk)\n    }\n  })\n  return result\n}\n\n/**\n * Enable/disable the active variables (P, Q, R, ...) in the requirement modal based on scope and pattern.\n */\nfunction update_vars() {\n  $(\".requirement_var_group\").each(function () {\n    $(this).hide()\n    $(this).removeClass(\"type-error\")\n  })\n\n  $(\".formalization_card\").each(function () {\n    // Fetch attributes\n    const formalization_id = $(this).attr(\"title\")\n    const selected_scope = $(\"#requirement_scope\" + formalization_id).val()\n    const selected_pattern = $(\"#requirement_pattern\" + formalization_id).val()\n    let header = $(\"#formalization_heading\" + formalization_id)\n    let var_p = $(\"#requirement_var_group_p\" + formalization_id)\n    let var_q = $(\"#requirement_var_group_q\" + formalization_id)\n    let var_r = $(\"#requirement_var_group_r\" + formalization_id)\n    let var_s = $(\"#requirement_var_group_s\" + formalization_id)\n    let var_t = $(\"#requirement_var_group_t\" + formalization_id)\n    let var_u = $(\"#requirement_var_group_u\" + formalization_id)\n    let var_v = $(\"#requirement_var_group_v\" + formalization_id)\n\n    // Set the red boxes for type inference failed expressions.\n    if (formalization_id in type_inference_errors) {\n      for (let i = 0; i < type_inference_errors[formalization_id].length; i++) {\n        $(\"#formalization_var_\" + type_inference_errors[formalization_id][i] + formalization_id).addClass(\"type-error\")\n        header.addClass(\"type-error-head\")\n      }\n    } else {\n      header.removeClass(\"type-error-head\")\n    }\n\n    switch (selected_scope) {\n      case \"BEFORE\":\n      case \"AFTER\":\n        var_p.show()\n        break\n      case \"BETWEEN\":\n      case \"AFTER_UNTIL\":\n        var_p.show()\n        var_q.show()\n        break\n      default:\n        break\n    }\n\n    Object.keys(_PATTERNS[selected_pattern][\"env\"]).forEach(function (key) {\n      switch (key) {\n        case \"R\":\n          var_r.show()\n          break\n        case \"S\":\n          var_s.show()\n          break\n        case \"T\":\n          var_t.show()\n          break\n        case \"U\":\n          var_u.show()\n          break\n        case \"V\":\n          var_v.show()\n          break\n      }\n    })\n  })\n}\n\nfunction load_tags() {\n  $.ajax({\n    type: \"GET\",\n    url: \"api/v1/tags\",\n  })\n    .done(function (data) {\n      available_tags = []\n      for (let tag of data) {\n        available_tags.push(tag[\"name\"])\n        tag_colors[tag[\"name\"]] = tag[\"color\"]\n      }\n    })\n    .fail(function (jqXHR, textStatus, errorThrown) {\n      alert(errorThrown + \"\\n\\n\" + jqXHR[\"responseText\"])\n    })\n}\n\nfunction bind_tag_field_events() {\n  $(\"#requirement_tag_field\")\n    .on(\"tokenfield:createtoken\", function (e) {\n      let existingTokens = $(this).tokenfield(\"getTokens\")\n      for (const token of existingTokens) {\n        if (e.attrs.value === token.value) return false\n      }\n    })\n    .on(\"tokenfield:createdtoken\", function (e) {\n      add_tag_table_row(e.attrs.value)\n    })\n    .on(\"tokenfield:removedtoken\", function (e) {\n      $(\"#tags_comments_table tr:gt(0)\").each(function () {\n        let row = $(this)\n        let tag = $(this).find(\"td:eq(0)\").text()\n        if (tag === e.attrs.value) row.remove()\n      })\n    })\n}\n\nfunction add_tag_table_row(tag_name) {\n  //todo: we need to fill the fields with the actional comments (maybe name the fields and\n  // add comments later)\n  var table_row =\n    \"<tr>\" +\n    \"<td>\" +\n    tag_name +\n    \"</td>\" +\n    \"<td><textarea rows='1' class='form-control w-100' type='text'>\" +\n    \"</textarea>\" +\n    \"</td>\"\n  $(\"#tags_comments_table tbody\").append(table_row)\n}\n\n/**\n * REPORT TAB / REPORT MODAL\n * =====================================================================================================================\n */\nfunction open_report_modal(source = false) {\n  let query_textarea = $(\"#report_query_textarea\")\n  let results_textarea = $(\"#report_results_textarea\")\n  let report_title = $(\"#report_modal_title\")\n  let report_name = $(\"#report_name\")\n  let queries = \"\"\n  let results = \"\"\n  let name = \"\"\n  let report_id = -1\n  let report_modal = $(\"#report_modal\")\n  if (source !== false) {\n    report_id = source.attr(\"data-id\")\n    queries = available_reports[report_id].queries\n    results = available_reports[report_id].results\n    name = available_reports[report_id].name\n  }\n  query_textarea.val(queries).change()\n  results_textarea.val(results).change()\n  report_name.val(name).change()\n  report_title.html(name)\n  $(\"#save_report\").attr(\"data-id\", report_id)\n\n  Modal.getOrCreateInstance(document.querySelector(\"#report_modal\")).show()\n  //report_modal.modal('show');\n}\n\nfunction init_report_generation() {\n  $(\"#add-new-report\").click(function () {\n    open_report_modal()\n  })\n  $(\"#eval_report\").click(function () {\n    evaluate_report()\n  })\n  $(\"#save_report\").click(function () {\n    save_report()\n  })\n  let av_reports = $(\"#available_reports\")\n  av_reports.on(\"click\", \".open-report\", function () {\n    open_report_modal($(this))\n  })\n  av_reports.on(\"click\", \".delete-report\", function () {\n    delete_report($(this).attr(\"data-id\"))\n  })\n  $(\"#report_name\").change(function () {\n    $(\"#report_modal_title\").html($(this).val())\n  })\n  load_reports()\n}\n\nfunction delete_report(id) {\n  $.ajax({\n    type: \"DELETE\",\n    url: \"api/report/delete\",\n    data: { report_id: id },\n    success: function (data) {\n      if (data[\"success\"] === false) {\n        alert(data[\"errormsg\"])\n      }\n      load_reports()\n    },\n  })\n}\n\nfunction save_report() {\n  let body = $(\"body\")\n  body.LoadingOverlay(\"show\")\n\n  $.post(\n    \"api/report/set\",\n    {\n      report_querys: $(\"#report_query_textarea\").val(),\n      report_results: $(\"#report_results_textarea\").val(),\n      report_name: $(\"#report_name\").val(),\n      report_id: $(\"#save_report\").attr(\"data-id\"),\n    },\n    function (data) {\n      body.LoadingOverlay(\"hide\", true)\n      if (data[\"success\"] === false) {\n        alert(data[\"errormsg\"])\n      }\n      load_reports()\n    },\n  )\n}\n\nfunction load_reports() {\n  $.get(\"api/report/get\", {}, function (data) {\n    if (data[\"success\"] === false) {\n      alert(data[\"errormsg\"])\n    } else {\n      let result = \"\"\n      available_reports = data.data\n      $.each(data.data, function (id, report) {\n        result += `<div class=\"card border-primary\">\n                              <div class=\"card-body\">\n                                <h5 class=\"card-title\">${report.name}</h5>\n                                <h6 class=\"card-subtitle mb-2 text-muted\">Query</h6>\n                                <p class=\"card-text report-results\">${report.queries}</p>\n                                <h6 class=\"card-subtitle mb-2 text-muted\">Matches for queries</h6>\n                                <p class=\"card-text report-results\">${report.results}</p>\n                                <a href=\"#\" class=\"card-link open-report\" data-id=\"${id}\">\n                                    Edit (reevaluate) Report.\n                                </a>\n                                <a href=\"#\" class=\"card-link delete-report\" data-id=\"${id}\">Delete Report.</a>\n                              </div>\n                            </div>`\n      })\n      $(\"#available_reports\").html(result)\n    }\n  })\n}\n\n/**\n * Evaluate the report queries given by the report_query_textarea.\n * Paste the result into the report_results_textarea.\n * @TODO: the .draw() method is potentially overkill, since it will render the whole datatable.\n * So look into callstack and only apply necessary steps to evaluate the new search tree.\n * (.search() would not work since we use our own plugin to support the search expression parsing.)\n */\nfunction evaluate_report() {\n  let body = $(\"body\")\n  body.LoadingOverlay(\"show\")\n  const report_querys = $(\"#report_query_textarea\").val().split(\"\\n\")\n  let reqTable = $(\"#requirements_table\").DataTable()\n  let results = \"\"\n  const regex = /^(:NAME:)(`(\\w+)`)(.*)/\n  try {\n    $.each(report_querys, function (id, report_query) {\n      // Test if there is a named query.\n      let match = regex.exec(report_query)\n      if (match != null) {\n        report_query = match[4]\n        id = match[3]\n      }\n      search_tree = SearchNode.fromQuery(report_query)\n      reqTable.draw()\n      let result = reqTable.page.info()\n      results += `\"${id}\":\\t${result.recordsDisplay}\\n`\n    })\n    $(\"#report_results_textarea\").val(results).change()\n    update_search()\n    reqTable.draw()\n  } catch (err) {\n    alert(err)\n  }\n  body.LoadingOverlay(\"hide\", true)\n}\n\n/**\n * GUESS MODAL\n * =====================================================================================================================\n */\n\n/**\n * Load available guesses into the modal.\n */\nfunction fetch_available_guesses() {\n  let modal = $(\"#requirement_guess_modal\")\n  let available_guesses_cards = $(\"#available_guesses_cards\")\n  let modal_content = $(\".modal-content\")\n  let requirement_id = $(\"#requirement_id\").val()\n\n  //modal.modal({\n  //    keyboard: false\n  //});\n  new Modal(modal, { keyboard: false })\n\n  //modal.modal('show');\n  Modal.getOrCreateInstance(modal).show()\n\n  modal_content.LoadingOverlay(\"show\")\n  available_guesses_cards.html(\"\")\n\n  function add_available_guess(guess) {\n    let template =\n      '<div class=\"card\">' +\n      '                    <div class=\"pl-1 pr-1\">' +\n      \"                        <p>\" +\n      guess[\"string\"] +\n      \"                        </p>\" +\n      \"                    </div>\" +\n      '                    <button type=\"button\" class=\"btn btn-success btn-sm add_guess\"' +\n      '                            title=\"Add formalization\"' +\n      '                            data-scope=\"' +\n      guess[\"scope\"] +\n      '\"' +\n      '                            data-pattern=\"' +\n      guess[\"pattern\"] +\n      '\"' +\n      \"                            data-mapping='\" +\n      JSON.stringify(guess[\"mapping\"]) +\n      \"'>\" +\n      \"                        <strong>+ Add this formalization +</strong>\" +\n      \"                    </button>\" +\n      \"                </div>\"\n    available_guesses_cards.append(template)\n  }\n\n  $.post(\n    \"api/req/get_available_guesses\",\n    {\n      requirement_id: requirement_id,\n    },\n    function (data) {\n      if (data[\"success\"] === false) {\n        alert(data[\"errormsg\"])\n      } else {\n        for (let i = 0; i < data[\"available_guesses\"].length; i++) {\n          add_available_guess(data[\"available_guesses\"][i])\n        }\n      }\n    },\n  ).done(function () {\n    $(\".add_guess\").click(function () {\n      add_formalization_from_guess($(this).data(\"scope\"), $(this).data(\"pattern\"), $(this).data(\"mapping\"))\n    })\n    modal_content.LoadingOverlay(\"hide\", true)\n  })\n}\n\nfunction add_formalization_from_guess(scope, pattern, mapping) {\n  // Request a new Formalization. And add its edit elements to the modal.\n  let requirement_modal_content = $(\".modal-content\")\n  requirement_modal_content.LoadingOverlay(\"show\")\n\n  let requirement_id = $(\"#requirement_id\").val()\n  $.post(\n    \"api/req/add_formalization_from_guess\",\n    {\n      requirement_id: requirement_id,\n      scope: scope,\n      pattern: pattern,\n      mapping: JSON.stringify(mapping),\n    },\n    function (data) {\n      requirement_modal_content.LoadingOverlay(\"hide\", true)\n      if (data[\"success\"] === false) {\n        alert(data[\"errormsg\"])\n      } else {\n        $(\"#formalization_accordion\").append(data[\"html\"])\n      }\n    },\n  ).done(function () {\n    update_vars()\n    update_formalization()\n    bind_var_autocomplete()\n    update_logs()\n  })\n}\n\n\n//# sourceURL=webpack://hanfor/./js/requirements.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/core/dist/Completer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@textcomplete/core/dist/Completer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Completer = void 0;\nconst eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nconst Strategy_1 = __webpack_require__(/*! ./Strategy */ \"./node_modules/@textcomplete/core/dist/Strategy.js\");\nclass Completer extends eventemitter3_1.EventEmitter {\n    constructor(strategyPropsList) {\n        super();\n        this.handleQueryResult = (searchResults) => {\n            this.emit(\"hit\", { searchResults });\n        };\n        this.strategies = strategyPropsList.map((p) => new Strategy_1.Strategy(p));\n    }\n    destroy() {\n        this.strategies.forEach((s) => s.destroy());\n        return this;\n    }\n    run(beforeCursor) {\n        for (const strategy of this.strategies) {\n            const executed = strategy.execute(beforeCursor, this.handleQueryResult);\n            if (executed)\n                return;\n        }\n        this.handleQueryResult([]);\n    }\n}\nexports.Completer = Completer;\n//# sourceMappingURL=Completer.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/core/dist/Completer.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/core/dist/Dropdown.js":
/*!**********************************************************!*\
  !*** ./node_modules/@textcomplete/core/dist/Dropdown.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Dropdown = exports.DEFAULT_DROPDOWN_ITEM_ACTIVE_CLASS_NAME = exports.DEFAULT_DROPDOWN_ITEM_CLASS_NAME = exports.DEFAULT_DROPDOWN_CLASS_NAME = exports.DEFAULT_DROPDOWN_PLACEMENT = exports.DEFAULT_DROPDOWN_MAX_COUNT = void 0;\nconst eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@textcomplete/core/dist/utils.js\");\n// Default constants for Dropdown\nexports.DEFAULT_DROPDOWN_MAX_COUNT = 10;\nexports.DEFAULT_DROPDOWN_PLACEMENT = \"auto\";\nexports.DEFAULT_DROPDOWN_CLASS_NAME = \"dropdown-menu textcomplete-dropdown\";\n// Default constants for DropdownItem\nexports.DEFAULT_DROPDOWN_ITEM_CLASS_NAME = \"textcomplete-item\";\nexports.DEFAULT_DROPDOWN_ITEM_ACTIVE_CLASS_NAME = `${exports.DEFAULT_DROPDOWN_ITEM_CLASS_NAME} active`;\nclass Dropdown extends eventemitter3_1.EventEmitter {\n    static create(option) {\n        const ul = document.createElement(\"ul\");\n        ul.className = option.className || exports.DEFAULT_DROPDOWN_CLASS_NAME;\n        Object.assign(ul.style, {\n            display: \"none\",\n            position: \"absolute\",\n            zIndex: \"1000\",\n        }, option.style);\n        const parent = option.parent || document.body;\n        parent === null || parent === void 0 ? void 0 : parent.appendChild(ul);\n        return new Dropdown(ul, option);\n    }\n    constructor(el, option) {\n        super();\n        this.el = el;\n        this.option = option;\n        this.shown = false;\n        this.items = [];\n        this.activeIndex = null;\n    }\n    /**\n     * Render the given search results. Previous results are cleared.\n     *\n     * @emits render\n     * @emits rendered\n     */\n    render(searchResults, cursorOffset) {\n        const event = (0, utils_1.createCustomEvent)(\"render\", { cancelable: true });\n        this.emit(\"render\", event);\n        if (event.defaultPrevented)\n            return this;\n        this.clear();\n        if (searchResults.length === 0)\n            return this.hide();\n        this.items = searchResults\n            .slice(0, this.option.maxCount || exports.DEFAULT_DROPDOWN_MAX_COUNT)\n            .map((r, index) => { var _a; return new DropdownItem(this, index, r, ((_a = this.option) === null || _a === void 0 ? void 0 : _a.item) || {}); });\n        this.setStrategyId(searchResults[0])\n            .renderEdge(searchResults, \"header\")\n            .renderItems()\n            .renderEdge(searchResults, \"footer\")\n            .show()\n            .setOffset(cursorOffset)\n            .activate(0);\n        this.emit(\"rendered\", (0, utils_1.createCustomEvent)(\"rendered\"));\n        return this;\n    }\n    destroy() {\n        var _a;\n        this.clear();\n        (_a = this.el.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.el);\n        return this;\n    }\n    /**\n     * Select the given item\n     *\n     * @emits select\n     * @emits selected\n     */\n    select(item) {\n        const detail = { searchResult: item.searchResult };\n        const event = (0, utils_1.createCustomEvent)(\"select\", { cancelable: true, detail });\n        this.emit(\"select\", event);\n        if (event.defaultPrevented)\n            return this;\n        this.hide();\n        this.emit(\"selected\", (0, utils_1.createCustomEvent)(\"selected\", { detail }));\n        return this;\n    }\n    /**\n     * Show the dropdown element\n     *\n     * @emits show\n     * @emits shown\n     */\n    show() {\n        if (!this.shown) {\n            const event = (0, utils_1.createCustomEvent)(\"show\", { cancelable: true });\n            this.emit(\"show\", event);\n            if (event.defaultPrevented)\n                return this;\n            this.el.style.display = \"block\";\n            this.shown = true;\n            this.emit(\"shown\", (0, utils_1.createCustomEvent)(\"shown\"));\n        }\n        return this;\n    }\n    /**\n     * Hide the dropdown element\n     *\n     * @emits hide\n     * @emits hidden\n     */\n    hide() {\n        if (this.shown) {\n            const event = (0, utils_1.createCustomEvent)(\"hide\", { cancelable: true });\n            this.emit(\"hide\", event);\n            if (event.defaultPrevented)\n                return this;\n            this.el.style.display = \"none\";\n            this.shown = false;\n            this.clear();\n            this.emit(\"hidden\", (0, utils_1.createCustomEvent)(\"hidden\"));\n        }\n        return this;\n    }\n    /** Clear search results */\n    clear() {\n        this.items.forEach((i) => i.destroy());\n        this.items = [];\n        this.el.innerHTML = \"\";\n        this.activeIndex = null;\n        return this;\n    }\n    up(e) {\n        return this.shown ? this.moveActiveItem(\"prev\", e) : this;\n    }\n    down(e) {\n        return this.shown ? this.moveActiveItem(\"next\", e) : this;\n    }\n    moveActiveItem(direction, e) {\n        if (this.activeIndex != null) {\n            const activeIndex = direction === \"next\"\n                ? this.getNextActiveIndex()\n                : this.getPrevActiveIndex();\n            if (activeIndex != null) {\n                this.activate(activeIndex);\n                e.preventDefault();\n            }\n        }\n        return this;\n    }\n    activate(index) {\n        if (this.activeIndex !== index) {\n            if (this.activeIndex != null) {\n                this.items[this.activeIndex].deactivate();\n            }\n            this.activeIndex = index;\n            this.items[index].activate();\n        }\n        return this;\n    }\n    isShown() {\n        return this.shown;\n    }\n    getActiveItem() {\n        return this.activeIndex != null ? this.items[this.activeIndex] : null;\n    }\n    setOffset(cursorOffset) {\n        const doc = document.documentElement;\n        if (doc) {\n            const elementWidth = this.el.offsetWidth;\n            if (cursorOffset.left) {\n                const browserWidth = this.option.dynamicWidth\n                    ? doc.scrollWidth\n                    : doc.clientWidth;\n                if (cursorOffset.left + elementWidth > browserWidth) {\n                    cursorOffset.left = browserWidth - elementWidth;\n                }\n                this.el.style.left = `${cursorOffset.left}px`;\n            }\n            else if (cursorOffset.right) {\n                if (cursorOffset.right - elementWidth < 0) {\n                    cursorOffset.right = 0;\n                }\n                this.el.style.right = `${cursorOffset.right}px`;\n            }\n            let forceTop = false;\n            const placement = this.option.placement || exports.DEFAULT_DROPDOWN_PLACEMENT;\n            if (placement === \"auto\") {\n                const dropdownHeight = this.items.length * cursorOffset.lineHeight;\n                forceTop =\n                    cursorOffset.clientTop != null &&\n                        cursorOffset.clientTop + dropdownHeight > doc.clientHeight;\n            }\n            if (placement === \"top\" || forceTop) {\n                this.el.style.bottom = `${doc.clientHeight - cursorOffset.top + cursorOffset.lineHeight}px`;\n                this.el.style.top = \"auto\";\n            }\n            else {\n                this.el.style.top = `${cursorOffset.top}px`;\n                this.el.style.bottom = \"auto\";\n            }\n        }\n        return this;\n    }\n    getNextActiveIndex() {\n        if (this.activeIndex == null)\n            throw new Error();\n        return this.activeIndex < this.items.length - 1\n            ? this.activeIndex + 1\n            : this.option.rotate\n                ? 0\n                : null;\n    }\n    getPrevActiveIndex() {\n        if (this.activeIndex == null)\n            throw new Error();\n        return this.activeIndex !== 0\n            ? this.activeIndex - 1\n            : this.option.rotate\n                ? this.items.length - 1\n                : null;\n    }\n    renderItems() {\n        const fragment = document.createDocumentFragment();\n        for (const item of this.items) {\n            fragment.appendChild(item.el);\n        }\n        this.el.appendChild(fragment);\n        return this;\n    }\n    setStrategyId(searchResult) {\n        const id = searchResult.getStrategyId();\n        if (id)\n            this.el.dataset.strategy = id;\n        return this;\n    }\n    renderEdge(searchResults, type) {\n        const option = this.option[type];\n        const li = document.createElement(\"li\");\n        li.className = `textcomplete-${type}`;\n        li.innerHTML =\n            typeof option === \"function\"\n                ? option(searchResults.map((s) => s.data))\n                : option || \"\";\n        this.el.appendChild(li);\n        return this;\n    }\n}\nexports.Dropdown = Dropdown;\nclass DropdownItem {\n    constructor(dropdown, index, searchResult, props) {\n        this.dropdown = dropdown;\n        this.index = index;\n        this.searchResult = searchResult;\n        this.props = props;\n        this.active = false;\n        this.onClick = (e) => {\n            e.preventDefault();\n            this.dropdown.select(this);\n        };\n        this.className = this.props.className || exports.DEFAULT_DROPDOWN_ITEM_CLASS_NAME;\n        this.activeClassName =\n            this.props.activeClassName || exports.DEFAULT_DROPDOWN_ITEM_ACTIVE_CLASS_NAME;\n        const li = document.createElement(\"li\");\n        li.className = this.active ? this.activeClassName : this.className;\n        const span = document.createElement(\"span\");\n        span.tabIndex = -1;\n        span.innerHTML = this.searchResult.render();\n        li.appendChild(span);\n        li.addEventListener(\"click\", this.onClick);\n        this.el = li;\n    }\n    destroy() {\n        var _a;\n        const li = this.el;\n        (_a = li.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(li);\n        li.removeEventListener(\"click\", this.onClick, false);\n        return this;\n    }\n    activate() {\n        if (!this.active) {\n            this.active = true;\n            this.el.className = this.activeClassName;\n            this.dropdown.el.scrollTop = this.el.offsetTop;\n        }\n        return this;\n    }\n    deactivate() {\n        if (this.active) {\n            this.active = false;\n            this.el.className = this.className;\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=Dropdown.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/core/dist/Dropdown.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/core/dist/Editor.js":
/*!********************************************************!*\
  !*** ./node_modules/@textcomplete/core/dist/Editor.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Editor = void 0;\nconst eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@textcomplete/core/dist/utils.js\");\nclass Editor extends eventemitter3_1.EventEmitter {\n    /**\n     * Finalize the editor object.\n     *\n     * It is called when associated textcomplete object is destroyed.\n     */\n    destroy() {\n        return this;\n    }\n    /**\n     * It is called when a search result is selected by a user.\n     */\n    applySearchResult(_searchResult) {\n        throw new Error(\"Not implemented.\");\n    }\n    /**\n     * The input cursor's absolute coordinates from the window's left\n     * top corner.\n     */\n    getCursorOffset() {\n        throw new Error(\"Not implemented.\");\n    }\n    /**\n     * Editor string value from head to the cursor.\n     * Returns null if selection type is range not cursor.\n     */\n    getBeforeCursor() {\n        throw new Error(\"Not implemented.\");\n    }\n    /**\n     * Emit a move event, which moves active dropdown element.\n     * Child class must call this method at proper timing with proper parameter.\n     *\n     * @see {@link Textarea} for live example.\n     */\n    emitMoveEvent(code) {\n        const moveEvent = (0, utils_1.createCustomEvent)(\"move\", {\n            cancelable: true,\n            detail: {\n                code: code,\n            },\n        });\n        this.emit(\"move\", moveEvent);\n        return moveEvent;\n    }\n    /**\n     * Emit a enter event, which selects current search result.\n     * Child class must call this method at proper timing.\n     *\n     * @see {@link Textarea} for live example.\n     */\n    emitEnterEvent() {\n        const enterEvent = (0, utils_1.createCustomEvent)(\"enter\", { cancelable: true });\n        this.emit(\"enter\", enterEvent);\n        return enterEvent;\n    }\n    /**\n     * Emit a change event, which triggers auto completion.\n     * Child class must call this method at proper timing.\n     *\n     * @see {@link Textarea} for live example.\n     */\n    emitChangeEvent() {\n        const changeEvent = (0, utils_1.createCustomEvent)(\"change\", {\n            detail: {\n                beforeCursor: this.getBeforeCursor(),\n            },\n        });\n        this.emit(\"change\", changeEvent);\n        return changeEvent;\n    }\n    /**\n     * Emit a esc event, which hides dropdown element.\n     * Child class must call this method at proper timing.\n     *\n     * @see {@link Textarea} for live example.\n     */\n    emitEscEvent() {\n        const escEvent = (0, utils_1.createCustomEvent)(\"esc\", { cancelable: true });\n        this.emit(\"esc\", escEvent);\n        return escEvent;\n    }\n    /**\n     * Helper method for parsing KeyboardEvent.\n     *\n     * @see {@link Textarea} for live example.\n     */\n    getCode(e) {\n        switch (e.keyCode) {\n            case 9: // tab\n            case 13: // enter\n                return \"ENTER\";\n            case 27: // esc\n                return \"ESC\";\n            case 38: // up\n                return \"UP\";\n            case 40: // down\n                return \"DOWN\";\n            case 78: // ctrl-n\n                if (e.ctrlKey)\n                    return \"DOWN\";\n                break;\n            case 80: // ctrl-p\n                if (e.ctrlKey)\n                    return \"UP\";\n                break;\n        }\n        return \"OTHER\";\n    }\n}\nexports.Editor = Editor;\n//# sourceMappingURL=Editor.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/core/dist/Editor.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/core/dist/SearchResult.js":
/*!**************************************************************!*\
  !*** ./node_modules/@textcomplete/core/dist/SearchResult.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SearchResult = void 0;\nconst MAIN = /\\$&/g;\nconst PLACE = /\\$(\\d)/g;\nclass SearchResult {\n    constructor(data, term, strategy) {\n        this.data = data;\n        this.term = term;\n        this.strategy = strategy;\n    }\n    getReplacementData(beforeCursor) {\n        let result = this.strategy.replace(this.data);\n        if (result == null)\n            return null;\n        let afterCursor = \"\";\n        if (Array.isArray(result)) {\n            afterCursor = result[1];\n            result = result[0];\n        }\n        const match = this.strategy.match(beforeCursor);\n        if (match == null || match.index == null)\n            return null;\n        const replacement = result\n            .replace(MAIN, match[0])\n            .replace(PLACE, (_, p) => match[parseInt(p)]);\n        return {\n            start: match.index,\n            end: match.index + match[0].length,\n            beforeCursor: replacement,\n            afterCursor: afterCursor,\n        };\n    }\n    replace(beforeCursor, afterCursor) {\n        const replacement = this.getReplacementData(beforeCursor);\n        if (replacement === null)\n            return;\n        afterCursor = replacement.afterCursor + afterCursor;\n        return [\n            [\n                beforeCursor.slice(0, replacement.start),\n                replacement.beforeCursor,\n                beforeCursor.slice(replacement.end),\n            ].join(\"\"),\n            afterCursor,\n        ];\n    }\n    render() {\n        return this.strategy.renderTemplate(this.data, this.term);\n    }\n    getStrategyId() {\n        return this.strategy.getId();\n    }\n}\nexports.SearchResult = SearchResult;\n//# sourceMappingURL=SearchResult.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/core/dist/SearchResult.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/core/dist/Strategy.js":
/*!**********************************************************!*\
  !*** ./node_modules/@textcomplete/core/dist/Strategy.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Strategy = exports.DEFAULT_INDEX = void 0;\nconst SearchResult_1 = __webpack_require__(/*! ./SearchResult */ \"./node_modules/@textcomplete/core/dist/SearchResult.js\");\nexports.DEFAULT_INDEX = 1;\nclass Strategy {\n    constructor(props) {\n        this.props = props;\n        this.cache = {};\n    }\n    destroy() {\n        this.cache = {};\n        return this;\n    }\n    replace(data) {\n        return this.props.replace(data);\n    }\n    execute(beforeCursor, callback) {\n        var _a;\n        const match = this.matchWithContext(beforeCursor);\n        if (!match)\n            return false;\n        const term = match[(_a = this.props.index) !== null && _a !== void 0 ? _a : exports.DEFAULT_INDEX];\n        this.search(term, (results) => {\n            callback(results.map((result) => new SearchResult_1.SearchResult(result, term, this)));\n        }, match);\n        return true;\n    }\n    renderTemplate(data, term) {\n        if (this.props.template) {\n            return this.props.template(data, term);\n        }\n        if (typeof data === \"string\")\n            return data;\n        throw new Error(`Unexpected render data type: ${typeof data}. Please implement template parameter by yourself`);\n    }\n    getId() {\n        return this.props.id || null;\n    }\n    match(text) {\n        return typeof this.props.match === \"function\"\n            ? this.props.match(text)\n            : text.match(this.props.match);\n    }\n    search(term, callback, match) {\n        if (this.props.cache) {\n            this.searchWithCach(term, callback, match);\n        }\n        else {\n            this.props.search(term, callback, match);\n        }\n    }\n    matchWithContext(beforeCursor) {\n        const context = this.context(beforeCursor);\n        if (context === false)\n            return null;\n        return this.match(context === true ? beforeCursor : context);\n    }\n    context(beforeCursor) {\n        return this.props.context ? this.props.context(beforeCursor) : true;\n    }\n    searchWithCach(term, callback, match) {\n        if (this.cache[term] != null) {\n            callback(this.cache[term]);\n        }\n        else {\n            this.props.search(term, (results) => {\n                this.cache[term] = results;\n                callback(results);\n            }, match);\n        }\n    }\n}\nexports.Strategy = Strategy;\n//# sourceMappingURL=Strategy.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/core/dist/Strategy.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/core/dist/Textcomplete.js":
/*!**************************************************************!*\
  !*** ./node_modules/@textcomplete/core/dist/Textcomplete.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Textcomplete = void 0;\nconst eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nconst Dropdown_1 = __webpack_require__(/*! ./Dropdown */ \"./node_modules/@textcomplete/core/dist/Dropdown.js\");\nconst Completer_1 = __webpack_require__(/*! ./Completer */ \"./node_modules/@textcomplete/core/dist/Completer.js\");\nconst PASSTHOUGH_EVENT_NAMES = [\n    \"show\",\n    \"shown\",\n    \"render\",\n    \"rendered\",\n    \"selected\",\n    \"hidden\",\n    \"hide\",\n];\nclass Textcomplete extends eventemitter3_1.EventEmitter {\n    constructor(editor, strategies, option) {\n        super();\n        this.editor = editor;\n        this.isQueryInFlight = false;\n        this.nextPendingQuery = null;\n        this.handleHit = ({ searchResults, }) => {\n            if (searchResults.length) {\n                this.dropdown.render(searchResults, this.editor.getCursorOffset());\n            }\n            else {\n                this.dropdown.hide();\n            }\n            this.isQueryInFlight = false;\n            if (this.nextPendingQuery !== null)\n                this.trigger(this.nextPendingQuery);\n        };\n        this.handleMove = (e) => {\n            e.detail.code === \"UP\" ? this.dropdown.up(e) : this.dropdown.down(e);\n        };\n        this.handleEnter = (e) => {\n            const activeItem = this.dropdown.getActiveItem();\n            if (activeItem) {\n                this.dropdown.select(activeItem);\n                e.preventDefault();\n            }\n            else {\n                this.dropdown.hide();\n            }\n        };\n        this.handleEsc = (e) => {\n            if (this.dropdown.isShown()) {\n                this.dropdown.hide();\n                e.preventDefault();\n            }\n        };\n        this.handleChange = (e) => {\n            if (e.detail.beforeCursor != null) {\n                this.trigger(e.detail.beforeCursor);\n            }\n            else {\n                this.dropdown.hide();\n            }\n        };\n        this.handleSelect = (selectEvent) => {\n            this.emit(\"select\", selectEvent);\n            if (!selectEvent.defaultPrevented) {\n                this.editor.applySearchResult(selectEvent.detail.searchResult);\n            }\n        };\n        this.handleResize = () => {\n            if (this.dropdown.isShown()) {\n                this.dropdown.setOffset(this.editor.getCursorOffset());\n            }\n        };\n        this.completer = new Completer_1.Completer(strategies);\n        this.dropdown = Dropdown_1.Dropdown.create((option === null || option === void 0 ? void 0 : option.dropdown) || {});\n        this.startListening();\n    }\n    destroy(destroyEditor = true) {\n        this.completer.destroy();\n        this.dropdown.destroy();\n        if (destroyEditor)\n            this.editor.destroy();\n        this.stopListening();\n        return this;\n    }\n    isShown() {\n        return this.dropdown.isShown();\n    }\n    hide() {\n        this.dropdown.hide();\n        return this;\n    }\n    trigger(beforeCursor) {\n        if (this.isQueryInFlight) {\n            this.nextPendingQuery = beforeCursor;\n        }\n        else {\n            this.isQueryInFlight = true;\n            this.nextPendingQuery = null;\n            this.completer.run(beforeCursor);\n        }\n        return this;\n    }\n    startListening() {\n        var _a;\n        this.editor\n            .on(\"move\", this.handleMove)\n            .on(\"enter\", this.handleEnter)\n            .on(\"esc\", this.handleEsc)\n            .on(\"change\", this.handleChange);\n        this.dropdown.on(\"select\", this.handleSelect);\n        for (const eventName of PASSTHOUGH_EVENT_NAMES) {\n            this.dropdown.on(eventName, (e) => this.emit(eventName, e));\n        }\n        this.completer.on(\"hit\", this.handleHit);\n        (_a = this.dropdown.el.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.addEventListener(\"resize\", this.handleResize);\n    }\n    stopListening() {\n        var _a;\n        (_a = this.dropdown.el.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"resize\", this.handleResize);\n        this.completer.removeAllListeners();\n        this.dropdown.removeAllListeners();\n        this.editor\n            .removeListener(\"move\", this.handleMove)\n            .removeListener(\"enter\", this.handleEnter)\n            .removeListener(\"esc\", this.handleEsc)\n            .removeListener(\"change\", this.handleChange);\n    }\n}\nexports.Textcomplete = Textcomplete;\n//# sourceMappingURL=Textcomplete.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/core/dist/Textcomplete.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/core/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@textcomplete/core/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./Completer */ \"./node_modules/@textcomplete/core/dist/Completer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Dropdown */ \"./node_modules/@textcomplete/core/dist/Dropdown.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Editor */ \"./node_modules/@textcomplete/core/dist/Editor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SearchResult */ \"./node_modules/@textcomplete/core/dist/SearchResult.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Strategy */ \"./node_modules/@textcomplete/core/dist/Strategy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Textcomplete */ \"./node_modules/@textcomplete/core/dist/Textcomplete.js\"), exports);\n__exportStar(__webpack_require__(/*! ./utils */ \"./node_modules/@textcomplete/core/dist/utils.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/core/dist/index.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/core/dist/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@textcomplete/core/dist/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createCustomEvent = void 0;\nconst isCustomEventSupported = typeof window !== \"undefined\" && !!window.CustomEvent;\nconst createCustomEvent = (type, options) => {\n    if (isCustomEventSupported)\n        return new CustomEvent(type, options);\n    const event = document.createEvent(\"CustomEvent\");\n    event.initCustomEvent(type, \n    /* bubbles */ false, (options === null || options === void 0 ? void 0 : options.cancelable) || false, (options === null || options === void 0 ? void 0 : options.detail) || undefined);\n    return event;\n};\nexports.createCustomEvent = createCustomEvent;\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/core/dist/utils.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/textarea/dist/TextareaEditor.js":
/*!********************************************************************!*\
  !*** ./node_modules/@textcomplete/textarea/dist/TextareaEditor.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextareaEditor = void 0;\nconst undate_1 = __webpack_require__(/*! undate */ \"./node_modules/undate/dist/index.mjs\");\nconst textarea_caret_1 = __importDefault(__webpack_require__(/*! textarea-caret */ \"./node_modules/textarea-caret/index.js\"));\nconst core_1 = __webpack_require__(/*! @textcomplete/core */ \"./node_modules/@textcomplete/core/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! @textcomplete/utils */ \"./node_modules/@textcomplete/utils/dist/index.js\");\nclass TextareaEditor extends core_1.Editor {\n    constructor(el) {\n        super();\n        this.el = el;\n        this.onInput = () => {\n            this.emitChangeEvent();\n        };\n        this.onKeydown = (e) => {\n            const code = this.getCode(e);\n            let event;\n            if (code === \"UP\" || code === \"DOWN\") {\n                event = this.emitMoveEvent(code);\n            }\n            else if (code === \"ENTER\") {\n                event = this.emitEnterEvent();\n            }\n            else if (code === \"ESC\") {\n                event = this.emitEscEvent();\n            }\n            if (event && event.defaultPrevented) {\n                e.preventDefault();\n            }\n        };\n        this.startListening();\n    }\n    destroy() {\n        super.destroy();\n        this.stopListening();\n        return this;\n    }\n    /**\n     * @implements {@link Editor#applySearchResult}\n     */\n    applySearchResult(searchResult) {\n        const beforeCursor = this.getBeforeCursor();\n        if (beforeCursor != null) {\n            const replace = searchResult.replace(beforeCursor, this.getAfterCursor());\n            this.el.focus(); // Clicking a dropdown item removes focus from the element.\n            if (Array.isArray(replace)) {\n                (0, undate_1.update)(this.el, replace[0], replace[1]);\n                if (this.el) {\n                    this.el.dispatchEvent((0, core_1.createCustomEvent)(\"input\"));\n                }\n            }\n        }\n    }\n    /**\n     * @implements {@link Editor#getCursorOffset}\n     */\n    getCursorOffset() {\n        const elOffset = (0, utils_1.calculateElementOffset)(this.el);\n        const elScroll = this.getElScroll();\n        const cursorPosition = this.getCursorPosition();\n        const lineHeight = (0, utils_1.getLineHeightPx)(this.el);\n        const top = elOffset.top - elScroll.top + cursorPosition.top + lineHeight;\n        const left = elOffset.left - elScroll.left + cursorPosition.left;\n        const clientTop = this.el.getBoundingClientRect().top;\n        if (this.el.dir !== \"rtl\") {\n            return { top, left, lineHeight, clientTop };\n        }\n        else {\n            const right = document.documentElement\n                ? document.documentElement.clientWidth - left\n                : 0;\n            return { top, right, lineHeight, clientTop };\n        }\n    }\n    /**\n     * @implements {@link Editor#getBeforeCursor}\n     */\n    getBeforeCursor() {\n        return this.el.selectionStart !== this.el.selectionEnd\n            ? null\n            : this.el.value.substring(0, this.el.selectionEnd);\n    }\n    getAfterCursor() {\n        return this.el.value.substring(this.el.selectionEnd);\n    }\n    getElScroll() {\n        return { top: this.el.scrollTop, left: this.el.scrollLeft };\n    }\n    /**\n     * The input cursor's relative coordinates from the textarea's left\n     * top corner.\n     */\n    getCursorPosition() {\n        return (0, textarea_caret_1.default)(this.el, this.el.selectionEnd);\n    }\n    startListening() {\n        this.el.addEventListener(\"input\", this.onInput);\n        this.el.addEventListener(\"keydown\", this.onKeydown);\n    }\n    stopListening() {\n        this.el.removeEventListener(\"input\", this.onInput);\n        this.el.removeEventListener(\"keydown\", this.onKeydown);\n    }\n}\nexports.TextareaEditor = TextareaEditor;\n//# sourceMappingURL=TextareaEditor.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/textarea/dist/TextareaEditor.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/textarea/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@textcomplete/textarea/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextareaEditor = void 0;\nvar TextareaEditor_1 = __webpack_require__(/*! ./TextareaEditor */ \"./node_modules/@textcomplete/textarea/dist/TextareaEditor.js\");\nObject.defineProperty(exports, \"TextareaEditor\", ({ enumerable: true, get: function () { return TextareaEditor_1.TextareaEditor; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/textarea/dist/index.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/utils/dist/calculateElementOffset.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@textcomplete/utils/dist/calculateElementOffset.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.calculateElementOffset = void 0;\n/**\n * Get the current coordinates of the `el` relative to the document.\n */\nconst calculateElementOffset = (el) => {\n    const rect = el.getBoundingClientRect();\n    const owner = el.ownerDocument;\n    if (owner == null) {\n        throw new Error(\"Given element does not belong to document\");\n    }\n    const { defaultView, documentElement } = owner;\n    if (defaultView == null) {\n        throw new Error(\"Given element does not belong to window\");\n    }\n    const offset = {\n        top: rect.top + defaultView.pageYOffset,\n        left: rect.left + defaultView.pageXOffset,\n    };\n    if (documentElement) {\n        offset.top -= documentElement.clientTop;\n        offset.left -= documentElement.clientLeft;\n    }\n    return offset;\n};\nexports.calculateElementOffset = calculateElementOffset;\n//# sourceMappingURL=calculateElementOffset.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/utils/dist/calculateElementOffset.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/utils/dist/getLineHeightPx.js":
/*!******************************************************************!*\
  !*** ./node_modules/@textcomplete/utils/dist/getLineHeightPx.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getLineHeightPx = void 0;\nconst CHAR_CODE_ZERO = \"0\".charCodeAt(0);\nconst CHAR_CODE_NINE = \"9\".charCodeAt(0);\nconst isDigit = (charCode) => CHAR_CODE_ZERO <= charCode && charCode <= CHAR_CODE_NINE;\nconst getLineHeightPx = (el) => {\n    const computedStyle = getComputedStyle(el);\n    const lineHeight = computedStyle.lineHeight;\n    // If the char code starts with a digit, it is either a value in pixels,\n    // or unitless, as per:\n    // https://drafts.csswg.org/css2/visudet.html#propdef-line-height\n    // https://drafts.csswg.org/css2/cascade.html#computed-value\n    if (isDigit(lineHeight.charCodeAt(0))) {\n        const floatLineHeight = parseFloat(lineHeight);\n        // In real browsers the value is *always* in pixels, even for unit-less\n        // line-heights. However, we still check as per the spec.\n        return isDigit(lineHeight.charCodeAt(lineHeight.length - 1))\n            ? floatLineHeight * parseFloat(computedStyle.fontSize)\n            : floatLineHeight;\n    }\n    // Otherwise, the value is \"normal\".\n    // If the line-height is \"normal\", calculate by font-size\n    return calculateLineHeightPx(el.nodeName, computedStyle);\n};\nexports.getLineHeightPx = getLineHeightPx;\n/**\n * Returns calculated line-height of the given node in pixels.\n */\nconst calculateLineHeightPx = (nodeName, computedStyle) => {\n    const body = document.body;\n    if (!body)\n        return 0;\n    const tempNode = document.createElement(nodeName);\n    tempNode.innerHTML = \"&nbsp;\";\n    Object.assign(tempNode.style, {\n        fontSize: computedStyle.fontSize,\n        fontFamily: computedStyle.fontFamily,\n        padding: \"0\",\n    });\n    body.appendChild(tempNode);\n    // Make sure textarea has only 1 row\n    if (tempNode instanceof HTMLTextAreaElement) {\n        tempNode.rows = 1;\n    }\n    // Assume the height of the element is the line-height\n    const height = tempNode.offsetHeight;\n    body.removeChild(tempNode);\n    return height;\n};\n//# sourceMappingURL=getLineHeightPx.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/utils/dist/getLineHeightPx.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/utils/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@textcomplete/utils/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./calculateElementOffset */ \"./node_modules/@textcomplete/utils/dist/calculateElementOffset.js\"), exports);\n__exportStar(__webpack_require__(/*! ./getLineHeightPx */ \"./node_modules/@textcomplete/utils/dist/getLineHeightPx.js\"), exports);\n__exportStar(__webpack_require__(/*! ./isSafari */ \"./node_modules/@textcomplete/utils/dist/isSafari.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/utils/dist/index.js?");

/***/ }),

/***/ "./node_modules/@textcomplete/utils/dist/isSafari.js":
/*!***********************************************************!*\
  !*** ./node_modules/@textcomplete/utils/dist/isSafari.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSafari = void 0;\nconst isSafari = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\nexports.isSafari = isSafari;\n//# sourceMappingURL=isSafari.js.map\n\n//# sourceURL=webpack://hanfor/./node_modules/@textcomplete/utils/dist/isSafari.js?");

/***/ }),

/***/ "./node_modules/datatables.net-select-bs5/js/select.bootstrap5.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/datatables.net-select-bs5/js/select.bootstrap5.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var datatables_net_bs5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net-bs5 */ \"./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs\");\n/* harmony import */ var datatables_net_select__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! datatables.net-select */ \"./node_modules/datatables.net-select/js/dataTables.select.mjs\");\n/*! Bootstrap 5 styling wrapper for Select\n *  SpryMedia Ltd - datatables.net/license\n */\n\n\n\n\n\n// Allow reassignment of the $ variable\nlet $ = jquery__WEBPACK_IMPORTED_MODULE_0__;\n\n\ndatatables_net_bs5__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select.classes.checkbox = 'form-check-input';\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net_bs5__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n//# sourceURL=webpack://hanfor/./node_modules/datatables.net-select-bs5/js/select.bootstrap5.mjs?");

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://hanfor/./node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./node_modules/fuse.js/dist/fuse.cjs":
/*!********************************************!*\
  !*** ./node_modules/fuse.js/dist/fuse.cjs ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * Fuse.js v7.0.0 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2023 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction isArray(value) {\n  return !Array.isArray ? getTag(value) === '[object Array]' : Array.isArray(value);\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nvar INFINITY = 1 / 0;\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  var result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n}\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\nfunction isString(value) {\n  return typeof value === 'string';\n}\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n  return value === true || value === false || isObjectLike(value) && getTag(value) == '[object Boolean]';\n}\nfunction isObject(value) {\n  return _typeof(value) === 'object';\n}\n\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n  return isObject(value) && value !== null;\n}\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\nfunction isBlank(value) {\n  return !value.trim().length;\n}\n\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n  return value == null ? value === undefined ? '[object Undefined]' : '[object Null]' : Object.prototype.toString.call(value);\n}\n\nvar EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\nvar INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\nvar LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = function LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key) {\n  return \"Invalid value for key \".concat(key);\n};\nvar PATTERN_LENGTH_TOO_LARGE = function PATTERN_LENGTH_TOO_LARGE(max) {\n  return \"Pattern length exceeds max of \".concat(max, \".\");\n};\nvar MISSING_KEY_PROPERTY = function MISSING_KEY_PROPERTY(name) {\n  return \"Missing \".concat(name, \" property in key\");\n};\nvar INVALID_KEY_WEIGHT_VALUE = function INVALID_KEY_WEIGHT_VALUE(key) {\n  return \"Property 'weight' in key '\".concat(key, \"' must be a positive integer\");\n};\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar KeyStore = /*#__PURE__*/function () {\n  function KeyStore(keys) {\n    var _this = this;\n    _classCallCheck(this, KeyStore);\n    this._keys = [];\n    this._keyMap = {};\n    var totalWeight = 0;\n    keys.forEach(function (key) {\n      var obj = createKey(key);\n      _this._keys.push(obj);\n      _this._keyMap[obj.id] = obj;\n      totalWeight += obj.weight;\n    });\n\n    // Normalize weights so that their sum is equal to 1\n    this._keys.forEach(function (key) {\n      key.weight /= totalWeight;\n    });\n  }\n  _createClass(KeyStore, [{\n    key: \"get\",\n    value: function get(keyId) {\n      return this._keyMap[keyId];\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return this._keys;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return JSON.stringify(this._keys);\n    }\n  }]);\n  return KeyStore;\n}();\nfunction createKey(key) {\n  var path = null;\n  var id = null;\n  var src = null;\n  var weight = 1;\n  var getFn = null;\n  if (isString(key) || isArray(key)) {\n    src = key;\n    path = createKeyPath(key);\n    id = createKeyId(key);\n  } else {\n    if (!hasOwn.call(key, 'name')) {\n      throw new Error(MISSING_KEY_PROPERTY('name'));\n    }\n    var name = key.name;\n    src = name;\n    if (hasOwn.call(key, 'weight')) {\n      weight = key.weight;\n      if (weight <= 0) {\n        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));\n      }\n    }\n    path = createKeyPath(name);\n    id = createKeyId(name);\n    getFn = key.getFn;\n  }\n  return {\n    path: path,\n    id: id,\n    weight: weight,\n    src: src,\n    getFn: getFn\n  };\n}\nfunction createKeyPath(key) {\n  return isArray(key) ? key : key.split('.');\n}\nfunction createKeyId(key) {\n  return isArray(key) ? key.join('.') : key;\n}\n\nfunction get(obj, path) {\n  var list = [];\n  var arr = false;\n  var deepGet = function deepGet(obj, path, index) {\n    if (!isDefined(obj)) {\n      return;\n    }\n    if (!path[index]) {\n      // If there's no path left, we've arrived at the object we care about.\n      list.push(obj);\n    } else {\n      var key = path[index];\n      var value = obj[key];\n      if (!isDefined(value)) {\n        return;\n      }\n\n      // If we're at the last value in the path, and if it's a string/number/bool,\n      // add it to the list\n      if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {\n        list.push(toString(value));\n      } else if (isArray(value)) {\n        arr = true;\n        // Search each item in the array.\n        for (var i = 0, len = value.length; i < len; i += 1) {\n          deepGet(value[i], path, index + 1);\n        }\n      } else if (path.length) {\n        // An object. Recurse further.\n        deepGet(value, path, index + 1);\n      }\n    }\n  };\n\n  // Backwards compatibility (since path used to be a string)\n  deepGet(obj, isString(path) ? path.split('.') : path, 0);\n  return arr ? list : list[0];\n}\n\nvar MatchOptions = {\n  // Whether the matches should be included in the result set. When `true`, each record in the result\n  // set will include the indices of the matched characters.\n  // These can consequently be used for highlighting purposes.\n  includeMatches: false,\n  // When `true`, the matching function will continue to the end of a search pattern even if\n  // a perfect match has already been located in the string.\n  findAllMatches: false,\n  // Minimum number of characters that must be matched before a result is considered a match\n  minMatchCharLength: 1\n};\nvar BasicOptions = {\n  // When `true`, the algorithm continues searching to the end of the input even if a perfect\n  // match is found before the end of the same input.\n  isCaseSensitive: false,\n  // When true, the matching function will continue to the end of a search pattern even if\n  includeScore: false,\n  // List of properties that will be searched. This also supports nested properties.\n  keys: [],\n  // Whether to sort the result list, by score\n  shouldSort: true,\n  // Default sort function: sort by ascending score, ascending index\n  sortFn: function sortFn(a, b) {\n    return a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1;\n  }\n};\nvar FuzzyOptions = {\n  // Approximately where in the text is the pattern expected to be found?\n  location: 0,\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n  // (of both letters and location), a threshold of '1.0' would match anything.\n  threshold: 0.6,\n  // Determines how close the match must be to the fuzzy location (specified above).\n  // An exact letter match which is 'distance' characters away from the fuzzy location\n  // would score as a complete mismatch. A distance of '0' requires the match be at\n  // the exact location specified, a threshold of '1000' would require a perfect match\n  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n  distance: 100\n};\nvar AdvancedOptions = {\n  // When `true`, it enables the use of unix-like search commands\n  useExtendedSearch: false,\n  // The get function to use when fetching an object's properties.\n  // The default will search nested paths *ie foo.bar.baz*\n  getFn: get,\n  // When `true`, search will ignore `location` and `distance`, so it won't matter\n  // where in the string the pattern appears.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n  ignoreLocation: false,\n  // When `true`, the calculation for the relevance score (used for sorting) will\n  // ignore the field-length norm.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n  ignoreFieldNorm: false,\n  // The weight to determine how much field length norm effects scoring.\n  fieldNormWeight: 1\n};\nvar Config = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, BasicOptions), MatchOptions), FuzzyOptions), AdvancedOptions);\n\nvar SPACE = /[^ ]+/g;\n\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm() {\n  var weight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var mantissa = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  var cache = new Map();\n  var m = Math.pow(10, mantissa);\n  return {\n    get: function get(value) {\n      var numTokens = value.match(SPACE).length;\n      if (cache.has(numTokens)) {\n        return cache.get(numTokens);\n      }\n\n      // Default function is 1/sqrt(x), weight makes that variable\n      var norm = 1 / Math.pow(numTokens, 0.5 * weight);\n\n      // In place of `toFixed(mantissa)`, for faster computation\n      var n = parseFloat(Math.round(norm * m) / m);\n      cache.set(numTokens, n);\n      return n;\n    },\n    clear: function clear() {\n      cache.clear();\n    }\n  };\n}\n\nvar FuseIndex = /*#__PURE__*/function () {\n  function FuseIndex() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$getFn = _ref.getFn,\n      getFn = _ref$getFn === void 0 ? Config.getFn : _ref$getFn,\n      _ref$fieldNormWeight = _ref.fieldNormWeight,\n      fieldNormWeight = _ref$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref$fieldNormWeight;\n    _classCallCheck(this, FuseIndex);\n    this.norm = norm(fieldNormWeight, 3);\n    this.getFn = getFn;\n    this.isCreated = false;\n    this.setIndexRecords();\n  }\n  _createClass(FuseIndex, [{\n    key: \"setSources\",\n    value: function setSources() {\n      var docs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      this.docs = docs;\n    }\n  }, {\n    key: \"setIndexRecords\",\n    value: function setIndexRecords() {\n      var records = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      this.records = records;\n    }\n  }, {\n    key: \"setKeys\",\n    value: function setKeys() {\n      var _this = this;\n      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      this.keys = keys;\n      this._keysMap = {};\n      keys.forEach(function (key, idx) {\n        _this._keysMap[key.id] = idx;\n      });\n    }\n  }, {\n    key: \"create\",\n    value: function create() {\n      var _this2 = this;\n      if (this.isCreated || !this.docs.length) {\n        return;\n      }\n      this.isCreated = true;\n\n      // List is Array<String>\n      if (isString(this.docs[0])) {\n        this.docs.forEach(function (doc, docIndex) {\n          _this2._addString(doc, docIndex);\n        });\n      } else {\n        // List is Array<Object>\n        this.docs.forEach(function (doc, docIndex) {\n          _this2._addObject(doc, docIndex);\n        });\n      }\n      this.norm.clear();\n    }\n    // Adds a doc to the end of the index\n  }, {\n    key: \"add\",\n    value: function add(doc) {\n      var idx = this.size();\n      if (isString(doc)) {\n        this._addString(doc, idx);\n      } else {\n        this._addObject(doc, idx);\n      }\n    }\n    // Removes the doc at the specified index of the index\n  }, {\n    key: \"removeAt\",\n    value: function removeAt(idx) {\n      this.records.splice(idx, 1);\n\n      // Change ref index of every subsquent doc\n      for (var i = idx, len = this.size(); i < len; i += 1) {\n        this.records[i].i -= 1;\n      }\n    }\n  }, {\n    key: \"getValueForItemAtKeyId\",\n    value: function getValueForItemAtKeyId(item, keyId) {\n      return item[this._keysMap[keyId]];\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.records.length;\n    }\n  }, {\n    key: \"_addString\",\n    value: function _addString(doc, docIndex) {\n      if (!isDefined(doc) || isBlank(doc)) {\n        return;\n      }\n      var record = {\n        v: doc,\n        i: docIndex,\n        n: this.norm.get(doc)\n      };\n      this.records.push(record);\n    }\n  }, {\n    key: \"_addObject\",\n    value: function _addObject(doc, docIndex) {\n      var _this3 = this;\n      var record = {\n        i: docIndex,\n        $: {}\n      };\n\n      // Iterate over every key (i.e, path), and fetch the value at that key\n      this.keys.forEach(function (key, keyIndex) {\n        var value = key.getFn ? key.getFn(doc) : _this3.getFn(doc, key.path);\n        if (!isDefined(value)) {\n          return;\n        }\n        if (isArray(value)) {\n          var subRecords = [];\n          var stack = [{\n            nestedArrIndex: -1,\n            value: value\n          }];\n          while (stack.length) {\n            var _stack$pop = stack.pop(),\n              nestedArrIndex = _stack$pop.nestedArrIndex,\n              _value = _stack$pop.value;\n            if (!isDefined(_value)) {\n              continue;\n            }\n            if (isString(_value) && !isBlank(_value)) {\n              var subRecord = {\n                v: _value,\n                i: nestedArrIndex,\n                n: _this3.norm.get(_value)\n              };\n              subRecords.push(subRecord);\n            } else if (isArray(_value)) {\n              _value.forEach(function (item, k) {\n                stack.push({\n                  nestedArrIndex: k,\n                  value: item\n                });\n              });\n            } else ;\n          }\n          record.$[keyIndex] = subRecords;\n        } else if (isString(value) && !isBlank(value)) {\n          var _subRecord = {\n            v: value,\n            n: _this3.norm.get(value)\n          };\n          record.$[keyIndex] = _subRecord;\n        }\n      });\n      this.records.push(record);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        keys: this.keys,\n        records: this.records\n      };\n    }\n  }]);\n  return FuseIndex;\n}();\nfunction createIndex(keys, docs) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref2$getFn = _ref2.getFn,\n    getFn = _ref2$getFn === void 0 ? Config.getFn : _ref2$getFn,\n    _ref2$fieldNormWeight = _ref2.fieldNormWeight,\n    fieldNormWeight = _ref2$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref2$fieldNormWeight;\n  var myIndex = new FuseIndex({\n    getFn: getFn,\n    fieldNormWeight: fieldNormWeight\n  });\n  myIndex.setKeys(keys.map(createKey));\n  myIndex.setSources(docs);\n  myIndex.create();\n  return myIndex;\n}\nfunction parseIndex(data) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref3$getFn = _ref3.getFn,\n    getFn = _ref3$getFn === void 0 ? Config.getFn : _ref3$getFn,\n    _ref3$fieldNormWeight = _ref3.fieldNormWeight,\n    fieldNormWeight = _ref3$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref3$fieldNormWeight;\n  var keys = data.keys,\n    records = data.records;\n  var myIndex = new FuseIndex({\n    getFn: getFn,\n    fieldNormWeight: fieldNormWeight\n  });\n  myIndex.setKeys(keys);\n  myIndex.setIndexRecords(records);\n  return myIndex;\n}\n\nfunction computeScore$1(pattern) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$errors = _ref.errors,\n    errors = _ref$errors === void 0 ? 0 : _ref$errors,\n    _ref$currentLocation = _ref.currentLocation,\n    currentLocation = _ref$currentLocation === void 0 ? 0 : _ref$currentLocation,\n    _ref$expectedLocation = _ref.expectedLocation,\n    expectedLocation = _ref$expectedLocation === void 0 ? 0 : _ref$expectedLocation,\n    _ref$distance = _ref.distance,\n    distance = _ref$distance === void 0 ? Config.distance : _ref$distance,\n    _ref$ignoreLocation = _ref.ignoreLocation,\n    ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;\n  var accuracy = errors / pattern.length;\n  if (ignoreLocation) {\n    return accuracy;\n  }\n  var proximity = Math.abs(expectedLocation - currentLocation);\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy;\n  }\n  return accuracy + proximity / distance;\n}\n\nfunction convertMaskToIndices() {\n  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Config.minMatchCharLength;\n  var indices = [];\n  var start = -1;\n  var end = -1;\n  var i = 0;\n  for (var len = matchmask.length; i < len; i += 1) {\n    var match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        indices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    indices.push([start, i - 1]);\n  }\n  return indices;\n}\n\n// Machine word size\nvar MAX_BITS = 32;\n\nfunction search(text, pattern, patternAlphabet) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    _ref$location = _ref.location,\n    location = _ref$location === void 0 ? Config.location : _ref$location,\n    _ref$distance = _ref.distance,\n    distance = _ref$distance === void 0 ? Config.distance : _ref$distance,\n    _ref$threshold = _ref.threshold,\n    threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,\n    _ref$findAllMatches = _ref.findAllMatches,\n    findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,\n    _ref$minMatchCharLeng = _ref.minMatchCharLength,\n    minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,\n    _ref$includeMatches = _ref.includeMatches,\n    includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\n    _ref$ignoreLocation = _ref.ignoreLocation,\n    ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;\n  if (pattern.length > MAX_BITS) {\n    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));\n  }\n  var patternLen = pattern.length;\n  // Set starting location at beginning text and initialize the alphabet.\n  var textLen = text.length;\n  // Handle the case when location > text.length\n  var expectedLocation = Math.max(0, Math.min(location, textLen));\n  // Highest score beyond which we give up.\n  var currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  var bestLocation = expectedLocation;\n\n  // Performance: only computer matches when the minMatchCharLength > 1\n  // OR if `includeMatches` is true.\n  var computeMatches = minMatchCharLength > 1 || includeMatches;\n  // A mask of the matches, used for building the indices\n  var matchMask = computeMatches ? Array(textLen) : [];\n  var index;\n\n  // Get all exact matches, here for speed up\n  while ((index = text.indexOf(pattern, bestLocation)) > -1) {\n    var score = computeScore$1(pattern, {\n      currentLocation: index,\n      expectedLocation: expectedLocation,\n      distance: distance,\n      ignoreLocation: ignoreLocation\n    });\n    currentThreshold = Math.min(score, currentThreshold);\n    bestLocation = index + patternLen;\n    if (computeMatches) {\n      var i = 0;\n      while (i < patternLen) {\n        matchMask[index + i] = 1;\n        i += 1;\n      }\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n  var lastBitArr = [];\n  var finalScore = 1;\n  var binMax = patternLen + textLen;\n  var mask = 1 << patternLen - 1;\n  for (var _i = 0; _i < patternLen; _i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    var binMin = 0;\n    var binMid = binMax;\n    while (binMin < binMid) {\n      var _score = computeScore$1(pattern, {\n        errors: _i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation: expectedLocation,\n        distance: distance,\n        ignoreLocation: ignoreLocation\n      });\n      if (_score <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n    var start = Math.max(1, expectedLocation - binMid + 1);\n    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    var bitArr = Array(finish + 2);\n    bitArr[finish + 1] = (1 << _i) - 1;\n    for (var j = finish; j >= start; j -= 1) {\n      var currentLocation = j - 1;\n      var charMatch = patternAlphabet[text.charAt(currentLocation)];\n      if (computeMatches) {\n        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n        matchMask[currentLocation] = +!!charMatch;\n      }\n\n      // First pass: exact match\n      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (_i) {\n        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n      }\n      if (bitArr[j] & mask) {\n        finalScore = computeScore$1(pattern, {\n          errors: _i,\n          currentLocation: currentLocation,\n          expectedLocation: expectedLocation,\n          distance: distance,\n          ignoreLocation: ignoreLocation\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break;\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    var _score2 = computeScore$1(pattern, {\n      errors: _i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation: expectedLocation,\n      distance: distance,\n      ignoreLocation: ignoreLocation\n    });\n    if (_score2 > currentThreshold) {\n      break;\n    }\n    lastBitArr = bitArr;\n  }\n  var result = {\n    isMatch: bestLocation >= 0,\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    score: Math.max(0.001, finalScore)\n  };\n  if (computeMatches) {\n    var indices = convertMaskToIndices(matchMask, minMatchCharLength);\n    if (!indices.length) {\n      result.isMatch = false;\n    } else if (includeMatches) {\n      result.indices = indices;\n    }\n  }\n  return result;\n}\n\nfunction createPatternAlphabet(pattern) {\n  var mask = {};\n  for (var i = 0, len = pattern.length; i < len; i += 1) {\n    var _char = pattern.charAt(i);\n    mask[_char] = (mask[_char] || 0) | 1 << len - i - 1;\n  }\n  return mask;\n}\n\nvar BitapSearch = /*#__PURE__*/function () {\n  function BitapSearch(pattern) {\n    var _this = this;\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$location = _ref.location,\n      location = _ref$location === void 0 ? Config.location : _ref$location,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === void 0 ? Config.distance : _ref$distance,\n      _ref$includeMatches = _ref.includeMatches,\n      includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\n      _ref$findAllMatches = _ref.findAllMatches,\n      findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,\n      _ref$minMatchCharLeng = _ref.minMatchCharLength,\n      minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,\n      _ref$isCaseSensitive = _ref.isCaseSensitive,\n      isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,\n      _ref$ignoreLocation = _ref.ignoreLocation,\n      ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;\n    _classCallCheck(this, BitapSearch);\n    this.options = {\n      location: location,\n      threshold: threshold,\n      distance: distance,\n      includeMatches: includeMatches,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength,\n      isCaseSensitive: isCaseSensitive,\n      ignoreLocation: ignoreLocation\n    };\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.chunks = [];\n    if (!this.pattern.length) {\n      return;\n    }\n    var addChunk = function addChunk(pattern, startIndex) {\n      _this.chunks.push({\n        pattern: pattern,\n        alphabet: createPatternAlphabet(pattern),\n        startIndex: startIndex\n      });\n    };\n    var len = this.pattern.length;\n    if (len > MAX_BITS) {\n      var i = 0;\n      var remainder = len % MAX_BITS;\n      var end = len - remainder;\n      while (i < end) {\n        addChunk(this.pattern.substr(i, MAX_BITS), i);\n        i += MAX_BITS;\n      }\n      if (remainder) {\n        var startIndex = len - MAX_BITS;\n        addChunk(this.pattern.substr(startIndex), startIndex);\n      }\n    } else {\n      addChunk(this.pattern, 0);\n    }\n  }\n  _createClass(BitapSearch, [{\n    key: \"searchIn\",\n    value: function searchIn(text) {\n      var _this$options = this.options,\n        isCaseSensitive = _this$options.isCaseSensitive,\n        includeMatches = _this$options.includeMatches;\n      if (!isCaseSensitive) {\n        text = text.toLowerCase();\n      }\n\n      // Exact match\n      if (this.pattern === text) {\n        var _result = {\n          isMatch: true,\n          score: 0\n        };\n        if (includeMatches) {\n          _result.indices = [[0, text.length - 1]];\n        }\n        return _result;\n      }\n\n      // Otherwise, use Bitap algorithm\n      var _this$options2 = this.options,\n        location = _this$options2.location,\n        distance = _this$options2.distance,\n        threshold = _this$options2.threshold,\n        findAllMatches = _this$options2.findAllMatches,\n        minMatchCharLength = _this$options2.minMatchCharLength,\n        ignoreLocation = _this$options2.ignoreLocation;\n      var allIndices = [];\n      var totalScore = 0;\n      var hasMatches = false;\n      this.chunks.forEach(function (_ref2) {\n        var pattern = _ref2.pattern,\n          alphabet = _ref2.alphabet,\n          startIndex = _ref2.startIndex;\n        var _search = search(text, pattern, alphabet, {\n            location: location + startIndex,\n            distance: distance,\n            threshold: threshold,\n            findAllMatches: findAllMatches,\n            minMatchCharLength: minMatchCharLength,\n            includeMatches: includeMatches,\n            ignoreLocation: ignoreLocation\n          }),\n          isMatch = _search.isMatch,\n          score = _search.score,\n          indices = _search.indices;\n        if (isMatch) {\n          hasMatches = true;\n        }\n        totalScore += score;\n        if (isMatch && indices) {\n          allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));\n        }\n      });\n      var result = {\n        isMatch: hasMatches,\n        score: hasMatches ? totalScore / this.chunks.length : 1\n      };\n      if (hasMatches && includeMatches) {\n        result.indices = allIndices;\n      }\n      return result;\n    }\n  }]);\n  return BitapSearch;\n}();\n\nvar BaseMatch = /*#__PURE__*/function () {\n  function BaseMatch(pattern) {\n    _classCallCheck(this, BaseMatch);\n    this.pattern = pattern;\n  }\n  _createClass(BaseMatch, [{\n    key: \"search\",\n    value: function search( /*text*/) {}\n  }], [{\n    key: \"isMultiMatch\",\n    value: function isMultiMatch(pattern) {\n      return getMatch(pattern, this.multiRegex);\n    }\n  }, {\n    key: \"isSingleMatch\",\n    value: function isSingleMatch(pattern) {\n      return getMatch(pattern, this.singleRegex);\n    }\n  }]);\n  return BaseMatch;\n}();\nfunction getMatch(pattern, exp) {\n  var matches = pattern.match(exp);\n  return matches ? matches[1] : null;\n}\n\nvar ExactMatch = /*#__PURE__*/function (_BaseMatch) {\n  _inherits(ExactMatch, _BaseMatch);\n  var _super = _createSuper(ExactMatch);\n  function ExactMatch(pattern) {\n    _classCallCheck(this, ExactMatch);\n    return _super.call(this, pattern);\n  }\n  _createClass(ExactMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var isMatch = text === this.pattern;\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: [0, this.pattern.length - 1]\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'exact';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^=\"(.*)\"$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^=(.*)$/;\n    }\n  }]);\n  return ExactMatch;\n}(BaseMatch);\n\nvar InverseExactMatch = /*#__PURE__*/function (_BaseMatch) {\n  _inherits(InverseExactMatch, _BaseMatch);\n  var _super = _createSuper(InverseExactMatch);\n  function InverseExactMatch(pattern) {\n    _classCallCheck(this, InverseExactMatch);\n    return _super.call(this, pattern);\n  }\n  _createClass(InverseExactMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var index = text.indexOf(this.pattern);\n      var isMatch = index === -1;\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: [0, text.length - 1]\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'inverse-exact';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^!\"(.*)\"$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^!(.*)$/;\n    }\n  }]);\n  return InverseExactMatch;\n}(BaseMatch);\n\nvar PrefixExactMatch = /*#__PURE__*/function (_BaseMatch) {\n  _inherits(PrefixExactMatch, _BaseMatch);\n  var _super = _createSuper(PrefixExactMatch);\n  function PrefixExactMatch(pattern) {\n    _classCallCheck(this, PrefixExactMatch);\n    return _super.call(this, pattern);\n  }\n  _createClass(PrefixExactMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var isMatch = text.startsWith(this.pattern);\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: [0, this.pattern.length - 1]\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'prefix-exact';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^\\^\"(.*)\"$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^\\^(.*)$/;\n    }\n  }]);\n  return PrefixExactMatch;\n}(BaseMatch);\n\nvar InversePrefixExactMatch = /*#__PURE__*/function (_BaseMatch) {\n  _inherits(InversePrefixExactMatch, _BaseMatch);\n  var _super = _createSuper(InversePrefixExactMatch);\n  function InversePrefixExactMatch(pattern) {\n    _classCallCheck(this, InversePrefixExactMatch);\n    return _super.call(this, pattern);\n  }\n  _createClass(InversePrefixExactMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var isMatch = !text.startsWith(this.pattern);\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: [0, text.length - 1]\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'inverse-prefix-exact';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^!\\^\"(.*)\"$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^!\\^(.*)$/;\n    }\n  }]);\n  return InversePrefixExactMatch;\n}(BaseMatch);\n\nvar SuffixExactMatch = /*#__PURE__*/function (_BaseMatch) {\n  _inherits(SuffixExactMatch, _BaseMatch);\n  var _super = _createSuper(SuffixExactMatch);\n  function SuffixExactMatch(pattern) {\n    _classCallCheck(this, SuffixExactMatch);\n    return _super.call(this, pattern);\n  }\n  _createClass(SuffixExactMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var isMatch = text.endsWith(this.pattern);\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: [text.length - this.pattern.length, text.length - 1]\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'suffix-exact';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^\"(.*)\"\\$$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^(.*)\\$$/;\n    }\n  }]);\n  return SuffixExactMatch;\n}(BaseMatch);\n\nvar InverseSuffixExactMatch = /*#__PURE__*/function (_BaseMatch) {\n  _inherits(InverseSuffixExactMatch, _BaseMatch);\n  var _super = _createSuper(InverseSuffixExactMatch);\n  function InverseSuffixExactMatch(pattern) {\n    _classCallCheck(this, InverseSuffixExactMatch);\n    return _super.call(this, pattern);\n  }\n  _createClass(InverseSuffixExactMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var isMatch = !text.endsWith(this.pattern);\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: [0, text.length - 1]\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'inverse-suffix-exact';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^!\"(.*)\"\\$$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^!(.*)\\$$/;\n    }\n  }]);\n  return InverseSuffixExactMatch;\n}(BaseMatch);\n\nvar FuzzyMatch = /*#__PURE__*/function (_BaseMatch) {\n  _inherits(FuzzyMatch, _BaseMatch);\n  var _super = _createSuper(FuzzyMatch);\n  function FuzzyMatch(pattern) {\n    var _this;\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$location = _ref.location,\n      location = _ref$location === void 0 ? Config.location : _ref$location,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === void 0 ? Config.distance : _ref$distance,\n      _ref$includeMatches = _ref.includeMatches,\n      includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\n      _ref$findAllMatches = _ref.findAllMatches,\n      findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,\n      _ref$minMatchCharLeng = _ref.minMatchCharLength,\n      minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,\n      _ref$isCaseSensitive = _ref.isCaseSensitive,\n      isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,\n      _ref$ignoreLocation = _ref.ignoreLocation,\n      ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;\n    _classCallCheck(this, FuzzyMatch);\n    _this = _super.call(this, pattern);\n    _this._bitapSearch = new BitapSearch(pattern, {\n      location: location,\n      threshold: threshold,\n      distance: distance,\n      includeMatches: includeMatches,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength,\n      isCaseSensitive: isCaseSensitive,\n      ignoreLocation: ignoreLocation\n    });\n    return _this;\n  }\n  _createClass(FuzzyMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      return this._bitapSearch.searchIn(text);\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'fuzzy';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^\"(.*)\"$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^(.*)$/;\n    }\n  }]);\n  return FuzzyMatch;\n}(BaseMatch);\n\nvar IncludeMatch = /*#__PURE__*/function (_BaseMatch) {\n  _inherits(IncludeMatch, _BaseMatch);\n  var _super = _createSuper(IncludeMatch);\n  function IncludeMatch(pattern) {\n    _classCallCheck(this, IncludeMatch);\n    return _super.call(this, pattern);\n  }\n  _createClass(IncludeMatch, [{\n    key: \"search\",\n    value: function search(text) {\n      var location = 0;\n      var index;\n      var indices = [];\n      var patternLen = this.pattern.length;\n\n      // Get all exact matches\n      while ((index = text.indexOf(this.pattern, location)) > -1) {\n        location = index + patternLen;\n        indices.push([index, location - 1]);\n      }\n      var isMatch = !!indices.length;\n      return {\n        isMatch: isMatch,\n        score: isMatch ? 0 : 1,\n        indices: indices\n      };\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'include';\n    }\n  }, {\n    key: \"multiRegex\",\n    get: function get() {\n      return /^'\"(.*)\"$/;\n    }\n  }, {\n    key: \"singleRegex\",\n    get: function get() {\n      return /^'(.*)$/;\n    }\n  }]);\n  return IncludeMatch;\n}(BaseMatch);\n\n// Order is important. DO NOT CHANGE.\nvar searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];\nvar searchersLen = searchers.length;\n\n// Regex to split by spaces, but keep anything in quotes together\nvar SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nvar OR_TOKEN = '|';\n\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return pattern.split(OR_TOKEN).map(function (item) {\n    var query = item.trim().split(SPACE_RE).filter(function (item) {\n      return item && !!item.trim();\n    });\n    var results = [];\n    for (var i = 0, len = query.length; i < len; i += 1) {\n      var queryItem = query[i];\n\n      // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n      var found = false;\n      var idx = -1;\n      while (!found && ++idx < searchersLen) {\n        var searcher = searchers[idx];\n        var token = searcher.isMultiMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          found = true;\n        }\n      }\n      if (found) {\n        continue;\n      }\n\n      // 2. Handle single query matches (i.e, once that are *not* quoted)\n      idx = -1;\n      while (++idx < searchersLen) {\n        var _searcher = searchers[idx];\n        var _token = _searcher.isSingleMatch(queryItem);\n        if (_token) {\n          results.push(new _searcher(_token, options));\n          break;\n        }\n      }\n    }\n    return results;\n  });\n}\n\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nvar MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);\n\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */\nvar ExtendedSearch = /*#__PURE__*/function () {\n  function ExtendedSearch(pattern) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$isCaseSensitive = _ref.isCaseSensitive,\n      isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,\n      _ref$includeMatches = _ref.includeMatches,\n      includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\n      _ref$minMatchCharLeng = _ref.minMatchCharLength,\n      minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,\n      _ref$ignoreLocation = _ref.ignoreLocation,\n      ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation,\n      _ref$findAllMatches = _ref.findAllMatches,\n      findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,\n      _ref$location = _ref.location,\n      location = _ref$location === void 0 ? Config.location : _ref$location,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === void 0 ? Config.distance : _ref$distance;\n    _classCallCheck(this, ExtendedSearch);\n    this.query = null;\n    this.options = {\n      isCaseSensitive: isCaseSensitive,\n      includeMatches: includeMatches,\n      minMatchCharLength: minMatchCharLength,\n      findAllMatches: findAllMatches,\n      ignoreLocation: ignoreLocation,\n      location: location,\n      threshold: threshold,\n      distance: distance\n    };\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.query = parseQuery(this.pattern, this.options);\n  }\n  _createClass(ExtendedSearch, [{\n    key: \"searchIn\",\n    value: function searchIn(text) {\n      var query = this.query;\n      if (!query) {\n        return {\n          isMatch: false,\n          score: 1\n        };\n      }\n      var _this$options = this.options,\n        includeMatches = _this$options.includeMatches,\n        isCaseSensitive = _this$options.isCaseSensitive;\n      text = isCaseSensitive ? text : text.toLowerCase();\n      var numMatches = 0;\n      var allIndices = [];\n      var totalScore = 0;\n\n      // ORs\n      for (var i = 0, qLen = query.length; i < qLen; i += 1) {\n        var searchers = query[i];\n\n        // Reset indices\n        allIndices.length = 0;\n        numMatches = 0;\n\n        // ANDs\n        for (var j = 0, pLen = searchers.length; j < pLen; j += 1) {\n          var searcher = searchers[j];\n          var _searcher$search = searcher.search(text),\n            isMatch = _searcher$search.isMatch,\n            indices = _searcher$search.indices,\n            score = _searcher$search.score;\n          if (isMatch) {\n            numMatches += 1;\n            totalScore += score;\n            if (includeMatches) {\n              var type = searcher.constructor.type;\n              if (MultiMatchSet.has(type)) {\n                allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));\n              } else {\n                allIndices.push(indices);\n              }\n            }\n          } else {\n            totalScore = 0;\n            numMatches = 0;\n            allIndices.length = 0;\n            break;\n          }\n        }\n\n        // OR condition, so if TRUE, return\n        if (numMatches) {\n          var result = {\n            isMatch: true,\n            score: totalScore / numMatches\n          };\n          if (includeMatches) {\n            result.indices = allIndices;\n          }\n          return result;\n        }\n      }\n\n      // Nothing was matched\n      return {\n        isMatch: false,\n        score: 1\n      };\n    }\n  }], [{\n    key: \"condition\",\n    value: function condition(_, options) {\n      return options.useExtendedSearch;\n    }\n  }]);\n  return ExtendedSearch;\n}();\n\nvar registeredSearchers = [];\nfunction register() {\n  registeredSearchers.push.apply(registeredSearchers, arguments);\n}\nfunction createSearcher(pattern, options) {\n  for (var i = 0, len = registeredSearchers.length; i < len; i += 1) {\n    var searcherClass = registeredSearchers[i];\n    if (searcherClass.condition(pattern, options)) {\n      return new searcherClass(pattern, options);\n    }\n  }\n  return new BitapSearch(pattern, options);\n}\n\nvar LogicalOperator = {\n  AND: '$and',\n  OR: '$or'\n};\nvar KeyType = {\n  PATH: '$path',\n  PATTERN: '$val'\n};\nvar isExpression = function isExpression(query) {\n  return !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\n};\nvar isPath = function isPath(query) {\n  return !!query[KeyType.PATH];\n};\nvar isLeaf = function isLeaf(query) {\n  return !isArray(query) && isObject(query) && !isExpression(query);\n};\nvar convertToExplicit = function convertToExplicit(query) {\n  return _defineProperty({}, LogicalOperator.AND, Object.keys(query).map(function (key) {\n    return _defineProperty({}, key, query[key]);\n  }));\n};\n\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options) {\n  var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref3$auto = _ref3.auto,\n    auto = _ref3$auto === void 0 ? true : _ref3$auto;\n  var next = function next(query) {\n    var keys = Object.keys(query);\n    var isQueryPath = isPath(query);\n    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n      return next(convertToExplicit(query));\n    }\n    if (isLeaf(query)) {\n      var key = isQueryPath ? query[KeyType.PATH] : keys[0];\n      var pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n      if (!isString(pattern)) {\n        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));\n      }\n      var obj = {\n        keyId: createKeyId(key),\n        pattern: pattern\n      };\n      if (auto) {\n        obj.searcher = createSearcher(pattern, options);\n      }\n      return obj;\n    }\n    var node = {\n      children: [],\n      operator: keys[0]\n    };\n    keys.forEach(function (key) {\n      var value = query[key];\n      if (isArray(value)) {\n        value.forEach(function (item) {\n          node.children.push(next(item));\n        });\n      }\n    });\n    return node;\n  };\n  if (!isExpression(query)) {\n    query = convertToExplicit(query);\n  }\n  return next(query);\n}\n\n// Practical scoring function\nfunction computeScore(results, _ref) {\n  var _ref$ignoreFieldNorm = _ref.ignoreFieldNorm,\n    ignoreFieldNorm = _ref$ignoreFieldNorm === void 0 ? Config.ignoreFieldNorm : _ref$ignoreFieldNorm;\n  results.forEach(function (result) {\n    var totalScore = 1;\n    result.matches.forEach(function (_ref2) {\n      var key = _ref2.key,\n        norm = _ref2.norm,\n        score = _ref2.score;\n      var weight = key ? key.weight : null;\n      totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));\n    });\n    result.score = totalScore;\n  });\n}\n\nfunction transformMatches(result, data) {\n  var matches = result.matches;\n  data.matches = [];\n  if (!isDefined(matches)) {\n    return;\n  }\n  matches.forEach(function (match) {\n    if (!isDefined(match.indices) || !match.indices.length) {\n      return;\n    }\n    var indices = match.indices,\n      value = match.value;\n    var obj = {\n      indices: indices,\n      value: value\n    };\n    if (match.key) {\n      obj.key = match.key.src;\n    }\n    if (match.idx > -1) {\n      obj.refIndex = match.idx;\n    }\n    data.matches.push(obj);\n  });\n}\n\nfunction transformScore(result, data) {\n  data.score = result.score;\n}\n\nfunction format(results, docs) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref$includeMatches = _ref.includeMatches,\n    includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\n    _ref$includeScore = _ref.includeScore,\n    includeScore = _ref$includeScore === void 0 ? Config.includeScore : _ref$includeScore;\n  var transformers = [];\n  if (includeMatches) transformers.push(transformMatches);\n  if (includeScore) transformers.push(transformScore);\n  return results.map(function (result) {\n    var idx = result.idx;\n    var data = {\n      item: docs[idx],\n      refIndex: idx\n    };\n    if (transformers.length) {\n      transformers.forEach(function (transformer) {\n        transformer(result, data);\n      });\n    }\n    return data;\n  });\n}\n\nvar Fuse$1 = /*#__PURE__*/function () {\n  function Fuse(docs) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var index = arguments.length > 2 ? arguments[2] : undefined;\n    _classCallCheck(this, Fuse);\n    this.options = _objectSpread2(_objectSpread2({}, Config), options);\n    if (this.options.useExtendedSearch && !true) {}\n    this._keyStore = new KeyStore(this.options.keys);\n    this.setCollection(docs, index);\n  }\n  _createClass(Fuse, [{\n    key: \"setCollection\",\n    value: function setCollection(docs, index) {\n      this._docs = docs;\n      if (index && !(index instanceof FuseIndex)) {\n        throw new Error(INCORRECT_INDEX_TYPE);\n      }\n      this._myIndex = index || createIndex(this.options.keys, this._docs, {\n        getFn: this.options.getFn,\n        fieldNormWeight: this.options.fieldNormWeight\n      });\n    }\n  }, {\n    key: \"add\",\n    value: function add(doc) {\n      if (!isDefined(doc)) {\n        return;\n      }\n      this._docs.push(doc);\n      this._myIndex.add(doc);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function /* doc, idx */ () {\n        return false;\n      };\n      var results = [];\n      for (var i = 0, len = this._docs.length; i < len; i += 1) {\n        var doc = this._docs[i];\n        if (predicate(doc, i)) {\n          this.removeAt(i);\n          i -= 1;\n          len -= 1;\n          results.push(doc);\n        }\n      }\n      return results;\n    }\n  }, {\n    key: \"removeAt\",\n    value: function removeAt(idx) {\n      this._docs.splice(idx, 1);\n      this._myIndex.removeAt(idx);\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex() {\n      return this._myIndex;\n    }\n  }, {\n    key: \"search\",\n    value: function search(query) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$limit = _ref.limit,\n        limit = _ref$limit === void 0 ? -1 : _ref$limit;\n      var _this$options = this.options,\n        includeMatches = _this$options.includeMatches,\n        includeScore = _this$options.includeScore,\n        shouldSort = _this$options.shouldSort,\n        sortFn = _this$options.sortFn,\n        ignoreFieldNorm = _this$options.ignoreFieldNorm;\n      var results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);\n      computeScore(results, {\n        ignoreFieldNorm: ignoreFieldNorm\n      });\n      if (shouldSort) {\n        results.sort(sortFn);\n      }\n      if (isNumber(limit) && limit > -1) {\n        results = results.slice(0, limit);\n      }\n      return format(results, this._docs, {\n        includeMatches: includeMatches,\n        includeScore: includeScore\n      });\n    }\n  }, {\n    key: \"_searchStringList\",\n    value: function _searchStringList(query) {\n      var searcher = createSearcher(query, this.options);\n      var records = this._myIndex.records;\n      var results = [];\n\n      // Iterate over every string in the index\n      records.forEach(function (_ref2) {\n        var text = _ref2.v,\n          idx = _ref2.i,\n          norm = _ref2.n;\n        if (!isDefined(text)) {\n          return;\n        }\n        var _searcher$searchIn = searcher.searchIn(text),\n          isMatch = _searcher$searchIn.isMatch,\n          score = _searcher$searchIn.score,\n          indices = _searcher$searchIn.indices;\n        if (isMatch) {\n          results.push({\n            item: text,\n            idx: idx,\n            matches: [{\n              score: score,\n              value: text,\n              norm: norm,\n              indices: indices\n            }]\n          });\n        }\n      });\n      return results;\n    }\n  }, {\n    key: \"_searchLogical\",\n    value: function _searchLogical(query) {\n      var _this = this;\n      var expression = parse(query, this.options);\n      var evaluate = function evaluate(node, item, idx) {\n        if (!node.children) {\n          var keyId = node.keyId,\n            searcher = node.searcher;\n          var matches = _this._findMatches({\n            key: _this._keyStore.get(keyId),\n            value: _this._myIndex.getValueForItemAtKeyId(item, keyId),\n            searcher: searcher\n          });\n          if (matches && matches.length) {\n            return [{\n              idx: idx,\n              item: item,\n              matches: matches\n            }];\n          }\n          return [];\n        }\n        var res = [];\n        for (var i = 0, len = node.children.length; i < len; i += 1) {\n          var child = node.children[i];\n          var result = evaluate(child, item, idx);\n          if (result.length) {\n            res.push.apply(res, _toConsumableArray(result));\n          } else if (node.operator === LogicalOperator.AND) {\n            return [];\n          }\n        }\n        return res;\n      };\n      var records = this._myIndex.records;\n      var resultMap = {};\n      var results = [];\n      records.forEach(function (_ref3) {\n        var item = _ref3.$,\n          idx = _ref3.i;\n        if (isDefined(item)) {\n          var expResults = evaluate(expression, item, idx);\n          if (expResults.length) {\n            // Dedupe when adding\n            if (!resultMap[idx]) {\n              resultMap[idx] = {\n                idx: idx,\n                item: item,\n                matches: []\n              };\n              results.push(resultMap[idx]);\n            }\n            expResults.forEach(function (_ref4) {\n              var _resultMap$idx$matche;\n              var matches = _ref4.matches;\n              (_resultMap$idx$matche = resultMap[idx].matches).push.apply(_resultMap$idx$matche, _toConsumableArray(matches));\n            });\n          }\n        }\n      });\n      return results;\n    }\n  }, {\n    key: \"_searchObjectList\",\n    value: function _searchObjectList(query) {\n      var _this2 = this;\n      var searcher = createSearcher(query, this.options);\n      var _this$_myIndex = this._myIndex,\n        keys = _this$_myIndex.keys,\n        records = _this$_myIndex.records;\n      var results = [];\n\n      // List is Array<Object>\n      records.forEach(function (_ref5) {\n        var item = _ref5.$,\n          idx = _ref5.i;\n        if (!isDefined(item)) {\n          return;\n        }\n        var matches = [];\n\n        // Iterate over every key (i.e, path), and fetch the value at that key\n        keys.forEach(function (key, keyIndex) {\n          matches.push.apply(matches, _toConsumableArray(_this2._findMatches({\n            key: key,\n            value: item[keyIndex],\n            searcher: searcher\n          })));\n        });\n        if (matches.length) {\n          results.push({\n            idx: idx,\n            item: item,\n            matches: matches\n          });\n        }\n      });\n      return results;\n    }\n  }, {\n    key: \"_findMatches\",\n    value: function _findMatches(_ref6) {\n      var key = _ref6.key,\n        value = _ref6.value,\n        searcher = _ref6.searcher;\n      if (!isDefined(value)) {\n        return [];\n      }\n      var matches = [];\n      if (isArray(value)) {\n        value.forEach(function (_ref7) {\n          var text = _ref7.v,\n            idx = _ref7.i,\n            norm = _ref7.n;\n          if (!isDefined(text)) {\n            return;\n          }\n          var _searcher$searchIn2 = searcher.searchIn(text),\n            isMatch = _searcher$searchIn2.isMatch,\n            score = _searcher$searchIn2.score,\n            indices = _searcher$searchIn2.indices;\n          if (isMatch) {\n            matches.push({\n              score: score,\n              key: key,\n              value: text,\n              idx: idx,\n              norm: norm,\n              indices: indices\n            });\n          }\n        });\n      } else {\n        var text = value.v,\n          norm = value.n;\n        var _searcher$searchIn3 = searcher.searchIn(text),\n          isMatch = _searcher$searchIn3.isMatch,\n          score = _searcher$searchIn3.score,\n          indices = _searcher$searchIn3.indices;\n        if (isMatch) {\n          matches.push({\n            score: score,\n            key: key,\n            value: text,\n            norm: norm,\n            indices: indices\n          });\n        }\n      }\n      return matches;\n    }\n  }]);\n  return Fuse;\n}();\n\nFuse$1.version = '7.0.0';\nFuse$1.createIndex = createIndex;\nFuse$1.parseIndex = parseIndex;\nFuse$1.config = Config;\n{\n  Fuse$1.parseQuery = parse;\n}\n{\n  register(ExtendedSearch);\n}\nvar Fuse = Fuse$1;\n\nmodule.exports = Fuse;\n\n\n//# sourceURL=webpack://hanfor/./node_modules/fuse.js/dist/fuse.cjs?");

/***/ }),

/***/ "./node_modules/textarea-caret/index.js":
/*!**********************************************!*\
  !*** ./node_modules/textarea-caret/index.js ***!
  \**********************************************/
/***/ ((module) => {

eval("/* jshint browser: true */\n\n(function () {\n\n// We'll copy the properties below into the mirror div.\n// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\nvar properties = [\n  'direction',  // RTL support\n  'boxSizing',\n  'width',  // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n  'height',\n  'overflowX',\n  'overflowY',  // copy the scrollbar for IE\n\n  'borderTopWidth',\n  'borderRightWidth',\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderStyle',\n\n  'paddingTop',\n  'paddingRight',\n  'paddingBottom',\n  'paddingLeft',\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  'fontStyle',\n  'fontVariant',\n  'fontWeight',\n  'fontStretch',\n  'fontSize',\n  'fontSizeAdjust',\n  'lineHeight',\n  'fontFamily',\n\n  'textAlign',\n  'textTransform',\n  'textIndent',\n  'textDecoration',  // might not make a difference, but better be safe\n\n  'letterSpacing',\n  'wordSpacing',\n\n  'tabSize',\n  'MozTabSize'\n\n];\n\nvar isBrowser = (typeof window !== 'undefined');\nvar isFirefox = (isBrowser && window.mozInnerScreenX != null);\n\nfunction getCaretCoordinates(element, position, options) {\n  if (!isBrowser) {\n    throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');\n  }\n\n  var debug = options && options.debug || false;\n  if (debug) {\n    var el = document.querySelector('#input-textarea-caret-position-mirror-div');\n    if (el) el.parentNode.removeChild(el);\n  }\n\n  // The mirror div will replicate the textarea's style\n  var div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n\n  var style = div.style;\n  var computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle;  // currentStyle for IE < 9\n  var isInput = element.nodeName === 'INPUT';\n\n  // Default textarea styles\n  style.whiteSpace = 'pre-wrap';\n  if (!isInput)\n    style.wordWrap = 'break-word';  // only for textarea-s\n\n  // Position off-screen\n  style.position = 'absolute';  // required to return coordinates properly\n  if (!debug)\n    style.visibility = 'hidden';  // not 'display: none' because we want rendering\n\n  // Transfer the element's properties to the div\n  properties.forEach(function (prop) {\n    if (isInput && prop === 'lineHeight') {\n      // Special case for <input>s because text is rendered centered and line height may be != height\n      style.lineHeight = computed.height;\n    } else {\n      style[prop] = computed[prop];\n    }\n  });\n\n  if (isFirefox) {\n    // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n    if (element.scrollHeight > parseInt(computed.height))\n      style.overflowY = 'scroll';\n  } else {\n    style.overflow = 'hidden';  // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n  }\n\n  div.textContent = element.value.substring(0, position);\n  // The second special handling for input type=\"text\" vs textarea:\n  // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n  if (isInput)\n    div.textContent = div.textContent.replace(/\\s/g, '\\u00a0');\n\n  var span = document.createElement('span');\n  // Wrapping must be replicated *exactly*, including when a long word gets\n  // onto the next line, with whitespace at the end of the line before (#7).\n  // The  *only* reliable way to do that is to copy the *entire* rest of the\n  // textarea's content into the <span> created at the caret position.\n  // For inputs, just '.' would be enough, but no need to bother.\n  span.textContent = element.value.substring(position) || '.';  // || because a completely empty faux span doesn't render at all\n  div.appendChild(span);\n\n  var coordinates = {\n    top: span.offsetTop + parseInt(computed['borderTopWidth']),\n    left: span.offsetLeft + parseInt(computed['borderLeftWidth']),\n    height: parseInt(computed['lineHeight'])\n  };\n\n  if (debug) {\n    span.style.backgroundColor = '#aaa';\n  } else {\n    document.body.removeChild(div);\n  }\n\n  return coordinates;\n}\n\nif ( true && typeof module.exports != 'undefined') {\n  module.exports = getCaretCoordinates;\n} else if(isBrowser) {\n  window.getCaretCoordinates = getCaretCoordinates;\n}\n\n}());\n\n\n//# sourceURL=webpack://hanfor/./node_modules/textarea-caret/index.js?");

/***/ }),

/***/ "./node_modules/undate/dist/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/undate/dist/index.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   update: () => (/* binding */ update),\n/* harmony export */   wrapCursor: () => (/* binding */ wrapCursor)\n/* harmony export */ });\nfunction update(el, headToCursor, cursorToTail) {\r\n    const curr = el.value; // strA + strB1 + strC\r\n    const next = headToCursor + (cursorToTail || \"\"); // strA + strB2 + strC\r\n    const activeElement = document.activeElement;\r\n    //  Calculate length of strA and strC\r\n    let aLength = 0;\r\n    let cLength = 0;\r\n    while (aLength < curr.length && aLength < next.length && curr[aLength] === next[aLength]) {\r\n        aLength++;\r\n    }\r\n    while (curr.length - cLength - 1 >= 0 &&\r\n        next.length - cLength - 1 >= 0 &&\r\n        curr[curr.length - cLength - 1] === next[next.length - cLength - 1]) {\r\n        cLength++;\r\n    }\r\n    aLength = Math.min(aLength, Math.min(curr.length, next.length) - cLength);\r\n    // Select strB1\r\n    el.setSelectionRange(aLength, curr.length - cLength);\r\n    // Get strB2\r\n    const strB2 = next.substring(aLength, next.length - cLength);\r\n    // Replace strB1 with strB2\r\n    el.focus();\r\n    if (!document.execCommand(\"insertText\", false, strB2)) {\r\n        // Document.execCommand returns false if the command is not supported.\r\n        // Firefox and IE returns false in this case.\r\n        el.value = next;\r\n        // Dispatch input event. Note that `new Event(\"input\")` throws an error on IE11\r\n        const event = document.createEvent(\"Event\");\r\n        event.initEvent(\"input\", true, true);\r\n        el.dispatchEvent(event);\r\n    }\r\n    // Move cursor to the end of headToCursor\r\n    el.setSelectionRange(headToCursor.length, headToCursor.length);\r\n    activeElement.focus();\r\n    return el;\r\n}\n\nfunction wrapCursor(el, before, after) {\r\n    const initEnd = el.selectionEnd;\r\n    const headToCursor = el.value.substr(0, el.selectionStart) + before;\r\n    const cursorToTail = el.value.substring(el.selectionStart, initEnd) + (after || \"\") + el.value.substr(initEnd);\r\n    update(el, headToCursor, cursorToTail);\r\n    el.selectionEnd = initEnd + before.length;\r\n    return el;\r\n}\n\n\n//# sourceMappingURL=index.mjs.map\n\n\n//# sourceURL=webpack://hanfor/./node_modules/undate/dist/index.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"requirements": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkhanfor"] = self["webpackChunkhanfor"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["commons"], () => (__webpack_require__("./js/requirements.js")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;