{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the Hanfor documentation page.","title":"Home"},{"location":"contribute/to_docs.html","text":"These are the source files for the Hanfor Documentation . Contribute to this Documentation. # 0. (Optional) setup a virtual environment # $ cd hanfor/documentation $ python3 -m venv docs_venv $ source docs_venv/bin/activate 1. Install MkDocs and all dependencies. # $ pip3 install -r requirements_docs.txt 2. Serve this Documentation locally to track your changes. # $ cd to_here $ mkdocs serve Open your Browser at http://127.0.0.1:8000/ . 3. Publish your changes to the staging directory. # $ mkdocs gh-deploy --remote-branch gh-pages-staging This will build the Documentation and commit them to the gh-pages-staging branch and push the gh-pages-staging branch to GitHub. If you have the necessary rights, you can then see the results on https://struebli.informatik.uni-freiburg.de/hanfor-docs-staging. 4. Publish your changes to the live directory # $ mkdocs gh-deploy This will build the Documentation and commit them to the gh-pages branch and push the gh-pages branch to GitHub. They will then be immediately available to the world at https://ultimate-pa.github.io/hanfor.","title":"To docs"},{"location":"contribute/to_docs.html#contribute-to-this-documentation","text":"","title":"Contribute to this Documentation."},{"location":"contribute/to_docs.html#0-optional-setup-a-virtual-environment","text":"$ cd hanfor/documentation $ python3 -m venv docs_venv $ source docs_venv/bin/activate","title":"0. (Optional) setup a virtual environment"},{"location":"contribute/to_docs.html#1-install-mkdocs-and-all-dependencies","text":"$ pip3 install -r requirements_docs.txt","title":"1. Install MkDocs and all dependencies."},{"location":"contribute/to_docs.html#2-serve-this-documentation-locally-to-track-your-changes","text":"$ cd to_here $ mkdocs serve Open your Browser at http://127.0.0.1:8000/ .","title":"2. Serve this Documentation locally to track your changes."},{"location":"contribute/to_docs.html#3-publish-your-changes-to-the-staging-directory","text":"$ mkdocs gh-deploy --remote-branch gh-pages-staging This will build the Documentation and commit them to the gh-pages-staging branch and push the gh-pages-staging branch to GitHub. If you have the necessary rights, you can then see the results on https://struebli.informatik.uni-freiburg.de/hanfor-docs-staging.","title":"3. Publish your changes to the staging directory."},{"location":"contribute/to_docs.html#4-publish-your-changes-to-the-live-directory","text":"$ mkdocs gh-deploy This will build the Documentation and commit them to the gh-pages branch and push the gh-pages branch to GitHub. They will then be immediately available to the world at https://ultimate-pa.github.io/hanfor.","title":"4. Publish your changes to the live directory"},{"location":"contribute/to_hanfor.html","text":"Hanfor # You know the drill, head over to Hanfor's Git repository and fork it, then work in your changes and PR.","title":"Hanfor"},{"location":"contribute/to_hanfor.html#hanfor","text":"You know the drill, head over to Hanfor's Git repository and fork it, then work in your changes and PR.","title":"Hanfor"},{"location":"installation/configuration.html","text":"Configuration # Hanfor # Copy ./hanfor/config.dist.py to ./hanfor/config.py . Edit the file /hanfor/config.py according your needs. Hanfor config file: # A config file looks as follows: ################################################################################ # Storage and folders # ################################################################################ # Set the SESSION_BASE_FOLDER to a path hanfor will store/load sessions. # If set to None, hanfor will store its sessions in ./data SESSION_BASE_FOLDER = './data' ################################################################################ # DEBUG and logging # ################################################################################ # Set DEBUG_MODE to true if you want to run the flask app in debug mode. # In Production this should be set to False. DEBUG_MODE = False # If ASSETS_DEBUG True, Bundles will output their individual source files. # This will significantly slow down performance. ASSETS_DEBUG = False # Set this to false if you want to use DEBUG toolbar with a URL_PREFIX DEBUG_TB_INTERCEPT_REDIRECTS = False # Set the log level to increase or decrease the logging sensitivity. # You can set LOG_LEVEL (in decreasing sensitivity to): # 'DEBUG', 'INFO', 'WARNING', 'ERROR' LOG_LEVEL = 'DEBUG' # Set LOG_TO_FILE to True if vou want to log to the file # you specified in LOG_FILE LOG_TO_FILE = True LOG_FILE = 'hanfor.log' # Set PYCHARM_DEBUG to True to supresss the flask debugging so it # won't interfere with the pycharm debugger. PYCHARM_DEBUG = False ################################################################################ # App and web server section # ################################################################################ # If you are running the app with a url prefix set URL_PREFIX like # URL_PREFIX = '/hanfor' URL_PREFIX = '' # set a 'SECRET_KEY' to enable the Flask session cookies SECRET_KEY = 'somesecretkeythatisonlyknowntoyou' # Specify the PORT the app should be running at PORT = 5000 # Set the host HOST = '127.0.0.1' ReqAnalyzer # Coming soon","title":"Configuration"},{"location":"installation/configuration.html#configuration","text":"","title":"Configuration"},{"location":"installation/configuration.html#hanfor","text":"Copy ./hanfor/config.dist.py to ./hanfor/config.py . Edit the file /hanfor/config.py according your needs.","title":"Hanfor"},{"location":"installation/configuration.html#hanfor-config-file","text":"A config file looks as follows: ################################################################################ # Storage and folders # ################################################################################ # Set the SESSION_BASE_FOLDER to a path hanfor will store/load sessions. # If set to None, hanfor will store its sessions in ./data SESSION_BASE_FOLDER = './data' ################################################################################ # DEBUG and logging # ################################################################################ # Set DEBUG_MODE to true if you want to run the flask app in debug mode. # In Production this should be set to False. DEBUG_MODE = False # If ASSETS_DEBUG True, Bundles will output their individual source files. # This will significantly slow down performance. ASSETS_DEBUG = False # Set this to false if you want to use DEBUG toolbar with a URL_PREFIX DEBUG_TB_INTERCEPT_REDIRECTS = False # Set the log level to increase or decrease the logging sensitivity. # You can set LOG_LEVEL (in decreasing sensitivity to): # 'DEBUG', 'INFO', 'WARNING', 'ERROR' LOG_LEVEL = 'DEBUG' # Set LOG_TO_FILE to True if vou want to log to the file # you specified in LOG_FILE LOG_TO_FILE = True LOG_FILE = 'hanfor.log' # Set PYCHARM_DEBUG to True to supresss the flask debugging so it # won't interfere with the pycharm debugger. PYCHARM_DEBUG = False ################################################################################ # App and web server section # ################################################################################ # If you are running the app with a url prefix set URL_PREFIX like # URL_PREFIX = '/hanfor' URL_PREFIX = '' # set a 'SECRET_KEY' to enable the Flask session cookies SECRET_KEY = 'somesecretkeythatisonlyknowntoyou' # Specify the PORT the app should be running at PORT = 5000 # Set the host HOST = '127.0.0.1'","title":"Hanfor config file:"},{"location":"installation/configuration.html#reqanalyzer","text":"Coming soon","title":"ReqAnalyzer"},{"location":"installation/deployment.html","text":"Deployment # To start a fresh session use $ python app.py <tag> -c <path_to_input_csv>.csv Point your browser to http://127.0.0.1:<port in config.py> If you want to start an existing session, use $ python app.py <tag> You can see all available tags using the ''-L'' switch: $ python app.py -L How it works # The app will create a session naming it by the given <tag> argument. A session creation process has the following steps: Create a session in a folder config.py_SESSION_BASE_FOLDER/<tag> . Read the given .csv file containing one requirement each row. Ask the user about a mapping of the csv-header-names for: \"ID\", \"Description\", \"Formalized Requirement\", \"Type\" Create a Hanfor-Requirement for each row in the csv and store it to the session folder. Provide the Web-interface on the port specified in config.py","title":"Deployment"},{"location":"installation/deployment.html#deployment","text":"To start a fresh session use $ python app.py <tag> -c <path_to_input_csv>.csv Point your browser to http://127.0.0.1:<port in config.py> If you want to start an existing session, use $ python app.py <tag> You can see all available tags using the ''-L'' switch: $ python app.py -L","title":"Deployment"},{"location":"installation/deployment.html#how-it-works","text":"The app will create a session naming it by the given <tag> argument. A session creation process has the following steps: Create a session in a folder config.py_SESSION_BASE_FOLDER/<tag> . Read the given .csv file containing one requirement each row. Ask the user about a mapping of the csv-header-names for: \"ID\", \"Description\", \"Formalized Requirement\", \"Type\" Create a Hanfor-Requirement for each row in the csv and store it to the session folder. Provide the Web-interface on the port specified in config.py","title":"How it works"},{"location":"installation/preliminaries.html","text":"Preliminaries # Install Hanfor # Clone the repository: $ git clone https://github.com/ultimate-pa/hanfor.git -b master --single-branch /your/hanfor/destination Hanfor requires Python and is only tested with Python 3.6.x. You can check if you have python already installed from the command line: $ python -- version Python 3.6.2 We recommend using a virtual environment . Create a new virtual environment with: $ virtualenv hanfor_python And activate it by sourcing: $ source hanfor_python/bin/activate Now the python dependencies needed to be installed into the virtual environment. Inside the repository run: $ pip install -r requirements.txt Install ReqAnalyzer # Coming soon","title":"Preliminaries"},{"location":"installation/preliminaries.html#preliminaries","text":"","title":"Preliminaries"},{"location":"installation/preliminaries.html#install-hanfor","text":"Clone the repository: $ git clone https://github.com/ultimate-pa/hanfor.git -b master --single-branch /your/hanfor/destination Hanfor requires Python and is only tested with Python 3.6.x. You can check if you have python already installed from the command line: $ python -- version Python 3.6.2 We recommend using a virtual environment . Create a new virtual environment with: $ virtualenv hanfor_python And activate it by sourcing: $ source hanfor_python/bin/activate Now the python dependencies needed to be installed into the virtual environment. Inside the repository run: $ pip install -r requirements.txt","title":"Install Hanfor"},{"location":"installation/preliminaries.html#install-reqanalyzer","text":"Coming soon","title":"Install ReqAnalyzer"},{"location":"introduction/index.html","text":"What is Hanfor? # Hanfor is a tool that h elps an alyzing and fo rmalizing r equirements. The specification of requirements is a critical activity in software and system development. A defect in a requirement specification can result in a situation where a software or system is delivered that fullfills the given requirements, but does not satisfy the customer's needs due to erroneous requirments. Requirement analysis, as a human activity, is error-prone. Especially for large sets of requirements, it is difficult and time consuming to manually check whether a given property is satisfied or not. Requirement based testing is helpful to increase the efficiency during development. Obtaining a high test coverage on requirements often takes a long time. As the number of requirements increases over the releases, the test specifications have to cover more and more requirements. Hanfor is developed to ease the process of requirement analysis. Its method consists of three major steps to discover requirement defects and obtain test specifications based on a set of informal requirements (Figure 1): Requirement Formalization Requirement Check Test Generation Figure 1: The Hanfor tool discovers requirement defects and derives test specifications from a given set of informal requirements. Requirement Formalization # To make it possible for a computer to check a set of requirements for a given criteria, it has to \"understand\" the semantics of the requirements. This could be achieved by using formal languages, which usually share the fact that they are rarely understandable for humans. In this method we make use of a simple pattern language. The language is based on a restricted English grammar and hence looks like natural language. Requirements formalized in this specification language can automatically be translated into logics. Specification language # The grammar of the specification language is given below. A requirement is defined by an ID, a scope and a pattern. Scope and pattern are parameterised by expressions over system observables and durations. Some patterns require a more detailed description concerning the order or the realtime occurence of events. REQ ::= ID: SCOPE, PATTERN . SCOPE ::= Globally | Before EXPR | After EXPR | Between EXPR and EXPR | After EXPR until EXPR PATTERN ::= It is never the case that EXPR holds | It is always the case that EXPR holds | It is always the case that if EXPR holds, then EXPR holds as well | Transition to states in which EXPR holds occur at most twice | It is always the case that ORDER | It is always the case that REALTIME ORDER ::= | If EXPR holds, then EXPR previously held | If EXPR holds and is succeded by EXPR, then EXPR previously held | If EXPR holds, then EXPR previously held and was preceeded by EXPR | If EXPR holds, then EXPR eventually holds and is succeeded by EXPR | If EXPR holds and is succeeded by EXPR, then EXPR eventually holds after EXPR | If EXPR holds, then EXPR eventually holds and is succeeded by EXPR where EXPR does not hold between EXPR and EXPR | If EXPR holds, then EXPR toggles EXPR REALTIME ::= Once EXPR becomes satisfied, it holds for at least DURATION | Once EXPR becomes satisfied, it holds for less than DURATION | EXPR holds at least every DURATION | If EXPR holds, then EXPR holds after at most DURATION | If EXPR holds for at least DURATION, then EXPR holds afterwards for at least DURATION | If EXPR holds for at least DURATION, then EXPR holds afterwards | If EXPR holds, then EXPR holds after at most DURATION for at least DURATION | If EXPR holds, then EXPR holds for at least DURATION | If EXPR holds, then there is at least one execution sequence such that EXPR holds after at most DURATION | After EXPR holds for DURATION, then EXPR holds | If EXPR holds, then EXPR toggles EXPR at most DURATION later Figure 2 shows the toolchain for the translation of an informal requirement into a formalized version. In the first step, the informal requirement, given in natural language, is translated into the specification language. This process is done manually. The requirement expressed in the specification language is then automatically translated into a formula in realtime logic (the Duration Calculus). Figure 2: A specification language for real-time requirements is used as an intermediate step in the translation from informal to formalized requirements. Requirement Check # The Hanfor tool chain checks requirements for the following three correctness properties: Consistency Realtime-consistency Vacuity Consistency # A set of requirements is inconsistent, if there exists no system satisfying all requirements in the set. Consider the two requirements in the specification language given below. This set of requirements is obviously not consistent as there is no interpretation where the observable 'A' evaluates both to true and to false at each point in time. Example 1: Inconsistent requirements Req1: Globally, it is never the case that 'A' holds. Req2: Globally, it is always the case that 'A' holds. Inconsistency in a set of requirements can be resolved by erasing or changing requirements. Realtime-consistency (rt-consistency) # A set of requirements is rt-inconsistent, if there are conflicts between requirements that arise after a certain time. Example 2: Rt-inconsistent requirements Req3: Globally, it is always the case that if 'B' holds then 'C' holds after at most '5' time units. Req4: Globally, it is always the case that if 'A' holds then '!C' holds for at least '2' time units. Consider the two real-time requirements given above. The set of the two requirements is consistent. Figure 3 gives an example of an interpretation of 'A', 'B', and 'C' (in form of a timing diagram) that satisfies both requirments. Figure 3: Consistency of the set of requirements {Req3, Req4}. 'A' and 'B' occur at the same point in time for one time unit, then '!C' for two time units satisfies Req4, and 'C' occurring at time 5 satisfies Req3. However, there are assignments for which the requirements are in conflict, as depicted in the example trace (Figure 4). If 'A' and 'B'change values as shown in the figure, than at time 5, Req4 would only be satisfied if 'C' remained false while Req3 would only be satisfied if 'C' changed to true . Figure 4: Witness for the rt-inconsistency of the set of requirements {Req3, Req4}. From time 4 on, the system steers toward inevitable rt-inconsistency. There are several possibilities to resolve the rt-inconsistency in a set of requirements, e.g. by erasing, changing or adding requirements. Example 2 (Cont.): Resolving rt-inconsistency Erasing requirements e.g. Erase Req4 Changing requirements e.g. Make Req4 less restrictive: Req4': Globally, it is always the case that if 'A' holds and 'B' did not hold in the last 5 time units, then '!C' holds for at least '2' time units. Adding requirements e.g. Add the following requirement: Req5: Globally, it is always the case that if 'B' holds, '!A' holds for at least 5 time units. Vacuity # A set of requirements is vacuous, if the behaviour specified by the requirements cannot be triggered in a system satisfying all requirements. More intuitively spoken, a vacuous requirement can be imagined as dead code in an implementation: Both a vacouous requirement as well as dead code can be removed without changing the meaning of the remaining part. Consider again the requirements Req1 and Req4 given below. The set of requirements is consistent. However, the precondition of Req4 is never true as this would violate Req1. Req4 is therefore vacuously satisfied in this set of requirements. Example 3: Vacuous requirements Req1: Globally, it is never the case that 'A' holds. Req4: Globally, it is always the case that if 'A' holds then '!C' holds for at least '2' time units. There are several possibilities to resolve vacuity in a set of requirements. Example 3 (cont.): Resolving vacuity Erasing requirements e.g. Erase Req1 Changing requirements e.g. Make Req1 less restrictive: Req2': Before \"Startup\", it is never the case that 'A'holds. Test Generation # Formalized requirements can be used to automatically generate test specifications. An automatic test generation helps to reduce the time needed to write test specifications with a high coverage rate. The efficiency during development can be increased and the maintainability costs can be reduced. Algorithm # Testing requires information about observability. The system variables are therefore categorized into input, output, and hidden (i.e. internal) variables. A sequence of inputs deterministically causes the valuation of the output variable. Figure 5 shows an abstract view of a two-input system with the variables A , B and C . Figure 5: System S with input variables A , B , and output variable C . The test generation algorithm automatically generates system tests that are based only on the formalized requirements (i.e. do not depend on an additional system model). It generates at least one test case per output variable, but as most as many test cases such that every requirement is tested. Each generated test indicates the requirements that it is based on. It is ensured that the generated tests may not lead to false positives (i.e. the test case fails, although the system state is conform with the requirements). In case that there exist untestable requirements, the algorithm lists the set of untestable requirements. Test Cases # The test cases generated by Hanfor contain three sorts of information: A sequence of n inputs: The initial state of the system, as well as the inputs for steps 1 to n . The expected outcome: The expected valuation of the tested output variable. The indication on which requirements the test is based on. Consider the set of requirements given below. The variables A , B are considered to be inputs of the system (Figure 5), H and I are hidden variables, and C represents the output of the system. Example 4: Requirements to be tested Req1: Globally, it is always the case that if \u2018A\u2019 holds then \u2018H\u2019 holds after at most \u201810\u2019 time units. Req2: Globally, it is always the case that if \u2018B\u2019 holds then \u2018I\u2019 holds after at most \u201810\u2019 time units. Req3: Globally, it is always the case that if \u2018H AND I\u2019 holds then \u2018C\u2019 holds after at most \u201810\u2019 time units. The test generation tool outputs the following test case: Case SystemTest: TestGeneratorResult: Found Test for: [C] Test Vector: Set inputs: A := true, B := true Wait for at most 20 for: C == true, (req3) The given test case tests the output variable C based on the third requirement. The input sequence is specified by an initial state only, in which both input variables A and B are set to true . The output variable C is expected to evaluate to true after at most 20 time units. Tool support # Hanfor takes as input an exported .csv file from Doors and stores the requirements. Figure 7 shows a screenshot of requirements imported into a Hanfor session. There are two IDs, the Hanfor ID and the Doors ID, so that the two databases can be synchronized. The informal requirements are listed in the column 'Description'. Once a requirement is formalized in the specification language, it is listed in the column 'Formalization'. Figure 6: Requirements exported into a Hanfor session. Clicking on a requirement opens the modification page of the requirement (Figure 8). The requirement can be formalized in the specification language by using the drop-down lists for both scopes and patterns. The variables can be specified manually by using the autocomplete function of the signal database. Figure 7: Modification window of a single requirement. For more information about the usage of Hanfor, please have a look at the usage section.","title":"What is Hanfor?"},{"location":"introduction/index.html#what-is-hanfor","text":"Hanfor is a tool that h elps an alyzing and fo rmalizing r equirements. The specification of requirements is a critical activity in software and system development. A defect in a requirement specification can result in a situation where a software or system is delivered that fullfills the given requirements, but does not satisfy the customer's needs due to erroneous requirments. Requirement analysis, as a human activity, is error-prone. Especially for large sets of requirements, it is difficult and time consuming to manually check whether a given property is satisfied or not. Requirement based testing is helpful to increase the efficiency during development. Obtaining a high test coverage on requirements often takes a long time. As the number of requirements increases over the releases, the test specifications have to cover more and more requirements. Hanfor is developed to ease the process of requirement analysis. Its method consists of three major steps to discover requirement defects and obtain test specifications based on a set of informal requirements (Figure 1): Requirement Formalization Requirement Check Test Generation Figure 1: The Hanfor tool discovers requirement defects and derives test specifications from a given set of informal requirements.","title":"What is Hanfor?"},{"location":"introduction/index.html#requirement-formalization","text":"To make it possible for a computer to check a set of requirements for a given criteria, it has to \"understand\" the semantics of the requirements. This could be achieved by using formal languages, which usually share the fact that they are rarely understandable for humans. In this method we make use of a simple pattern language. The language is based on a restricted English grammar and hence looks like natural language. Requirements formalized in this specification language can automatically be translated into logics.","title":"Requirement Formalization"},{"location":"introduction/index.html#specification-language","text":"The grammar of the specification language is given below. A requirement is defined by an ID, a scope and a pattern. Scope and pattern are parameterised by expressions over system observables and durations. Some patterns require a more detailed description concerning the order or the realtime occurence of events. REQ ::= ID: SCOPE, PATTERN . SCOPE ::= Globally | Before EXPR | After EXPR | Between EXPR and EXPR | After EXPR until EXPR PATTERN ::= It is never the case that EXPR holds | It is always the case that EXPR holds | It is always the case that if EXPR holds, then EXPR holds as well | Transition to states in which EXPR holds occur at most twice | It is always the case that ORDER | It is always the case that REALTIME ORDER ::= | If EXPR holds, then EXPR previously held | If EXPR holds and is succeded by EXPR, then EXPR previously held | If EXPR holds, then EXPR previously held and was preceeded by EXPR | If EXPR holds, then EXPR eventually holds and is succeeded by EXPR | If EXPR holds and is succeeded by EXPR, then EXPR eventually holds after EXPR | If EXPR holds, then EXPR eventually holds and is succeeded by EXPR where EXPR does not hold between EXPR and EXPR | If EXPR holds, then EXPR toggles EXPR REALTIME ::= Once EXPR becomes satisfied, it holds for at least DURATION | Once EXPR becomes satisfied, it holds for less than DURATION | EXPR holds at least every DURATION | If EXPR holds, then EXPR holds after at most DURATION | If EXPR holds for at least DURATION, then EXPR holds afterwards for at least DURATION | If EXPR holds for at least DURATION, then EXPR holds afterwards | If EXPR holds, then EXPR holds after at most DURATION for at least DURATION | If EXPR holds, then EXPR holds for at least DURATION | If EXPR holds, then there is at least one execution sequence such that EXPR holds after at most DURATION | After EXPR holds for DURATION, then EXPR holds | If EXPR holds, then EXPR toggles EXPR at most DURATION later Figure 2 shows the toolchain for the translation of an informal requirement into a formalized version. In the first step, the informal requirement, given in natural language, is translated into the specification language. This process is done manually. The requirement expressed in the specification language is then automatically translated into a formula in realtime logic (the Duration Calculus). Figure 2: A specification language for real-time requirements is used as an intermediate step in the translation from informal to formalized requirements.","title":"Specification language"},{"location":"introduction/index.html#requirement-check","text":"The Hanfor tool chain checks requirements for the following three correctness properties: Consistency Realtime-consistency Vacuity","title":"Requirement Check"},{"location":"introduction/index.html#consistency","text":"A set of requirements is inconsistent, if there exists no system satisfying all requirements in the set. Consider the two requirements in the specification language given below. This set of requirements is obviously not consistent as there is no interpretation where the observable 'A' evaluates both to true and to false at each point in time. Example 1: Inconsistent requirements Req1: Globally, it is never the case that 'A' holds. Req2: Globally, it is always the case that 'A' holds. Inconsistency in a set of requirements can be resolved by erasing or changing requirements.","title":"Consistency"},{"location":"introduction/index.html#realtime-consistency-rt-consistency","text":"A set of requirements is rt-inconsistent, if there are conflicts between requirements that arise after a certain time. Example 2: Rt-inconsistent requirements Req3: Globally, it is always the case that if 'B' holds then 'C' holds after at most '5' time units. Req4: Globally, it is always the case that if 'A' holds then '!C' holds for at least '2' time units. Consider the two real-time requirements given above. The set of the two requirements is consistent. Figure 3 gives an example of an interpretation of 'A', 'B', and 'C' (in form of a timing diagram) that satisfies both requirments. Figure 3: Consistency of the set of requirements {Req3, Req4}. 'A' and 'B' occur at the same point in time for one time unit, then '!C' for two time units satisfies Req4, and 'C' occurring at time 5 satisfies Req3. However, there are assignments for which the requirements are in conflict, as depicted in the example trace (Figure 4). If 'A' and 'B'change values as shown in the figure, than at time 5, Req4 would only be satisfied if 'C' remained false while Req3 would only be satisfied if 'C' changed to true . Figure 4: Witness for the rt-inconsistency of the set of requirements {Req3, Req4}. From time 4 on, the system steers toward inevitable rt-inconsistency. There are several possibilities to resolve the rt-inconsistency in a set of requirements, e.g. by erasing, changing or adding requirements. Example 2 (Cont.): Resolving rt-inconsistency Erasing requirements e.g. Erase Req4 Changing requirements e.g. Make Req4 less restrictive: Req4': Globally, it is always the case that if 'A' holds and 'B' did not hold in the last 5 time units, then '!C' holds for at least '2' time units. Adding requirements e.g. Add the following requirement: Req5: Globally, it is always the case that if 'B' holds, '!A' holds for at least 5 time units.","title":"Realtime-consistency (rt-consistency)"},{"location":"introduction/index.html#vacuity","text":"A set of requirements is vacuous, if the behaviour specified by the requirements cannot be triggered in a system satisfying all requirements. More intuitively spoken, a vacuous requirement can be imagined as dead code in an implementation: Both a vacouous requirement as well as dead code can be removed without changing the meaning of the remaining part. Consider again the requirements Req1 and Req4 given below. The set of requirements is consistent. However, the precondition of Req4 is never true as this would violate Req1. Req4 is therefore vacuously satisfied in this set of requirements. Example 3: Vacuous requirements Req1: Globally, it is never the case that 'A' holds. Req4: Globally, it is always the case that if 'A' holds then '!C' holds for at least '2' time units. There are several possibilities to resolve vacuity in a set of requirements. Example 3 (cont.): Resolving vacuity Erasing requirements e.g. Erase Req1 Changing requirements e.g. Make Req1 less restrictive: Req2': Before \"Startup\", it is never the case that 'A'holds.","title":"Vacuity"},{"location":"introduction/index.html#test-generation","text":"Formalized requirements can be used to automatically generate test specifications. An automatic test generation helps to reduce the time needed to write test specifications with a high coverage rate. The efficiency during development can be increased and the maintainability costs can be reduced.","title":"Test Generation"},{"location":"introduction/index.html#algorithm","text":"Testing requires information about observability. The system variables are therefore categorized into input, output, and hidden (i.e. internal) variables. A sequence of inputs deterministically causes the valuation of the output variable. Figure 5 shows an abstract view of a two-input system with the variables A , B and C . Figure 5: System S with input variables A , B , and output variable C . The test generation algorithm automatically generates system tests that are based only on the formalized requirements (i.e. do not depend on an additional system model). It generates at least one test case per output variable, but as most as many test cases such that every requirement is tested. Each generated test indicates the requirements that it is based on. It is ensured that the generated tests may not lead to false positives (i.e. the test case fails, although the system state is conform with the requirements). In case that there exist untestable requirements, the algorithm lists the set of untestable requirements.","title":"Algorithm"},{"location":"introduction/index.html#test-cases","text":"The test cases generated by Hanfor contain three sorts of information: A sequence of n inputs: The initial state of the system, as well as the inputs for steps 1 to n . The expected outcome: The expected valuation of the tested output variable. The indication on which requirements the test is based on. Consider the set of requirements given below. The variables A , B are considered to be inputs of the system (Figure 5), H and I are hidden variables, and C represents the output of the system. Example 4: Requirements to be tested Req1: Globally, it is always the case that if \u2018A\u2019 holds then \u2018H\u2019 holds after at most \u201810\u2019 time units. Req2: Globally, it is always the case that if \u2018B\u2019 holds then \u2018I\u2019 holds after at most \u201810\u2019 time units. Req3: Globally, it is always the case that if \u2018H AND I\u2019 holds then \u2018C\u2019 holds after at most \u201810\u2019 time units. The test generation tool outputs the following test case: Case SystemTest: TestGeneratorResult: Found Test for: [C] Test Vector: Set inputs: A := true, B := true Wait for at most 20 for: C == true, (req3) The given test case tests the output variable C based on the third requirement. The input sequence is specified by an initial state only, in which both input variables A and B are set to true . The output variable C is expected to evaluate to true after at most 20 time units.","title":"Test Cases"},{"location":"introduction/index.html#tool-support","text":"Hanfor takes as input an exported .csv file from Doors and stores the requirements. Figure 7 shows a screenshot of requirements imported into a Hanfor session. There are two IDs, the Hanfor ID and the Doors ID, so that the two databases can be synchronized. The informal requirements are listed in the column 'Description'. Once a requirement is formalized in the specification language, it is listed in the column 'Formalization'. Figure 6: Requirements exported into a Hanfor session. Clicking on a requirement opens the modification page of the requirement (Figure 8). The requirement can be formalized in the specification language by using the drop-down lists for both scopes and patterns. The variables can be specified manually by using the autocomplete function of the signal database. Figure 7: Modification window of a single requirement. For more information about the usage of Hanfor, please have a look at the usage section.","title":"Tool support"},{"location":"usage/api_queries.html","text":"API queries # To generate reports or search for requirements not using the frontend Hanfor can be queried with HTTP requests at http(s)://{{your host}}/{{your URL_PREFIX}}/api/query Show stored queries # GET /api/query URL arguments # Name Type Description name string Name of the Query to retrieve a single Query. reload bool, optional Reevaluates all stored Queries. Examples # # Show all stored Queries $ curl http://localhost:5000/api/query # Show only Queries which are named 'MyQuery' and re-evaluate the stored Query $ curl http://localhost:5000/api/query?name=MyQuery&reload=true # Using jq to parse the JSON response. Show only the name of the query with associated hits. $ curl http://localhost:5000/api/query\\?reload\\=true | jq -r '.data[] | {name: .name, hits: .hits}' Adding new queries # POST /api/query Content-Type: application/json JSON body parameters # Name Type Description name string Name for the Query. Existing ones will be overridden. query string The search Query. Examples # $ curl -X POST -H 'Content-Type: application/json' \\ --data '{\"name\": \"MyQuery\", \"query\": \"foo:AND:bar\"}' http://localhost:5000/api/query Deleting queries # DELETE /api/query JSON body parameters # Name Type Description name string Name for the Query to be deleted. names list of strings Queries by name to be deleted. Examples # # Delete a single Query: $ curl -X DELETE -H 'Content-Type: application/json' \\ --data '{\"name\": \"MyQuery\"}' http://localhost:5000/api/query # Delete multiple Queries: $ curl -X DELETE -H 'Content-Type: application/json' \\ --data '{\"names\": [\"MyQuery\", \"Another\"]' http://localhost:5000/api/query Query syntax # Much like in the frontend the Query syntax supports operators, nesting, exact- exclusive matches and targeting specific attributes. Search operators # You can concatenate search Queries by search_1:OR:search_2 yields the union of search_1 and search_2. search_1:AND:search_2 yields the intersection of search_1 and search_2. :AND: binds stronger than :OR: . To invert the result use :NOT: before your search string. To change the precedence or to nest a Query ( and ) . Exact searches # You can get exact search results by using \" to indicate the beginning or end of a sequence. \"fast Includes faster but not breakfast. fast\" Includes breakfast but not faster. \"fast\" Includes only exact matches of fast. Target specific attributes # To limit a part of the search Query to one attribute use the syntax :DATA_TARGET:<the attribute name> Note: the attribute name must be enclosed with backticks. Get available attributes # GET /api/quer?show=targets Example # # Show attribute names available for specific search. $ curl http://localhost:5000/api/query?show=targets Default targets: The available targets are composed of [ \"Description\", \"Formalization\", \"Id\", \"Status\", \"Tags\", \"Type\" ] Plus the fields available in the associated CSV file the requirements origin from.","title":"API queries"},{"location":"usage/api_queries.html#api-queries","text":"To generate reports or search for requirements not using the frontend Hanfor can be queried with HTTP requests at http(s)://{{your host}}/{{your URL_PREFIX}}/api/query","title":"API queries"},{"location":"usage/api_queries.html#show-stored-queries","text":"GET /api/query","title":"Show stored queries"},{"location":"usage/api_queries.html#url-arguments","text":"Name Type Description name string Name of the Query to retrieve a single Query. reload bool, optional Reevaluates all stored Queries.","title":"URL arguments"},{"location":"usage/api_queries.html#examples","text":"# Show all stored Queries $ curl http://localhost:5000/api/query # Show only Queries which are named 'MyQuery' and re-evaluate the stored Query $ curl http://localhost:5000/api/query?name=MyQuery&reload=true # Using jq to parse the JSON response. Show only the name of the query with associated hits. $ curl http://localhost:5000/api/query\\?reload\\=true | jq -r '.data[] | {name: .name, hits: .hits}'","title":"Examples"},{"location":"usage/api_queries.html#adding-new-queries","text":"POST /api/query Content-Type: application/json","title":"Adding new queries"},{"location":"usage/api_queries.html#json-body-parameters","text":"Name Type Description name string Name for the Query. Existing ones will be overridden. query string The search Query.","title":"JSON body parameters"},{"location":"usage/api_queries.html#examples_1","text":"$ curl -X POST -H 'Content-Type: application/json' \\ --data '{\"name\": \"MyQuery\", \"query\": \"foo:AND:bar\"}' http://localhost:5000/api/query","title":"Examples"},{"location":"usage/api_queries.html#deleting-queries","text":"DELETE /api/query","title":"Deleting queries"},{"location":"usage/api_queries.html#json-body-parameters_1","text":"Name Type Description name string Name for the Query to be deleted. names list of strings Queries by name to be deleted.","title":"JSON body parameters"},{"location":"usage/api_queries.html#examples_2","text":"# Delete a single Query: $ curl -X DELETE -H 'Content-Type: application/json' \\ --data '{\"name\": \"MyQuery\"}' http://localhost:5000/api/query # Delete multiple Queries: $ curl -X DELETE -H 'Content-Type: application/json' \\ --data '{\"names\": [\"MyQuery\", \"Another\"]' http://localhost:5000/api/query","title":"Examples"},{"location":"usage/api_queries.html#query-syntax","text":"Much like in the frontend the Query syntax supports operators, nesting, exact- exclusive matches and targeting specific attributes.","title":"Query syntax"},{"location":"usage/api_queries.html#search-operators","text":"You can concatenate search Queries by search_1:OR:search_2 yields the union of search_1 and search_2. search_1:AND:search_2 yields the intersection of search_1 and search_2. :AND: binds stronger than :OR: . To invert the result use :NOT: before your search string. To change the precedence or to nest a Query ( and ) .","title":"Search operators"},{"location":"usage/api_queries.html#exact-searches","text":"You can get exact search results by using \" to indicate the beginning or end of a sequence. \"fast Includes faster but not breakfast. fast\" Includes breakfast but not faster. \"fast\" Includes only exact matches of fast.","title":"Exact searches"},{"location":"usage/api_queries.html#target-specific-attributes","text":"To limit a part of the search Query to one attribute use the syntax :DATA_TARGET:<the attribute name> Note: the attribute name must be enclosed with backticks.","title":"Target specific attributes"},{"location":"usage/api_queries.html#get-available-attributes","text":"GET /api/quer?show=targets","title":"Get available attributes"},{"location":"usage/api_queries.html#example","text":"# Show attribute names available for specific search. $ curl http://localhost:5000/api/query?show=targets Default targets: The available targets are composed of [ \"Description\", \"Formalization\", \"Id\", \"Status\", \"Tags\", \"Type\" ] Plus the fields available in the associated CSV file the requirements origin from.","title":"Example"},{"location":"usage/faq.html","text":"FAQ # Change description or a field text in requirements table. # Currently there is only one way to achieve this: \u201cCreating a new revision\u201d: Edit the Description in the CSV -> edited.csv . Create a revision with the edited CSV as baseline: python app.py TAG_NAME -c path/to/edited.csv --revision This will check for changes in the CSV against the old one and create a new \u201cVersion\u201d aka. \u201cRevision\u201d.","title":"FAQ"},{"location":"usage/faq.html#faq","text":"","title":"FAQ"},{"location":"usage/faq.html#change-description-or-a-field-text-in-requirements-table","text":"Currently there is only one way to achieve this: \u201cCreating a new revision\u201d: Edit the Description in the CSV -> edited.csv . Create a revision with the edited CSV as baseline: python app.py TAG_NAME -c path/to/edited.csv --revision This will check for changes in the CSV against the old one and create a new \u201cVersion\u201d aka. \u201cRevision\u201d.","title":"Change description or a field text in requirements table."},{"location":"usage/patterns.html","text":"Patterns # BndDelayedResponsePatternUT # BndDelayedResponsePatternUT Globally # Globally, it is always the case that if \"R\" holds, then \"Q\" holds after at most \"c0\" time units for at least \"c1\" time units true;\u2308R\u2309;\u2308true\u2309 \u2227 \u2113 \u2265 50;\u2308Q\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true BndEntryConditionPattern # BndEntryConditionPattern Globally # Globally, it is always the case that after \"R\" holds for \"c0\" time units, then \"Q\" holds true;\u2308R\u2309 \u2227 \u2113 > 50;\u2308!Q\u2309;true BndEntryConditionPattern Before # Before \"Q\", it is always the case that after \"S\" holds for \"c0\" time units, then \"R\" holds \u2308!Q\u2309;\u2308(!Q && S)\u2309 \u2227 \u2113 > 50;\u2308(!Q && !R)\u2309;true BndEntryConditionPattern After # After \"Q\", it is always the case that after \"S\" holds for \"c0\" time units, then \"R\" holds true;\u2308Q\u2309;true;\u2308S\u2309 \u2227 \u2113 > 50;\u2308!R\u2309;true BndEntryConditionPattern Between # Between \"Q\" and \"R\", it is always the case that after \"T\" holds for \"c0\" time units, then \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309 \u2227 \u2113 > 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true BndEntryConditionPattern AfterUntil # After \"Q\" until \"R\", it is always the case that after \"T\" holds for \"c0\" time units, then \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309 \u2227 \u2113 > 50;\u2308(!R && !S)\u2309;true BndExistencePattern # BndExistencePattern Globally # Globally, transitions to states in which \"Q\" holds occur at most twice true;\u2308Q\u2309;\u2308!Q\u2309;\u2308Q\u2309;\u2308!Q\u2309;\u2308Q\u2309;true BndExistencePattern Before # Before \"Q\", transitions to states in which \"R\" holds occur at most twice \u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;true BndExistencePattern After # After \"Q\", transitions to states in which \"R\" holds occur at most twice true;\u2308Q\u2309;true;\u2308R\u2309;\u2308!R\u2309;\u2308R\u2309;\u2308!R\u2309;\u2308R\u2309;true BndExistencePattern Between # Between \"Q\" and \"R\", transitions to states in which \"S\" holds occur at most twice true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;\u2308R\u2309;true BndExistencePattern AfterUntil # After \"Q\" until \"R\", transitions to states in which \"S\" holds occur at most twice true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;true BndInvariancePattern # BndInvariancePattern Globally # Globally, it is always the case that if \"R\" holds, then \"Q\" holds for at least \"c0\" time units true;\u2308R\u2309;\u2308true\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true BndInvariancePattern Before # Before \"Q\", it is always the case that if \"S\" holds, then \"R\" holds for at least \"c0\" time units \u2308!Q\u2309;\u2308(!Q && S)\u2309;\u2308!Q\u2309 \u2227 \u2113 < 50;\u2308(!Q && !R)\u2309;true BndInvariancePattern After # After \"Q\", it is always the case that if \"S\" holds, then \"R\" holds for at least \"c0\" time units true;\u2308Q\u2309;true;\u2308S\u2309;\u2308true\u2309 \u2227 \u2113 < 50;\u2308!R\u2309;true BndInvariancePattern Between # Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309;\u2308!R\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true BndInvariancePattern AfterUntil # After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309;\u2308!R\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;true BndReccurrencePattern # BndReccurrencePattern Globally # Globally, it is always the case that \"Q\" holds at least every \"c0\" time units true;\u2308!Q\u2309 \u2227 \u2113 > 10;true BndReccurrencePattern Before # Before \"Q\", it is always the case that \"R\" holds at least every \"c0\" time units \u2308!Q\u2309;\u2308(!Q && !R)\u2309 \u2227 \u2113 > 50;true BndReccurrencePattern After # After \"Q\", it is always the case that \"R\" holds at least every \"c0\" time units true;\u2308Q\u2309;true;\u2308!R\u2309 \u2227 \u2113 > 50;true BndReccurrencePattern Between # Between \"Q\" and \"R\", it is always the case that \"S\" holds at least every \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 > 50;\u2308!R\u2309;\u2308R\u2309;true BndReccurrencePattern AfterUntil # After \"Q\" until \"R\", it is always the case that \"S\" holds at least every \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 > 50;true BndResponsePatternTT # BndResponsePatternTT Globally # Globally, it is always the case that if \"R\" holds for at least \"c0\" time units, then \"Q\" holds afterwards for at least \"c1\" time units true;\u2308R\u2309 \u2227 \u2113 \u2265 50;\u2308Q\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true BndResponsePatternTU # BndResponsePatternTU Globally # Globally, it is always the case that if \"R\" holds for at least \"c0\" time units, then \"Q\" holds afterwards true;\u2308R\u2309 \u2227 \u2113 \u2265 50;\u2308!Q\u2309;true BndResponsePatternUT # BndResponsePatternUT Globally # Globally, it is always the case that if \"R\" holds, then \"Q\" holds after at most \"c0\" time units true;\u2308(!Q && R)\u2309;\u2308!Q\u2309 \u2227 \u2113 > 50;true BndResponsePatternUT Before # Before \"Q\", it is always the case that if \"S\" holds, then \"R\" holds after at most \"c0\" time units \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308(!Q && !R)\u2309 \u2227 \u2113 \u2265 50;true BndResponsePatternUT After # After \"Q\", it is always the case that if \"S\" holds, then \"R\" holds after at most \"c0\" time units true;\u2308Q\u2309;true;\u2308(!R && S)\u2309;\u2308!R\u2309 \u2227 \u2113 \u2265 50;true BndResponsePatternUT Between # Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" holds after at most \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 \u2265 50;\u2308!R\u2309;\u2308R\u2309;true BndResponsePatternUT AfterUntil # After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" holds after at most \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 \u2265 50;true InstAbsPattern # InstAbsPattern Globally # Globally, it is never the case that \"Q\" holds true;\u2308Q\u2309;true InstAbsPattern After # After \"Q\", it is never the case that \"R\" holds true;\u2308Q\u2309;true;\u2308R\u2309;true InstAbsPattern Between # Between \"Q\" and \"R\", it is never the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;\u2308R\u2309;true InstAbsPattern AfterUntil # After \"Q\" until \"R\", it is never the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;true InvariantPattern # InvariantPattern Globally # Globally, it is always the case that if \"R\" holds, then \"Q\" holds as well true;\u2308(!Q && R)\u2309;true InvariantPattern Before # Before \"Q\", it is always the case that if \"S\" holds, then \"R\" holds as well \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308!Q\u2309;true InvariantPattern After # After \"Q\", it is always the case that if \"S\" holds, then \"R\" holds as well true;\u2308Q\u2309;true;\u2308(!R && S)\u2309;true InvariantPattern Between # Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" holds as well true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308!R\u2309;\u2308R\u2309;true InvariantPattern AfterUntil # After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" holds as well true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;true MaxDurationPattern # MaxDurationPattern Globally # Globally, it is always the case that once \"Q\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308Q\u2309 \u2227 \u2113 \u2265 50;true MaxDurationPattern Before # Before \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for less than \"c0\" time units \u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 50;true MaxDurationPattern After # After \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308Q\u2309;true;\u2308!R\u2309;\u2308R\u2309 \u2227 \u2113 \u2265 50;true MaxDurationPattern Between # Between \"Q\" and \"R\", it is always the case that once \"S\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 \u2265 50;\u2308!R\u2309;\u2308R\u2309;true MaxDurationPattern AfterUntil # After \"Q\" until \"R\", it is always the case that once \"S\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 \u2265 50;true MinDurationPattern # MinDurationPattern Globally # Globally, it is always the case that once \"Q\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308!Q\u2309;\u2308Q\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true MinDurationPattern Before # Before \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for at least \"c0\" time units \u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 < 50;\u2308(!Q && !R)\u2309;true MinDurationPattern After # After \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308Q\u2309;true;\u2308!R\u2309;\u2308R\u2309 \u2227 \u2113 < 50;\u2308!R\u2309;true MinDurationPattern Between # Between \"Q\" and \"R\", it is always the case that once \"S\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true MinDurationPattern AfterUntil # After \"Q\" until \"R\", it is always the case that once \"S\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;true PrecedenceChain12Pattern # PrecedenceChain12Pattern Globally # Globally, it is always the case that if \"S\" holds and is succeeded by \"R\", then \"Q\" previously held \u2308!S\u2309;\u2308R\u2309;true;\u2308Q\u2309;true PrecedenceChain12Pattern Before # Before \"Q\", it is always the case that if \"T\" holds and is succeeded by \"S\", then \"R\" previously held \u2308(!Q && !T)\u2309;\u2308(!Q && (S && !T))\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;true PrecedenceChain12Pattern After # After \"Q\", it is always the case that if \"T\" holds and is succeeded by \"S\", then \"R\" previously held \u2308!T\u2309;\u2308(Q && !T)\u2309;\u2308!T\u2309;\u2308(S && !T)\u2309;true;\u2308R\u2309;true PrecedenceChain12Pattern Between # Between \"Q\" and \"R\", it is always the case that if \"U\" holds and is succeeded by \"T\", then \"S\" previously held \u2308!U\u2309;\u2308(Q && (!R && !U))\u2309;\u2308(!R && !U)\u2309;\u2308(!R && (T && !U))\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;\u2308R\u2309;true PrecedenceChain12Pattern AfterUntil # After \"Q\" until \"R\", it is always the case that if \"U\" holds and is succeeded by \"T\", then \"S\" previously held \u2308!U\u2309;\u2308(Q && (!R && !U))\u2309;\u2308(!R && !U)\u2309;\u2308(!R && (T && !U))\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;true PrecedenceChain21Pattern # PrecedenceChain21Pattern Globally # Globally, it is always the case that if \"S\" holds, then \"R\" previously held and was preceded by \"Q\" \u2308!R\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308S\u2309;true PrecedencePattern # PrecedencePattern Globally # Globally, it is always the case that if \"R\" holds, then \"Q\" previously held \u2308!Q\u2309;\u2308R\u2309;true PrecedencePattern Before # Before \"Q\", it is always the case that if \"S\" holds, then \"R\" previously held \u2308(!Q && !R)\u2309;\u2308(!Q && S)\u2309;true PrecedencePattern After # After \"Q\", it is always the case that if \"S\" holds, then \"R\" previously held true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308S\u2309;true PrecedencePattern Between # Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" previously held true;\u2308(Q && (!R && !S))\u2309;\u2308(!R && !S)\u2309;\u2308(!R && (!S && T))\u2309;\u2308!R\u2309;\u2308R\u2309;true PrecedencePattern AfterUntil # After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" previously held true;\u2308(Q && (!R && !S))\u2309;\u2308(!R && !S)\u2309;\u2308(!R && T)\u2309;true ResponseChain21Pattern # ResponseChain21Pattern Before # Before \"Q\", it is always the case that if \"U\" holds and is succeeded by \"T\", then \"S\" eventually holds after \"R\" \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !T)\u2309;\u2308Q\u2309;true ResponseChain21Pattern Between # Between \"Q\" and \"R\", it is always the case that if \"V\" holds and is succeeded by \"U\", then \"T\" eventually holds after \"S\" true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308(!R && !U)\u2309;\u2308R\u2309;true ResponsePattern # ResponsePattern Globally # Globally, it is always the case that if \"R\" holds, then \"Q\" eventually holds true;\u2308(!Q && R)\u2309;\u2308!Q\u2309;true ResponsePattern Before # Before \"Q\", it is always the case that if \"S\" holds, then \"R\" eventually holds \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308(!Q && !R)\u2309;\u2308Q\u2309;true ResponsePattern Between # Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" eventually holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308(!R && !S)\u2309;\u2308R\u2309;true TogglePattern # TogglePattern Globally # Globally, it is always the case that if \"Q\" holds then \"R\" toggles \"S\" true;\u2308(Q && R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;true TogglePatternDelayed # TogglePatternDelayed Globally # Globally, it is always the case that if \"Q\" holds then \"R\" toggles \"S\" at most \"c0\" time units later true;\u2308(Q && R)\u2309;\u2308!R\u2309 \u2227 \u2113 \u2265 50;\u2308(!R && !S)\u2309;true UniversalityPattern # UniversalityPattern Globally # Globally, it is always the case that \"Q\" holds true;\u2308!Q\u2309;true UniversalityPattern Before # Before \"Q\", it is always the case that \"R\" holds \u2308!Q\u2309;\u2308(!Q && !R)\u2309;true UniversalityPattern After # After \"Q\", it is always the case that \"R\" holds true;\u2308Q\u2309;true;\u2308!R\u2309;true UniversalityPattern Between # Between \"Q\" and \"R\", it is always the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true UniversalityPattern AfterUntil # After \"Q\" until \"R\", it is always the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;true","title":"Patterns"},{"location":"usage/patterns.html#patterns","text":"","title":"Patterns"},{"location":"usage/patterns.html#bnddelayedresponsepatternut","text":"","title":"BndDelayedResponsePatternUT"},{"location":"usage/patterns.html#bnddelayedresponsepatternut-globally","text":"Globally, it is always the case that if \"R\" holds, then \"Q\" holds after at most \"c0\" time units for at least \"c1\" time units true;\u2308R\u2309;\u2308true\u2309 \u2227 \u2113 \u2265 50;\u2308Q\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true","title":"BndDelayedResponsePatternUT Globally"},{"location":"usage/patterns.html#bndentryconditionpattern","text":"","title":"BndEntryConditionPattern"},{"location":"usage/patterns.html#bndentryconditionpattern-globally","text":"Globally, it is always the case that after \"R\" holds for \"c0\" time units, then \"Q\" holds true;\u2308R\u2309 \u2227 \u2113 > 50;\u2308!Q\u2309;true","title":"BndEntryConditionPattern Globally"},{"location":"usage/patterns.html#bndentryconditionpattern-before","text":"Before \"Q\", it is always the case that after \"S\" holds for \"c0\" time units, then \"R\" holds \u2308!Q\u2309;\u2308(!Q && S)\u2309 \u2227 \u2113 > 50;\u2308(!Q && !R)\u2309;true","title":"BndEntryConditionPattern Before"},{"location":"usage/patterns.html#bndentryconditionpattern-after","text":"After \"Q\", it is always the case that after \"S\" holds for \"c0\" time units, then \"R\" holds true;\u2308Q\u2309;true;\u2308S\u2309 \u2227 \u2113 > 50;\u2308!R\u2309;true","title":"BndEntryConditionPattern After"},{"location":"usage/patterns.html#bndentryconditionpattern-between","text":"Between \"Q\" and \"R\", it is always the case that after \"T\" holds for \"c0\" time units, then \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309 \u2227 \u2113 > 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"BndEntryConditionPattern Between"},{"location":"usage/patterns.html#bndentryconditionpattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that after \"T\" holds for \"c0\" time units, then \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309 \u2227 \u2113 > 50;\u2308(!R && !S)\u2309;true","title":"BndEntryConditionPattern AfterUntil"},{"location":"usage/patterns.html#bndexistencepattern","text":"","title":"BndExistencePattern"},{"location":"usage/patterns.html#bndexistencepattern-globally","text":"Globally, transitions to states in which \"Q\" holds occur at most twice true;\u2308Q\u2309;\u2308!Q\u2309;\u2308Q\u2309;\u2308!Q\u2309;\u2308Q\u2309;true","title":"BndExistencePattern Globally"},{"location":"usage/patterns.html#bndexistencepattern-before","text":"Before \"Q\", transitions to states in which \"R\" holds occur at most twice \u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;true","title":"BndExistencePattern Before"},{"location":"usage/patterns.html#bndexistencepattern-after","text":"After \"Q\", transitions to states in which \"R\" holds occur at most twice true;\u2308Q\u2309;true;\u2308R\u2309;\u2308!R\u2309;\u2308R\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"BndExistencePattern After"},{"location":"usage/patterns.html#bndexistencepattern-between","text":"Between \"Q\" and \"R\", transitions to states in which \"S\" holds occur at most twice true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"BndExistencePattern Between"},{"location":"usage/patterns.html#bndexistencepattern-afteruntil","text":"After \"Q\" until \"R\", transitions to states in which \"S\" holds occur at most twice true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;true","title":"BndExistencePattern AfterUntil"},{"location":"usage/patterns.html#bndinvariancepattern","text":"","title":"BndInvariancePattern"},{"location":"usage/patterns.html#bndinvariancepattern-globally","text":"Globally, it is always the case that if \"R\" holds, then \"Q\" holds for at least \"c0\" time units true;\u2308R\u2309;\u2308true\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true","title":"BndInvariancePattern Globally"},{"location":"usage/patterns.html#bndinvariancepattern-before","text":"Before \"Q\", it is always the case that if \"S\" holds, then \"R\" holds for at least \"c0\" time units \u2308!Q\u2309;\u2308(!Q && S)\u2309;\u2308!Q\u2309 \u2227 \u2113 < 50;\u2308(!Q && !R)\u2309;true","title":"BndInvariancePattern Before"},{"location":"usage/patterns.html#bndinvariancepattern-after","text":"After \"Q\", it is always the case that if \"S\" holds, then \"R\" holds for at least \"c0\" time units true;\u2308Q\u2309;true;\u2308S\u2309;\u2308true\u2309 \u2227 \u2113 < 50;\u2308!R\u2309;true","title":"BndInvariancePattern After"},{"location":"usage/patterns.html#bndinvariancepattern-between","text":"Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309;\u2308!R\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"BndInvariancePattern Between"},{"location":"usage/patterns.html#bndinvariancepattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309;\u2308!R\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;true","title":"BndInvariancePattern AfterUntil"},{"location":"usage/patterns.html#bndreccurrencepattern","text":"","title":"BndReccurrencePattern"},{"location":"usage/patterns.html#bndreccurrencepattern-globally","text":"Globally, it is always the case that \"Q\" holds at least every \"c0\" time units true;\u2308!Q\u2309 \u2227 \u2113 > 10;true","title":"BndReccurrencePattern Globally"},{"location":"usage/patterns.html#bndreccurrencepattern-before","text":"Before \"Q\", it is always the case that \"R\" holds at least every \"c0\" time units \u2308!Q\u2309;\u2308(!Q && !R)\u2309 \u2227 \u2113 > 50;true","title":"BndReccurrencePattern Before"},{"location":"usage/patterns.html#bndreccurrencepattern-after","text":"After \"Q\", it is always the case that \"R\" holds at least every \"c0\" time units true;\u2308Q\u2309;true;\u2308!R\u2309 \u2227 \u2113 > 50;true","title":"BndReccurrencePattern After"},{"location":"usage/patterns.html#bndreccurrencepattern-between","text":"Between \"Q\" and \"R\", it is always the case that \"S\" holds at least every \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 > 50;\u2308!R\u2309;\u2308R\u2309;true","title":"BndReccurrencePattern Between"},{"location":"usage/patterns.html#bndreccurrencepattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that \"S\" holds at least every \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 > 50;true","title":"BndReccurrencePattern AfterUntil"},{"location":"usage/patterns.html#bndresponsepatterntt","text":"","title":"BndResponsePatternTT"},{"location":"usage/patterns.html#bndresponsepatterntt-globally","text":"Globally, it is always the case that if \"R\" holds for at least \"c0\" time units, then \"Q\" holds afterwards for at least \"c1\" time units true;\u2308R\u2309 \u2227 \u2113 \u2265 50;\u2308Q\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true","title":"BndResponsePatternTT Globally"},{"location":"usage/patterns.html#bndresponsepatterntu","text":"","title":"BndResponsePatternTU"},{"location":"usage/patterns.html#bndresponsepatterntu-globally","text":"Globally, it is always the case that if \"R\" holds for at least \"c0\" time units, then \"Q\" holds afterwards true;\u2308R\u2309 \u2227 \u2113 \u2265 50;\u2308!Q\u2309;true","title":"BndResponsePatternTU Globally"},{"location":"usage/patterns.html#bndresponsepatternut","text":"","title":"BndResponsePatternUT"},{"location":"usage/patterns.html#bndresponsepatternut-globally","text":"Globally, it is always the case that if \"R\" holds, then \"Q\" holds after at most \"c0\" time units true;\u2308(!Q && R)\u2309;\u2308!Q\u2309 \u2227 \u2113 > 50;true","title":"BndResponsePatternUT Globally"},{"location":"usage/patterns.html#bndresponsepatternut-before","text":"Before \"Q\", it is always the case that if \"S\" holds, then \"R\" holds after at most \"c0\" time units \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308(!Q && !R)\u2309 \u2227 \u2113 \u2265 50;true","title":"BndResponsePatternUT Before"},{"location":"usage/patterns.html#bndresponsepatternut-after","text":"After \"Q\", it is always the case that if \"S\" holds, then \"R\" holds after at most \"c0\" time units true;\u2308Q\u2309;true;\u2308(!R && S)\u2309;\u2308!R\u2309 \u2227 \u2113 \u2265 50;true","title":"BndResponsePatternUT After"},{"location":"usage/patterns.html#bndresponsepatternut-between","text":"Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" holds after at most \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 \u2265 50;\u2308!R\u2309;\u2308R\u2309;true","title":"BndResponsePatternUT Between"},{"location":"usage/patterns.html#bndresponsepatternut-afteruntil","text":"After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" holds after at most \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 \u2265 50;true","title":"BndResponsePatternUT AfterUntil"},{"location":"usage/patterns.html#instabspattern","text":"","title":"InstAbsPattern"},{"location":"usage/patterns.html#instabspattern-globally","text":"Globally, it is never the case that \"Q\" holds true;\u2308Q\u2309;true","title":"InstAbsPattern Globally"},{"location":"usage/patterns.html#instabspattern-after","text":"After \"Q\", it is never the case that \"R\" holds true;\u2308Q\u2309;true;\u2308R\u2309;true","title":"InstAbsPattern After"},{"location":"usage/patterns.html#instabspattern-between","text":"Between \"Q\" and \"R\", it is never the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"InstAbsPattern Between"},{"location":"usage/patterns.html#instabspattern-afteruntil","text":"After \"Q\" until \"R\", it is never the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;true","title":"InstAbsPattern AfterUntil"},{"location":"usage/patterns.html#invariantpattern","text":"","title":"InvariantPattern"},{"location":"usage/patterns.html#invariantpattern-globally","text":"Globally, it is always the case that if \"R\" holds, then \"Q\" holds as well true;\u2308(!Q && R)\u2309;true","title":"InvariantPattern Globally"},{"location":"usage/patterns.html#invariantpattern-before","text":"Before \"Q\", it is always the case that if \"S\" holds, then \"R\" holds as well \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308!Q\u2309;true","title":"InvariantPattern Before"},{"location":"usage/patterns.html#invariantpattern-after","text":"After \"Q\", it is always the case that if \"S\" holds, then \"R\" holds as well true;\u2308Q\u2309;true;\u2308(!R && S)\u2309;true","title":"InvariantPattern After"},{"location":"usage/patterns.html#invariantpattern-between","text":"Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" holds as well true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"InvariantPattern Between"},{"location":"usage/patterns.html#invariantpattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" holds as well true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;true","title":"InvariantPattern AfterUntil"},{"location":"usage/patterns.html#maxdurationpattern","text":"","title":"MaxDurationPattern"},{"location":"usage/patterns.html#maxdurationpattern-globally","text":"Globally, it is always the case that once \"Q\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308Q\u2309 \u2227 \u2113 \u2265 50;true","title":"MaxDurationPattern Globally"},{"location":"usage/patterns.html#maxdurationpattern-before","text":"Before \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for less than \"c0\" time units \u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 50;true","title":"MaxDurationPattern Before"},{"location":"usage/patterns.html#maxdurationpattern-after","text":"After \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308Q\u2309;true;\u2308!R\u2309;\u2308R\u2309 \u2227 \u2113 \u2265 50;true","title":"MaxDurationPattern After"},{"location":"usage/patterns.html#maxdurationpattern-between","text":"Between \"Q\" and \"R\", it is always the case that once \"S\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 \u2265 50;\u2308!R\u2309;\u2308R\u2309;true","title":"MaxDurationPattern Between"},{"location":"usage/patterns.html#maxdurationpattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that once \"S\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 \u2265 50;true","title":"MaxDurationPattern AfterUntil"},{"location":"usage/patterns.html#mindurationpattern","text":"","title":"MinDurationPattern"},{"location":"usage/patterns.html#mindurationpattern-globally","text":"Globally, it is always the case that once \"Q\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308!Q\u2309;\u2308Q\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true","title":"MinDurationPattern Globally"},{"location":"usage/patterns.html#mindurationpattern-before","text":"Before \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for at least \"c0\" time units \u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 < 50;\u2308(!Q && !R)\u2309;true","title":"MinDurationPattern Before"},{"location":"usage/patterns.html#mindurationpattern-after","text":"After \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308Q\u2309;true;\u2308!R\u2309;\u2308R\u2309 \u2227 \u2113 < 50;\u2308!R\u2309;true","title":"MinDurationPattern After"},{"location":"usage/patterns.html#mindurationpattern-between","text":"Between \"Q\" and \"R\", it is always the case that once \"S\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"MinDurationPattern Between"},{"location":"usage/patterns.html#mindurationpattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that once \"S\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;true","title":"MinDurationPattern AfterUntil"},{"location":"usage/patterns.html#precedencechain12pattern","text":"","title":"PrecedenceChain12Pattern"},{"location":"usage/patterns.html#precedencechain12pattern-globally","text":"Globally, it is always the case that if \"S\" holds and is succeeded by \"R\", then \"Q\" previously held \u2308!S\u2309;\u2308R\u2309;true;\u2308Q\u2309;true","title":"PrecedenceChain12Pattern Globally"},{"location":"usage/patterns.html#precedencechain12pattern-before","text":"Before \"Q\", it is always the case that if \"T\" holds and is succeeded by \"S\", then \"R\" previously held \u2308(!Q && !T)\u2309;\u2308(!Q && (S && !T))\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;true","title":"PrecedenceChain12Pattern Before"},{"location":"usage/patterns.html#precedencechain12pattern-after","text":"After \"Q\", it is always the case that if \"T\" holds and is succeeded by \"S\", then \"R\" previously held \u2308!T\u2309;\u2308(Q && !T)\u2309;\u2308!T\u2309;\u2308(S && !T)\u2309;true;\u2308R\u2309;true","title":"PrecedenceChain12Pattern After"},{"location":"usage/patterns.html#precedencechain12pattern-between","text":"Between \"Q\" and \"R\", it is always the case that if \"U\" holds and is succeeded by \"T\", then \"S\" previously held \u2308!U\u2309;\u2308(Q && (!R && !U))\u2309;\u2308(!R && !U)\u2309;\u2308(!R && (T && !U))\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"PrecedenceChain12Pattern Between"},{"location":"usage/patterns.html#precedencechain12pattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that if \"U\" holds and is succeeded by \"T\", then \"S\" previously held \u2308!U\u2309;\u2308(Q && (!R && !U))\u2309;\u2308(!R && !U)\u2309;\u2308(!R && (T && !U))\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;true","title":"PrecedenceChain12Pattern AfterUntil"},{"location":"usage/patterns.html#precedencechain21pattern","text":"","title":"PrecedenceChain21Pattern"},{"location":"usage/patterns.html#precedencechain21pattern-globally","text":"Globally, it is always the case that if \"S\" holds, then \"R\" previously held and was preceded by \"Q\" \u2308!R\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308S\u2309;true","title":"PrecedenceChain21Pattern Globally"},{"location":"usage/patterns.html#precedencepattern","text":"","title":"PrecedencePattern"},{"location":"usage/patterns.html#precedencepattern-globally","text":"Globally, it is always the case that if \"R\" holds, then \"Q\" previously held \u2308!Q\u2309;\u2308R\u2309;true","title":"PrecedencePattern Globally"},{"location":"usage/patterns.html#precedencepattern-before","text":"Before \"Q\", it is always the case that if \"S\" holds, then \"R\" previously held \u2308(!Q && !R)\u2309;\u2308(!Q && S)\u2309;true","title":"PrecedencePattern Before"},{"location":"usage/patterns.html#precedencepattern-after","text":"After \"Q\", it is always the case that if \"S\" holds, then \"R\" previously held true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308S\u2309;true","title":"PrecedencePattern After"},{"location":"usage/patterns.html#precedencepattern-between","text":"Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" previously held true;\u2308(Q && (!R && !S))\u2309;\u2308(!R && !S)\u2309;\u2308(!R && (!S && T))\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"PrecedencePattern Between"},{"location":"usage/patterns.html#precedencepattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" previously held true;\u2308(Q && (!R && !S))\u2309;\u2308(!R && !S)\u2309;\u2308(!R && T)\u2309;true","title":"PrecedencePattern AfterUntil"},{"location":"usage/patterns.html#responsechain21pattern","text":"","title":"ResponseChain21Pattern"},{"location":"usage/patterns.html#responsechain21pattern-before","text":"Before \"Q\", it is always the case that if \"U\" holds and is succeeded by \"T\", then \"S\" eventually holds after \"R\" \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !T)\u2309;\u2308Q\u2309;true","title":"ResponseChain21Pattern Before"},{"location":"usage/patterns.html#responsechain21pattern-between","text":"Between \"Q\" and \"R\", it is always the case that if \"V\" holds and is succeeded by \"U\", then \"T\" eventually holds after \"S\" true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308(!R && !U)\u2309;\u2308R\u2309;true","title":"ResponseChain21Pattern Between"},{"location":"usage/patterns.html#responsepattern","text":"","title":"ResponsePattern"},{"location":"usage/patterns.html#responsepattern-globally","text":"Globally, it is always the case that if \"R\" holds, then \"Q\" eventually holds true;\u2308(!Q && R)\u2309;\u2308!Q\u2309;true","title":"ResponsePattern Globally"},{"location":"usage/patterns.html#responsepattern-before","text":"Before \"Q\", it is always the case that if \"S\" holds, then \"R\" eventually holds \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308(!Q && !R)\u2309;\u2308Q\u2309;true","title":"ResponsePattern Before"},{"location":"usage/patterns.html#responsepattern-between","text":"Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" eventually holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308(!R && !S)\u2309;\u2308R\u2309;true","title":"ResponsePattern Between"},{"location":"usage/patterns.html#togglepattern","text":"","title":"TogglePattern"},{"location":"usage/patterns.html#togglepattern-globally","text":"Globally, it is always the case that if \"Q\" holds then \"R\" toggles \"S\" true;\u2308(Q && R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;true","title":"TogglePattern Globally"},{"location":"usage/patterns.html#togglepatterndelayed","text":"","title":"TogglePatternDelayed"},{"location":"usage/patterns.html#togglepatterndelayed-globally","text":"Globally, it is always the case that if \"Q\" holds then \"R\" toggles \"S\" at most \"c0\" time units later true;\u2308(Q && R)\u2309;\u2308!R\u2309 \u2227 \u2113 \u2265 50;\u2308(!R && !S)\u2309;true","title":"TogglePatternDelayed Globally"},{"location":"usage/patterns.html#universalitypattern","text":"","title":"UniversalityPattern"},{"location":"usage/patterns.html#universalitypattern-globally","text":"Globally, it is always the case that \"Q\" holds true;\u2308!Q\u2309;true","title":"UniversalityPattern Globally"},{"location":"usage/patterns.html#universalitypattern-before","text":"Before \"Q\", it is always the case that \"R\" holds \u2308!Q\u2309;\u2308(!Q && !R)\u2309;true","title":"UniversalityPattern Before"},{"location":"usage/patterns.html#universalitypattern-after","text":"After \"Q\", it is always the case that \"R\" holds true;\u2308Q\u2309;true;\u2308!R\u2309;true","title":"UniversalityPattern After"},{"location":"usage/patterns.html#universalitypattern-between","text":"Between \"Q\" and \"R\", it is always the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"UniversalityPattern Between"},{"location":"usage/patterns.html#universalitypattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;true","title":"UniversalityPattern AfterUntil"},{"location":"usage/requirements.html","text":"Requirements # Search in requirements table # Searching in the requirements table is accessible via the search tab. Typing in the search input supports autocomplete for extended search triggered by : . Search Operators # You can concatenate search queries by search_1:OR:search_2 yields the union of search_1 and search_2. search_1:AND:search_2 yields the intersection of search_1 and search_2. :AND: binds stronger than :OR: . To invert the result use :NOT: before your search string. Exact searches # You can get exact search results by using \" to indicate the beginning or end of a sequence. \"fast Includes faster but not breakfast. fast\" Includes breakfast but not faster. \"fast\" Includes only exact matches of fast. Search Target column To target a specific column use :COL_INDEX_02: to target column 2. The column indexes are appended in the requirements table header in parentheses. Mass edit requirements # You can mass edit requirements. Select requirements by clicking on the requirement checkbox in the table. Hold shift for multi select and Ctrl to toggle a single selection. Click on Edit Selected , fill out the form. Empty fields will have no effect.","title":"Requirements"},{"location":"usage/requirements.html#requirements","text":"","title":"Requirements"},{"location":"usage/requirements.html#search-in-requirements-table","text":"Searching in the requirements table is accessible via the search tab. Typing in the search input supports autocomplete for extended search triggered by : .","title":"Search in requirements table"},{"location":"usage/requirements.html#search-operators","text":"You can concatenate search queries by search_1:OR:search_2 yields the union of search_1 and search_2. search_1:AND:search_2 yields the intersection of search_1 and search_2. :AND: binds stronger than :OR: . To invert the result use :NOT: before your search string.","title":"Search Operators"},{"location":"usage/requirements.html#exact-searches","text":"You can get exact search results by using \" to indicate the beginning or end of a sequence. \"fast Includes faster but not breakfast. fast\" Includes breakfast but not faster. \"fast\" Includes only exact matches of fast.","title":"Exact searches"},{"location":"usage/requirements.html#mass-edit-requirements","text":"You can mass edit requirements. Select requirements by clicking on the requirement checkbox in the table. Hold shift for multi select and Ctrl to toggle a single selection. Click on Edit Selected , fill out the form. Empty fields will have no effect.","title":"Mass edit requirements"},{"location":"usage/workflow.html","text":"Workflow # This example and everything that belongs to it is located in example_input . Example input # The CSV file example_intput/example_input.csv contains requirements: ID,Description,Type META1,This is an example for some requirements,meta META2,Next we define some requirements,meta REQ1,var1 is always greater than 5,requirement REQ2,var2 is always smaller than 10,requirement REQ3,constraint1 always holds,requirement REQ4,constraint2 always holds,requirement REQ5,var1 is always smaller than 5,requirement REQ6,constraint1 and constraint2 never hold at the same time,requirement REQ7,if var3 = True then var4 := 1,requirement REQ8,if var3 = True then var4 := 0,requirement In this case every row consists of the fields ID , Description , and Type . ID is a unique identifier, Description is the description , Type , is a type, in this example meta or requirement , where rows with type meta contain some meta-information and rows with type requirement contain actual requirements of the module you want to formalize. Fire up Hanfor # Configure Hanfor as explained in Configuration Start Hanfor: cd hanfor python3 app.py -c ../example_input/example_input.csv awesome_tag_by_bree -c example_input.csv specifies the csv input file we pass. example_tag is some meaningful tag you want to give this session. If you start hanfor later with the same tag, you'll start exactly this session. Currently the startup of Hanfor is interactive and looks like this: (venv) bree@titan:~/repos/hanfor/hanfor$ python3 app.py -c ../example_input/example_input.csv awesome_tag_by_bree 2019-10-10 13:55:17,845: [DEBUG]: Enabled logging. 2019-10-10 13:55:17,858: [INFO]: Hanfor starts creating a revision. 2019-10-10 13:55:17,858: [INFO]: No revisions for `awesome_tag_by_bree`. Creating initial revision. 2019-10-10 13:55:17,858: [INFO]: Load Input : example/example_input.csv 2019-10-10 13:55:17,862: [INFO]: Could not guess .csv dialect, assuming defaults Select ID header \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 -> 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [Choice or Enter for -> default]> 1 Select requirements description header \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [Choice or Enter for -> default]> 0 Select formalization header \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u2551 3 \u2551 Add new Formalization \u2551 \u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [Choice or Enter for -> default]> 3 Select type header. \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [Choice or Enter for -> default]> 2 Alternatively you can directly pass the header definition, using --header : python3 app.py -c example_input/example_input.csv --header='{\"csv_id_header\": \"ID\", \"csv_desc_header\": \"Description\", \"csv_formal_header\": \"Hanfor_Formalization\", \"csv_type_header\" : \"Type\"}' awesome_tag you can now reach Hanfor by visiting http://127.0.0.1:5000 Hanfor requirement overview Preprocessing # By default, all rows now have the status Todo . It might be the case that you want to change this for a certain set of rows to another status. In this example we want to set every row of type meta to the status Done . To accomplish this we use the Search Query Language . In Hanfor, search :COL_INDEX_04:meta . This will search for rows which match \"meta\" in the 4. coloumn (Type). You should now only see the rows of type meta . Select all rows by clicking All . Click Edit selected and select Done in the field Set status . Finally, click Apply changes to selected requirements Formalization # Order your requirement overview by Pos by clicking on the table column. REQ1 # To formalize this requirement, we click on the ID REQ1 to open then formalization-modal: Formalization modal Click on + to add a new formalization and then on ..(click to open) We now have to select a Scope and a Pattern . The scope is Globally , because the requirement states that \"var1 is always greater than 5\". The pattern is it is always the case that {R} holds . For {R} we insert the condition: var1 > 5 Set the status to Review and then press save changes . If you save a requirement, Hanfor will automatically create the used variables and derive their type. You can examine and even alter them in the section Variables , for the case that Hanfor did not derive a variable-type correctly. Definition of Scope and Pattern The same procedure can be applied to REQ2 - REQ6 REQ7 and REQ8 # REQ7 and REQ8 are different. Consider REQ7: if var3 = True then var4 := 0 . The scope is still Globally The pattern is it is always the case that if \"{R}\" holds, then \"{S}\" holds after at most \"{T}\" time units , because in a realtime-system a variable assignment does not happen instantly, there can be delays. For {R} we insert var3 , because the variable type is boolean. For {S} insert var4 == 0 , For {T} we need a certain amount of time units, for example 50. We do not want to hardcode values, we introduce a new variable and insert MAX_TIME . We end up with the following: Globally, it is always the case that if \"var3\" holds, then \"var4 == 0\" holds after at most \"MAX_TIME\" time units. Save the formalization. You will now recognize that Hanfor automatically added a new Tag Type_inference_error to your freshly formalized requirement. To fix that, to go the Variables section and open the MAX_TIME variable. You see that Hanfor derived the type bool , but we actually want it to be of type CONST as the variable represents time units. Change the type and also assign a value, for example 50 . Example for the MAX_TIME variable For REQ8 you should have: Globally, it is always the case that if \"var3\" holds, then \"var4 == 1\" holds after at most \"MAX_TIME\" time units. Exporting the formalized requirements. # Once you are done with all requirements, it is time to analyze them using a tool like Ultimate (TODO:ref to git). Preparing the export. # You might want to filter out some rows, for example, all of type meta or all that have a certain tag. Again, use the Search Query Language to select only the requirements you want. For example, if we only rows of type requirement which are not on status Todo we search: :COL_INDEX_04:requirement:AND::COL_INDEX_06::NOT:Todo Export # To export requirements, press Tools , then choose either .req or .csv . If you want to analyze the requirements using Ultimate, choose Generate .req file from (filtered) requirements table and then save it. You should end up with the following: CONST MAX_TIME IS 50.0 Input constraint1 IS bool Input constraint2 IS bool Input var1 IS int Input var2 IS int Input var3 IS bool Input var4 IS int REQ1_0: Globally, it is always the case that \"var1 > 5\" holds REQ2_0: Globally, it is always the case that \"var2 < 10\" holds REQ3_0: Globally, it is always the case that \"constraint1\" holds REQ4_0: Globally, it is always the case that \"constraint2\" holds REQ5_0: Globally, it is always the case that \"var1 < 5\" holds REQ6_0: Globally, it is never the case that \"constraint1 && constraint2 \" holds REQ7_0: Globally, it is always the case that if \"var3\" holds, then \"var4 == 1\" holds after at most \"MAX_TIME\" time units REQ8_0: Globally, it is always the case that if \"var3\" holds, then \"var4 == 0\" holds after at most \"MAX_TIME \" time units Analysis using Ultimate. # Get Ultimate # First of all you need Ultimate Install Java JDK (1.8) and Maven (>3.0) Clone the repository: git clone https://github.com/ultimate-pa/ultimate . Navigate to the release scripts cd ultimate/releaseScripts/default Generate a fresh binary ./makeFresh.sh You have now successfully forged binaries, which are located in UReqCheck-linux . Scripts to perform the complete analysis. # We wrote a script, which perform a complete anaylsis, including the extraction of relevant stuff. The script is located in /path/to/ultimate/releaseScripts/default/UReqCheck-linux . You have to configure run_complete_analysis.sh , which is used to run the complete analysis. The script takes several arguments: run_complete_analysis.sh <req_file> <req_repo_folder> <req_folder> [<rt_inconsistency_range> <timeout_per_assertion>] Where: req_file is the Requirements file you generated using Hanfor. req_repo_folder is the path to the repository, which contains the requirements-folder req_folder is the path to the requirements-folder rt_inconsistency_range (default: 2) is the amount of requirements which are checked together for RT-inconsistency. Careful with this parameter, it will blow up the amount of checks really fast. * timeout_per_assertion (default: 900) The time how long a singles assertion is checked. Use Ultimate # We now simply execute the run_complete_analysis.sh script. $ cd /path/to/ultimate/releaseScripts/default/UReqCheck-linux $ ./run_complete_analysis.sh path/to/repo/example_input/example_input.req path/to/repo/example_input path/to/repo/example_input This will fire up Ultimate and run an analysis. The analysis checks for rt-inconsistency and vacuity and logs are be generated: hanfor/example/example_input.req.log hanfor/example/example_input.req.testgen.log hanfor/example/logs/example_input/example_input.req.relevant.log hanfor/example/logs/example_input/example_input.req.testgen.log Evaluate # In hanfor/example/example_input.req.log we can see that Ultimate reports: --- Results --- * Results from de.uni_freiburg.informatik.ultimate.pea2boogie: - RequirementInconsistentErrorResult: Requirements set is inconsistent. Requirements set is inconsistent. Some invariants are already infeasible. Responsible requirements: REQ6_0, REQ3_0, REQ4_0 Now, if we investigate REQ3, REQ4 and REQ6: REQ3_0: Globally, it is always the case that \"constraint1\" holds REQ4_0: Globally, it is always the case that \"constraint2\" holds REQ6_0: Globally, it is never the case that \"constraint1 && constraint2 \" holds We directly see what the problem is: On one hand, our invariants demand that constraint1 and constraint2 always holds, but on the other hand there is another invariant which demands that constraint1 and constraint2 never hold at the same time. Think about this as: constraint1 && constraint2 && ((constraint1 && !constraint2) || (!constraint1 && constraint2)) this is clearly unsatisfiable. Alter your requirements # We now found an inconsistency in our requirements, that has to be fixed. Let's assume you review your requirements and you recognize REQ4 was defined wrong in the csv, where REQ4,constraint2 always holds,requirement should be REQ4,constraint2 never holds,requirement . While reading over the requirements, you also recognize that REQ1 and REQ5 collide and you find out that REQ5 shall be deleted. When we apply this changes, we end up with the following changes: alter REQ4,constraint2 always holds,requirement to REQ4,constraint2 never holds,requirement remove REQ5 and our csv file now looks as follows: ID,Description,Type META1,This is an example for some requirements,meta META2,Next we define some requirements,meta REQ1,var1 is always greater than 5,requirement REQ2,var2 is always smaller than 10,requirement REQ3,constraint1 always holds,requirement REQ4,constraint2 never holds,requirement REQ6,constraint1 and constraint2 never hold at the same time,requirement REQ7,if var3 = True then var4 = 0,requirement REQ8,if var3 = True then var4 = 1,requirement Time for a new revision. # We altered our requirements, we now need to create a new revision in Hanfor and change our formalizations. Execute: $ cd hanfor $ python3 app.py -r -c example/example_input.csv example_tag Hanfor will then ask: \"Which revision should I use as a base?\" , we choose revision_0 (as it is the only one, usually you want your latest revision). Then, Hanfor asks Should I use the csv header mapping from base revision? , as we did not change the csv header, we just keep the current one. A quick recap what happens when creating a revision: New requirements get the tag revision_0_to_revision_1_new_requirement Changed requirements get the tag revision_0_to_revision_1_data_changed and revision_0_to_revision_1_description_changed * Requirements where the formalization migrated to the new revision get the tag revision_0_to_revision_1_migrated_formalized We now have to alter the requirements which have changed, that's only REQ4 . Open the formalization of REQ4 and correct it to Globally, it is never the case that \"constraint2\" holds . Ultimate Analysis #2 # Export your requirements as before with the name example_input_revision1.req Run Ultimate on the new requirements file. You can now examine the log created in hanfor/example/logs/example_input/example_input.req.relevant.log , which contains the following: - ReqCheckFailResult [Line: -1]: Requirements REQ8_0, REQ7_0 are rt-inconsistent A ReqCheckFailResult usually implies that something is broken, Ultimate found that requirements REQ7 and REQ8 are rt-inconsistent, let's analyze this result: REQ7,if var3 = True then var4 = 0,requirement REQ8,if var3 = True then var4 = 1,requirement These two requirements collide, because they assign different values to var4 when var3 holds. This is especially bad in a realtime system, because it can happen that var4 == 0 holds after a certain amount of time, and var4 == 1 holds at a later point of time or vice versa. Why is this bad? - because it can cause unexpected behaviour when a change propagates through the system. Conclusion # You are now able to: Setup hanfor, Formalize requirements, Filter requirements, Export them to a .req file Run Ultimate on a .req file Interpret the results of Ultimate Create new revisions in hanfor to fix mistakes in requirements.","title":"Workflow"},{"location":"usage/workflow.html#workflow","text":"This example and everything that belongs to it is located in example_input .","title":"Workflow"},{"location":"usage/workflow.html#example-input","text":"The CSV file example_intput/example_input.csv contains requirements: ID,Description,Type META1,This is an example for some requirements,meta META2,Next we define some requirements,meta REQ1,var1 is always greater than 5,requirement REQ2,var2 is always smaller than 10,requirement REQ3,constraint1 always holds,requirement REQ4,constraint2 always holds,requirement REQ5,var1 is always smaller than 5,requirement REQ6,constraint1 and constraint2 never hold at the same time,requirement REQ7,if var3 = True then var4 := 1,requirement REQ8,if var3 = True then var4 := 0,requirement In this case every row consists of the fields ID , Description , and Type . ID is a unique identifier, Description is the description , Type , is a type, in this example meta or requirement , where rows with type meta contain some meta-information and rows with type requirement contain actual requirements of the module you want to formalize.","title":"Example input"},{"location":"usage/workflow.html#fire-up-hanfor","text":"Configure Hanfor as explained in Configuration Start Hanfor: cd hanfor python3 app.py -c ../example_input/example_input.csv awesome_tag_by_bree -c example_input.csv specifies the csv input file we pass. example_tag is some meaningful tag you want to give this session. If you start hanfor later with the same tag, you'll start exactly this session. Currently the startup of Hanfor is interactive and looks like this: (venv) bree@titan:~/repos/hanfor/hanfor$ python3 app.py -c ../example_input/example_input.csv awesome_tag_by_bree 2019-10-10 13:55:17,845: [DEBUG]: Enabled logging. 2019-10-10 13:55:17,858: [INFO]: Hanfor starts creating a revision. 2019-10-10 13:55:17,858: [INFO]: No revisions for `awesome_tag_by_bree`. Creating initial revision. 2019-10-10 13:55:17,858: [INFO]: Load Input : example/example_input.csv 2019-10-10 13:55:17,862: [INFO]: Could not guess .csv dialect, assuming defaults Select ID header \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 -> 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [Choice or Enter for -> default]> 1 Select requirements description header \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [Choice or Enter for -> default]> 0 Select formalization header \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u2551 3 \u2551 Add new Formalization \u2551 \u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [Choice or Enter for -> default]> 3 Select type header. \u2554Choices\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 0 \u2551 Description \u2551 \u2551 1 \u2551 ID \u2551 \u2551 2 \u2551 Type \u2551 \u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d [Choice or Enter for -> default]> 2 Alternatively you can directly pass the header definition, using --header : python3 app.py -c example_input/example_input.csv --header='{\"csv_id_header\": \"ID\", \"csv_desc_header\": \"Description\", \"csv_formal_header\": \"Hanfor_Formalization\", \"csv_type_header\" : \"Type\"}' awesome_tag you can now reach Hanfor by visiting http://127.0.0.1:5000 Hanfor requirement overview","title":"Fire up Hanfor"},{"location":"usage/workflow.html#preprocessing","text":"By default, all rows now have the status Todo . It might be the case that you want to change this for a certain set of rows to another status. In this example we want to set every row of type meta to the status Done . To accomplish this we use the Search Query Language . In Hanfor, search :COL_INDEX_04:meta . This will search for rows which match \"meta\" in the 4. coloumn (Type). You should now only see the rows of type meta . Select all rows by clicking All . Click Edit selected and select Done in the field Set status . Finally, click Apply changes to selected requirements","title":"Preprocessing"},{"location":"usage/workflow.html#formalization","text":"Order your requirement overview by Pos by clicking on the table column.","title":"Formalization"},{"location":"usage/workflow.html#req1","text":"To formalize this requirement, we click on the ID REQ1 to open then formalization-modal: Formalization modal Click on + to add a new formalization and then on ..(click to open) We now have to select a Scope and a Pattern . The scope is Globally , because the requirement states that \"var1 is always greater than 5\". The pattern is it is always the case that {R} holds . For {R} we insert the condition: var1 > 5 Set the status to Review and then press save changes . If you save a requirement, Hanfor will automatically create the used variables and derive their type. You can examine and even alter them in the section Variables , for the case that Hanfor did not derive a variable-type correctly. Definition of Scope and Pattern The same procedure can be applied to REQ2 - REQ6","title":"REQ1"},{"location":"usage/workflow.html#req7-and-req8","text":"REQ7 and REQ8 are different. Consider REQ7: if var3 = True then var4 := 0 . The scope is still Globally The pattern is it is always the case that if \"{R}\" holds, then \"{S}\" holds after at most \"{T}\" time units , because in a realtime-system a variable assignment does not happen instantly, there can be delays. For {R} we insert var3 , because the variable type is boolean. For {S} insert var4 == 0 , For {T} we need a certain amount of time units, for example 50. We do not want to hardcode values, we introduce a new variable and insert MAX_TIME . We end up with the following: Globally, it is always the case that if \"var3\" holds, then \"var4 == 0\" holds after at most \"MAX_TIME\" time units. Save the formalization. You will now recognize that Hanfor automatically added a new Tag Type_inference_error to your freshly formalized requirement. To fix that, to go the Variables section and open the MAX_TIME variable. You see that Hanfor derived the type bool , but we actually want it to be of type CONST as the variable represents time units. Change the type and also assign a value, for example 50 . Example for the MAX_TIME variable For REQ8 you should have: Globally, it is always the case that if \"var3\" holds, then \"var4 == 1\" holds after at most \"MAX_TIME\" time units.","title":"REQ7 and REQ8"},{"location":"usage/workflow.html#exporting-the-formalized-requirements","text":"Once you are done with all requirements, it is time to analyze them using a tool like Ultimate (TODO:ref to git).","title":"Exporting the formalized requirements."},{"location":"usage/workflow.html#preparing-the-export","text":"You might want to filter out some rows, for example, all of type meta or all that have a certain tag. Again, use the Search Query Language to select only the requirements you want. For example, if we only rows of type requirement which are not on status Todo we search: :COL_INDEX_04:requirement:AND::COL_INDEX_06::NOT:Todo","title":"Preparing the export."},{"location":"usage/workflow.html#export","text":"To export requirements, press Tools , then choose either .req or .csv . If you want to analyze the requirements using Ultimate, choose Generate .req file from (filtered) requirements table and then save it. You should end up with the following: CONST MAX_TIME IS 50.0 Input constraint1 IS bool Input constraint2 IS bool Input var1 IS int Input var2 IS int Input var3 IS bool Input var4 IS int REQ1_0: Globally, it is always the case that \"var1 > 5\" holds REQ2_0: Globally, it is always the case that \"var2 < 10\" holds REQ3_0: Globally, it is always the case that \"constraint1\" holds REQ4_0: Globally, it is always the case that \"constraint2\" holds REQ5_0: Globally, it is always the case that \"var1 < 5\" holds REQ6_0: Globally, it is never the case that \"constraint1 && constraint2 \" holds REQ7_0: Globally, it is always the case that if \"var3\" holds, then \"var4 == 1\" holds after at most \"MAX_TIME\" time units REQ8_0: Globally, it is always the case that if \"var3\" holds, then \"var4 == 0\" holds after at most \"MAX_TIME \" time units","title":"Export"},{"location":"usage/workflow.html#analysis-using-ultimate","text":"","title":"Analysis using Ultimate."},{"location":"usage/workflow.html#get-ultimate","text":"First of all you need Ultimate Install Java JDK (1.8) and Maven (>3.0) Clone the repository: git clone https://github.com/ultimate-pa/ultimate . Navigate to the release scripts cd ultimate/releaseScripts/default Generate a fresh binary ./makeFresh.sh You have now successfully forged binaries, which are located in UReqCheck-linux .","title":"Get Ultimate"},{"location":"usage/workflow.html#scripts-to-perform-the-complete-analysis","text":"We wrote a script, which perform a complete anaylsis, including the extraction of relevant stuff. The script is located in /path/to/ultimate/releaseScripts/default/UReqCheck-linux . You have to configure run_complete_analysis.sh , which is used to run the complete analysis. The script takes several arguments: run_complete_analysis.sh <req_file> <req_repo_folder> <req_folder> [<rt_inconsistency_range> <timeout_per_assertion>] Where: req_file is the Requirements file you generated using Hanfor. req_repo_folder is the path to the repository, which contains the requirements-folder req_folder is the path to the requirements-folder rt_inconsistency_range (default: 2) is the amount of requirements which are checked together for RT-inconsistency. Careful with this parameter, it will blow up the amount of checks really fast. * timeout_per_assertion (default: 900) The time how long a singles assertion is checked.","title":"Scripts to perform the complete analysis."},{"location":"usage/workflow.html#use-ultimate","text":"We now simply execute the run_complete_analysis.sh script. $ cd /path/to/ultimate/releaseScripts/default/UReqCheck-linux $ ./run_complete_analysis.sh path/to/repo/example_input/example_input.req path/to/repo/example_input path/to/repo/example_input This will fire up Ultimate and run an analysis. The analysis checks for rt-inconsistency and vacuity and logs are be generated: hanfor/example/example_input.req.log hanfor/example/example_input.req.testgen.log hanfor/example/logs/example_input/example_input.req.relevant.log hanfor/example/logs/example_input/example_input.req.testgen.log","title":"Use Ultimate"},{"location":"usage/workflow.html#evaluate","text":"In hanfor/example/example_input.req.log we can see that Ultimate reports: --- Results --- * Results from de.uni_freiburg.informatik.ultimate.pea2boogie: - RequirementInconsistentErrorResult: Requirements set is inconsistent. Requirements set is inconsistent. Some invariants are already infeasible. Responsible requirements: REQ6_0, REQ3_0, REQ4_0 Now, if we investigate REQ3, REQ4 and REQ6: REQ3_0: Globally, it is always the case that \"constraint1\" holds REQ4_0: Globally, it is always the case that \"constraint2\" holds REQ6_0: Globally, it is never the case that \"constraint1 && constraint2 \" holds We directly see what the problem is: On one hand, our invariants demand that constraint1 and constraint2 always holds, but on the other hand there is another invariant which demands that constraint1 and constraint2 never hold at the same time. Think about this as: constraint1 && constraint2 && ((constraint1 && !constraint2) || (!constraint1 && constraint2)) this is clearly unsatisfiable.","title":"Evaluate"},{"location":"usage/workflow.html#alter-your-requirements","text":"We now found an inconsistency in our requirements, that has to be fixed. Let's assume you review your requirements and you recognize REQ4 was defined wrong in the csv, where REQ4,constraint2 always holds,requirement should be REQ4,constraint2 never holds,requirement . While reading over the requirements, you also recognize that REQ1 and REQ5 collide and you find out that REQ5 shall be deleted. When we apply this changes, we end up with the following changes: alter REQ4,constraint2 always holds,requirement to REQ4,constraint2 never holds,requirement remove REQ5 and our csv file now looks as follows: ID,Description,Type META1,This is an example for some requirements,meta META2,Next we define some requirements,meta REQ1,var1 is always greater than 5,requirement REQ2,var2 is always smaller than 10,requirement REQ3,constraint1 always holds,requirement REQ4,constraint2 never holds,requirement REQ6,constraint1 and constraint2 never hold at the same time,requirement REQ7,if var3 = True then var4 = 0,requirement REQ8,if var3 = True then var4 = 1,requirement","title":"Alter your requirements"},{"location":"usage/workflow.html#time-for-a-new-revision","text":"We altered our requirements, we now need to create a new revision in Hanfor and change our formalizations. Execute: $ cd hanfor $ python3 app.py -r -c example/example_input.csv example_tag Hanfor will then ask: \"Which revision should I use as a base?\" , we choose revision_0 (as it is the only one, usually you want your latest revision). Then, Hanfor asks Should I use the csv header mapping from base revision? , as we did not change the csv header, we just keep the current one. A quick recap what happens when creating a revision: New requirements get the tag revision_0_to_revision_1_new_requirement Changed requirements get the tag revision_0_to_revision_1_data_changed and revision_0_to_revision_1_description_changed * Requirements where the formalization migrated to the new revision get the tag revision_0_to_revision_1_migrated_formalized We now have to alter the requirements which have changed, that's only REQ4 . Open the formalization of REQ4 and correct it to Globally, it is never the case that \"constraint2\" holds .","title":"Time for a new revision."},{"location":"usage/workflow.html#ultimate-analysis-2","text":"Export your requirements as before with the name example_input_revision1.req Run Ultimate on the new requirements file. You can now examine the log created in hanfor/example/logs/example_input/example_input.req.relevant.log , which contains the following: - ReqCheckFailResult [Line: -1]: Requirements REQ8_0, REQ7_0 are rt-inconsistent A ReqCheckFailResult usually implies that something is broken, Ultimate found that requirements REQ7 and REQ8 are rt-inconsistent, let's analyze this result: REQ7,if var3 = True then var4 = 0,requirement REQ8,if var3 = True then var4 = 1,requirement These two requirements collide, because they assign different values to var4 when var3 holds. This is especially bad in a realtime system, because it can happen that var4 == 0 holds after a certain amount of time, and var4 == 1 holds at a later point of time or vice versa. Why is this bad? - because it can cause unexpected behaviour when a change propagates through the system.","title":"Ultimate Analysis #2"},{"location":"usage/workflow.html#conclusion","text":"You are now able to: Setup hanfor, Formalize requirements, Filter requirements, Export them to a .req file Run Ultimate on a .req file Interpret the results of Ultimate Create new revisions in hanfor to fix mistakes in requirements.","title":"Conclusion"},{"location":"usage/patterns/BndDelayedResponsePatternUT.html","text":"BndDelayedResponsePatternUT # BndDelayedResponsePatternUT Globally # Globally, it is always the case that if \"R\" holds, then \"Q\" holds after at most \"c0\" time units for at least \"c1\" time units true;\u2308R\u2309;\u2308true\u2309 \u2227 \u2113 \u2265 50;\u2308Q\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true","title":"BndDelayedResponsePatternUT"},{"location":"usage/patterns/BndDelayedResponsePatternUT.html#bnddelayedresponsepatternut","text":"","title":"BndDelayedResponsePatternUT"},{"location":"usage/patterns/BndDelayedResponsePatternUT.html#bnddelayedresponsepatternut-globally","text":"Globally, it is always the case that if \"R\" holds, then \"Q\" holds after at most \"c0\" time units for at least \"c1\" time units true;\u2308R\u2309;\u2308true\u2309 \u2227 \u2113 \u2265 50;\u2308Q\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true","title":"BndDelayedResponsePatternUT Globally"},{"location":"usage/patterns/BndEntryConditionPattern.html","text":"BndEntryConditionPattern # BndEntryConditionPattern Globally # Globally, it is always the case that after \"R\" holds for \"c0\" time units, then \"Q\" holds true;\u2308R\u2309 \u2227 \u2113 > 50;\u2308!Q\u2309;true BndEntryConditionPattern Before # Before \"Q\", it is always the case that after \"S\" holds for \"c0\" time units, then \"R\" holds \u2308!Q\u2309;\u2308(!Q && S)\u2309 \u2227 \u2113 > 50;\u2308(!Q && !R)\u2309;true BndEntryConditionPattern After # After \"Q\", it is always the case that after \"S\" holds for \"c0\" time units, then \"R\" holds true;\u2308Q\u2309;true;\u2308S\u2309 \u2227 \u2113 > 50;\u2308!R\u2309;true BndEntryConditionPattern Between # Between \"Q\" and \"R\", it is always the case that after \"T\" holds for \"c0\" time units, then \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309 \u2227 \u2113 > 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true BndEntryConditionPattern AfterUntil # After \"Q\" until \"R\", it is always the case that after \"T\" holds for \"c0\" time units, then \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309 \u2227 \u2113 > 50;\u2308(!R && !S)\u2309;true","title":"BndEntryConditionPattern"},{"location":"usage/patterns/BndEntryConditionPattern.html#bndentryconditionpattern","text":"","title":"BndEntryConditionPattern"},{"location":"usage/patterns/BndEntryConditionPattern.html#bndentryconditionpattern-globally","text":"Globally, it is always the case that after \"R\" holds for \"c0\" time units, then \"Q\" holds true;\u2308R\u2309 \u2227 \u2113 > 50;\u2308!Q\u2309;true","title":"BndEntryConditionPattern Globally"},{"location":"usage/patterns/BndEntryConditionPattern.html#bndentryconditionpattern-before","text":"Before \"Q\", it is always the case that after \"S\" holds for \"c0\" time units, then \"R\" holds \u2308!Q\u2309;\u2308(!Q && S)\u2309 \u2227 \u2113 > 50;\u2308(!Q && !R)\u2309;true","title":"BndEntryConditionPattern Before"},{"location":"usage/patterns/BndEntryConditionPattern.html#bndentryconditionpattern-after","text":"After \"Q\", it is always the case that after \"S\" holds for \"c0\" time units, then \"R\" holds true;\u2308Q\u2309;true;\u2308S\u2309 \u2227 \u2113 > 50;\u2308!R\u2309;true","title":"BndEntryConditionPattern After"},{"location":"usage/patterns/BndEntryConditionPattern.html#bndentryconditionpattern-between","text":"Between \"Q\" and \"R\", it is always the case that after \"T\" holds for \"c0\" time units, then \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309 \u2227 \u2113 > 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"BndEntryConditionPattern Between"},{"location":"usage/patterns/BndEntryConditionPattern.html#bndentryconditionpattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that after \"T\" holds for \"c0\" time units, then \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309 \u2227 \u2113 > 50;\u2308(!R && !S)\u2309;true","title":"BndEntryConditionPattern AfterUntil"},{"location":"usage/patterns/BndExistencePattern.html","text":"BndExistencePattern # BndExistencePattern Globally # Globally, transitions to states in which \"Q\" holds occur at most twice true;\u2308Q\u2309;\u2308!Q\u2309;\u2308Q\u2309;\u2308!Q\u2309;\u2308Q\u2309;true BndExistencePattern Before # Before \"Q\", transitions to states in which \"R\" holds occur at most twice \u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;true BndExistencePattern After # After \"Q\", transitions to states in which \"R\" holds occur at most twice true;\u2308Q\u2309;true;\u2308R\u2309;\u2308!R\u2309;\u2308R\u2309;\u2308!R\u2309;\u2308R\u2309;true BndExistencePattern Between # Between \"Q\" and \"R\", transitions to states in which \"S\" holds occur at most twice true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;\u2308R\u2309;true BndExistencePattern AfterUntil # After \"Q\" until \"R\", transitions to states in which \"S\" holds occur at most twice true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;true","title":"BndExistencePattern"},{"location":"usage/patterns/BndExistencePattern.html#bndexistencepattern","text":"","title":"BndExistencePattern"},{"location":"usage/patterns/BndExistencePattern.html#bndexistencepattern-globally","text":"Globally, transitions to states in which \"Q\" holds occur at most twice true;\u2308Q\u2309;\u2308!Q\u2309;\u2308Q\u2309;\u2308!Q\u2309;\u2308Q\u2309;true","title":"BndExistencePattern Globally"},{"location":"usage/patterns/BndExistencePattern.html#bndexistencepattern-before","text":"Before \"Q\", transitions to states in which \"R\" holds occur at most twice \u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309;true","title":"BndExistencePattern Before"},{"location":"usage/patterns/BndExistencePattern.html#bndexistencepattern-after","text":"After \"Q\", transitions to states in which \"R\" holds occur at most twice true;\u2308Q\u2309;true;\u2308R\u2309;\u2308!R\u2309;\u2308R\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"BndExistencePattern After"},{"location":"usage/patterns/BndExistencePattern.html#bndexistencepattern-between","text":"Between \"Q\" and \"R\", transitions to states in which \"S\" holds occur at most twice true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"BndExistencePattern Between"},{"location":"usage/patterns/BndExistencePattern.html#bndexistencepattern-afteruntil","text":"After \"Q\" until \"R\", transitions to states in which \"S\" holds occur at most twice true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;true","title":"BndExistencePattern AfterUntil"},{"location":"usage/patterns/BndInvariancePattern.html","text":"BndInvariancePattern # BndInvariancePattern Globally # Globally, it is always the case that if \"R\" holds, then \"Q\" holds for at least \"c0\" time units true;\u2308R\u2309;\u2308true\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true BndInvariancePattern Before # Before \"Q\", it is always the case that if \"S\" holds, then \"R\" holds for at least \"c0\" time units \u2308!Q\u2309;\u2308(!Q && S)\u2309;\u2308!Q\u2309 \u2227 \u2113 < 50;\u2308(!Q && !R)\u2309;true BndInvariancePattern After # After \"Q\", it is always the case that if \"S\" holds, then \"R\" holds for at least \"c0\" time units true;\u2308Q\u2309;true;\u2308S\u2309;\u2308true\u2309 \u2227 \u2113 < 50;\u2308!R\u2309;true BndInvariancePattern Between # Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309;\u2308!R\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true BndInvariancePattern AfterUntil # After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309;\u2308!R\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;true","title":"BndInvariancePattern"},{"location":"usage/patterns/BndInvariancePattern.html#bndinvariancepattern","text":"","title":"BndInvariancePattern"},{"location":"usage/patterns/BndInvariancePattern.html#bndinvariancepattern-globally","text":"Globally, it is always the case that if \"R\" holds, then \"Q\" holds for at least \"c0\" time units true;\u2308R\u2309;\u2308true\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true","title":"BndInvariancePattern Globally"},{"location":"usage/patterns/BndInvariancePattern.html#bndinvariancepattern-before","text":"Before \"Q\", it is always the case that if \"S\" holds, then \"R\" holds for at least \"c0\" time units \u2308!Q\u2309;\u2308(!Q && S)\u2309;\u2308!Q\u2309 \u2227 \u2113 < 50;\u2308(!Q && !R)\u2309;true","title":"BndInvariancePattern Before"},{"location":"usage/patterns/BndInvariancePattern.html#bndinvariancepattern-after","text":"After \"Q\", it is always the case that if \"S\" holds, then \"R\" holds for at least \"c0\" time units true;\u2308Q\u2309;true;\u2308S\u2309;\u2308true\u2309 \u2227 \u2113 < 50;\u2308!R\u2309;true","title":"BndInvariancePattern After"},{"location":"usage/patterns/BndInvariancePattern.html#bndinvariancepattern-between","text":"Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309;\u2308!R\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"BndInvariancePattern Between"},{"location":"usage/patterns/BndInvariancePattern.html#bndinvariancepattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && T)\u2309;\u2308!R\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;true","title":"BndInvariancePattern AfterUntil"},{"location":"usage/patterns/BndReccurrencePattern.html","text":"BndReccurrencePattern # BndReccurrencePattern Globally # Globally, it is always the case that \"Q\" holds at least every \"c0\" time units true;\u2308!Q\u2309 \u2227 \u2113 > 10;true BndReccurrencePattern Before # Before \"Q\", it is always the case that \"R\" holds at least every \"c0\" time units \u2308!Q\u2309;\u2308(!Q && !R)\u2309 \u2227 \u2113 > 50;true BndReccurrencePattern After # After \"Q\", it is always the case that \"R\" holds at least every \"c0\" time units true;\u2308Q\u2309;true;\u2308!R\u2309 \u2227 \u2113 > 50;true BndReccurrencePattern Between # Between \"Q\" and \"R\", it is always the case that \"S\" holds at least every \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 > 50;\u2308!R\u2309;\u2308R\u2309;true BndReccurrencePattern AfterUntil # After \"Q\" until \"R\", it is always the case that \"S\" holds at least every \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 > 50;true","title":"BndReccurrencePattern"},{"location":"usage/patterns/BndReccurrencePattern.html#bndreccurrencepattern","text":"","title":"BndReccurrencePattern"},{"location":"usage/patterns/BndReccurrencePattern.html#bndreccurrencepattern-globally","text":"Globally, it is always the case that \"Q\" holds at least every \"c0\" time units true;\u2308!Q\u2309 \u2227 \u2113 > 10;true","title":"BndReccurrencePattern Globally"},{"location":"usage/patterns/BndReccurrencePattern.html#bndreccurrencepattern-before","text":"Before \"Q\", it is always the case that \"R\" holds at least every \"c0\" time units \u2308!Q\u2309;\u2308(!Q && !R)\u2309 \u2227 \u2113 > 50;true","title":"BndReccurrencePattern Before"},{"location":"usage/patterns/BndReccurrencePattern.html#bndreccurrencepattern-after","text":"After \"Q\", it is always the case that \"R\" holds at least every \"c0\" time units true;\u2308Q\u2309;true;\u2308!R\u2309 \u2227 \u2113 > 50;true","title":"BndReccurrencePattern After"},{"location":"usage/patterns/BndReccurrencePattern.html#bndreccurrencepattern-between","text":"Between \"Q\" and \"R\", it is always the case that \"S\" holds at least every \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 > 50;\u2308!R\u2309;\u2308R\u2309;true","title":"BndReccurrencePattern Between"},{"location":"usage/patterns/BndReccurrencePattern.html#bndreccurrencepattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that \"S\" holds at least every \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 > 50;true","title":"BndReccurrencePattern AfterUntil"},{"location":"usage/patterns/BndResponsePatternTT.html","text":"BndResponsePatternTT # BndResponsePatternTT Globally # Globally, it is always the case that if \"R\" holds for at least \"c0\" time units, then \"Q\" holds afterwards for at least \"c1\" time units true;\u2308R\u2309 \u2227 \u2113 \u2265 50;\u2308Q\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true","title":"BndResponsePatternTT"},{"location":"usage/patterns/BndResponsePatternTT.html#bndresponsepatterntt","text":"","title":"BndResponsePatternTT"},{"location":"usage/patterns/BndResponsePatternTT.html#bndresponsepatterntt-globally","text":"Globally, it is always the case that if \"R\" holds for at least \"c0\" time units, then \"Q\" holds afterwards for at least \"c1\" time units true;\u2308R\u2309 \u2227 \u2113 \u2265 50;\u2308Q\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true","title":"BndResponsePatternTT Globally"},{"location":"usage/patterns/BndResponsePatternTU.html","text":"BndResponsePatternTU # BndResponsePatternTU Globally # Globally, it is always the case that if \"R\" holds for at least \"c0\" time units, then \"Q\" holds afterwards true;\u2308R\u2309 \u2227 \u2113 \u2265 50;\u2308!Q\u2309;true","title":"BndResponsePatternTU"},{"location":"usage/patterns/BndResponsePatternTU.html#bndresponsepatterntu","text":"","title":"BndResponsePatternTU"},{"location":"usage/patterns/BndResponsePatternTU.html#bndresponsepatterntu-globally","text":"Globally, it is always the case that if \"R\" holds for at least \"c0\" time units, then \"Q\" holds afterwards true;\u2308R\u2309 \u2227 \u2113 \u2265 50;\u2308!Q\u2309;true","title":"BndResponsePatternTU Globally"},{"location":"usage/patterns/BndResponsePatternUT.html","text":"BndResponsePatternUT # BndResponsePatternUT Globally # Globally, it is always the case that if \"R\" holds, then \"Q\" holds after at most \"c0\" time units true;\u2308(!Q && R)\u2309;\u2308!Q\u2309 \u2227 \u2113 > 50;true BndResponsePatternUT Before # Before \"Q\", it is always the case that if \"S\" holds, then \"R\" holds after at most \"c0\" time units \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308(!Q && !R)\u2309 \u2227 \u2113 \u2265 50;true BndResponsePatternUT After # After \"Q\", it is always the case that if \"S\" holds, then \"R\" holds after at most \"c0\" time units true;\u2308Q\u2309;true;\u2308(!R && S)\u2309;\u2308!R\u2309 \u2227 \u2113 \u2265 50;true BndResponsePatternUT Between # Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" holds after at most \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 \u2265 50;\u2308!R\u2309;\u2308R\u2309;true BndResponsePatternUT AfterUntil # After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" holds after at most \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 \u2265 50;true","title":"BndResponsePatternUT"},{"location":"usage/patterns/BndResponsePatternUT.html#bndresponsepatternut","text":"","title":"BndResponsePatternUT"},{"location":"usage/patterns/BndResponsePatternUT.html#bndresponsepatternut-globally","text":"Globally, it is always the case that if \"R\" holds, then \"Q\" holds after at most \"c0\" time units true;\u2308(!Q && R)\u2309;\u2308!Q\u2309 \u2227 \u2113 > 50;true","title":"BndResponsePatternUT Globally"},{"location":"usage/patterns/BndResponsePatternUT.html#bndresponsepatternut-before","text":"Before \"Q\", it is always the case that if \"S\" holds, then \"R\" holds after at most \"c0\" time units \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308(!Q && !R)\u2309 \u2227 \u2113 \u2265 50;true","title":"BndResponsePatternUT Before"},{"location":"usage/patterns/BndResponsePatternUT.html#bndresponsepatternut-after","text":"After \"Q\", it is always the case that if \"S\" holds, then \"R\" holds after at most \"c0\" time units true;\u2308Q\u2309;true;\u2308(!R && S)\u2309;\u2308!R\u2309 \u2227 \u2113 \u2265 50;true","title":"BndResponsePatternUT After"},{"location":"usage/patterns/BndResponsePatternUT.html#bndresponsepatternut-between","text":"Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" holds after at most \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 \u2265 50;\u2308!R\u2309;\u2308R\u2309;true","title":"BndResponsePatternUT Between"},{"location":"usage/patterns/BndResponsePatternUT.html#bndresponsepatternut-afteruntil","text":"After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" holds after at most \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308(!R && !S)\u2309 \u2227 \u2113 \u2265 50;true","title":"BndResponsePatternUT AfterUntil"},{"location":"usage/patterns/InstAbsPattern.html","text":"InstAbsPattern # InstAbsPattern Globally # Globally, it is never the case that \"Q\" holds true;\u2308Q\u2309;true InstAbsPattern After # After \"Q\", it is never the case that \"R\" holds true;\u2308Q\u2309;true;\u2308R\u2309;true InstAbsPattern Between # Between \"Q\" and \"R\", it is never the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;\u2308R\u2309;true InstAbsPattern AfterUntil # After \"Q\" until \"R\", it is never the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;true","title":"InstAbsPattern"},{"location":"usage/patterns/InstAbsPattern.html#instabspattern","text":"","title":"InstAbsPattern"},{"location":"usage/patterns/InstAbsPattern.html#instabspattern-globally","text":"Globally, it is never the case that \"Q\" holds true;\u2308Q\u2309;true","title":"InstAbsPattern Globally"},{"location":"usage/patterns/InstAbsPattern.html#instabspattern-after","text":"After \"Q\", it is never the case that \"R\" holds true;\u2308Q\u2309;true;\u2308R\u2309;true","title":"InstAbsPattern After"},{"location":"usage/patterns/InstAbsPattern.html#instabspattern-between","text":"Between \"Q\" and \"R\", it is never the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"InstAbsPattern Between"},{"location":"usage/patterns/InstAbsPattern.html#instabspattern-afteruntil","text":"After \"Q\" until \"R\", it is never the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;true","title":"InstAbsPattern AfterUntil"},{"location":"usage/patterns/InvariantPattern.html","text":"InvariantPattern # InvariantPattern Globally # Globally, it is always the case that if \"R\" holds, then \"Q\" holds as well true;\u2308(!Q && R)\u2309;true InvariantPattern Before # Before \"Q\", it is always the case that if \"S\" holds, then \"R\" holds as well \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308!Q\u2309;true InvariantPattern After # After \"Q\", it is always the case that if \"S\" holds, then \"R\" holds as well true;\u2308Q\u2309;true;\u2308(!R && S)\u2309;true InvariantPattern Between # Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" holds as well true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308!R\u2309;\u2308R\u2309;true InvariantPattern AfterUntil # After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" holds as well true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;true","title":"InvariantPattern"},{"location":"usage/patterns/InvariantPattern.html#invariantpattern","text":"","title":"InvariantPattern"},{"location":"usage/patterns/InvariantPattern.html#invariantpattern-globally","text":"Globally, it is always the case that if \"R\" holds, then \"Q\" holds as well true;\u2308(!Q && R)\u2309;true","title":"InvariantPattern Globally"},{"location":"usage/patterns/InvariantPattern.html#invariantpattern-before","text":"Before \"Q\", it is always the case that if \"S\" holds, then \"R\" holds as well \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308!Q\u2309;true","title":"InvariantPattern Before"},{"location":"usage/patterns/InvariantPattern.html#invariantpattern-after","text":"After \"Q\", it is always the case that if \"S\" holds, then \"R\" holds as well true;\u2308Q\u2309;true;\u2308(!R && S)\u2309;true","title":"InvariantPattern After"},{"location":"usage/patterns/InvariantPattern.html#invariantpattern-between","text":"Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" holds as well true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"InvariantPattern Between"},{"location":"usage/patterns/InvariantPattern.html#invariantpattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" holds as well true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;true","title":"InvariantPattern AfterUntil"},{"location":"usage/patterns/MaxDurationPattern.html","text":"MaxDurationPattern # MaxDurationPattern Globally # Globally, it is always the case that once \"Q\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308Q\u2309 \u2227 \u2113 \u2265 50;true MaxDurationPattern Before # Before \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for less than \"c0\" time units \u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 50;true MaxDurationPattern After # After \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308Q\u2309;true;\u2308!R\u2309;\u2308R\u2309 \u2227 \u2113 \u2265 50;true MaxDurationPattern Between # Between \"Q\" and \"R\", it is always the case that once \"S\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 \u2265 50;\u2308!R\u2309;\u2308R\u2309;true MaxDurationPattern AfterUntil # After \"Q\" until \"R\", it is always the case that once \"S\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 \u2265 50;true","title":"MaxDurationPattern"},{"location":"usage/patterns/MaxDurationPattern.html#maxdurationpattern","text":"","title":"MaxDurationPattern"},{"location":"usage/patterns/MaxDurationPattern.html#maxdurationpattern-globally","text":"Globally, it is always the case that once \"Q\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308Q\u2309 \u2227 \u2113 \u2265 50;true","title":"MaxDurationPattern Globally"},{"location":"usage/patterns/MaxDurationPattern.html#maxdurationpattern-before","text":"Before \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for less than \"c0\" time units \u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 \u2265 50;true","title":"MaxDurationPattern Before"},{"location":"usage/patterns/MaxDurationPattern.html#maxdurationpattern-after","text":"After \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308Q\u2309;true;\u2308!R\u2309;\u2308R\u2309 \u2227 \u2113 \u2265 50;true","title":"MaxDurationPattern After"},{"location":"usage/patterns/MaxDurationPattern.html#maxdurationpattern-between","text":"Between \"Q\" and \"R\", it is always the case that once \"S\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 \u2265 50;\u2308!R\u2309;\u2308R\u2309;true","title":"MaxDurationPattern Between"},{"location":"usage/patterns/MaxDurationPattern.html#maxdurationpattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that once \"S\" becomes satisfied, it holds for less than \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 \u2265 50;true","title":"MaxDurationPattern AfterUntil"},{"location":"usage/patterns/MinDurationPattern.html","text":"MinDurationPattern # MinDurationPattern Globally # Globally, it is always the case that once \"Q\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308!Q\u2309;\u2308Q\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true MinDurationPattern Before # Before \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for at least \"c0\" time units \u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 < 50;\u2308(!Q && !R)\u2309;true MinDurationPattern After # After \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308Q\u2309;true;\u2308!R\u2309;\u2308R\u2309 \u2227 \u2113 < 50;\u2308!R\u2309;true MinDurationPattern Between # Between \"Q\" and \"R\", it is always the case that once \"S\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true MinDurationPattern AfterUntil # After \"Q\" until \"R\", it is always the case that once \"S\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;true","title":"MinDurationPattern"},{"location":"usage/patterns/MinDurationPattern.html#mindurationpattern","text":"","title":"MinDurationPattern"},{"location":"usage/patterns/MinDurationPattern.html#mindurationpattern-globally","text":"Globally, it is always the case that once \"Q\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308!Q\u2309;\u2308Q\u2309 \u2227 \u2113 < 50;\u2308!Q\u2309;true","title":"MinDurationPattern Globally"},{"location":"usage/patterns/MinDurationPattern.html#mindurationpattern-before","text":"Before \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for at least \"c0\" time units \u2308!Q\u2309;\u2308(!Q && !R)\u2309;\u2308(!Q && R)\u2309 \u2227 \u2113 < 50;\u2308(!Q && !R)\u2309;true","title":"MinDurationPattern Before"},{"location":"usage/patterns/MinDurationPattern.html#mindurationpattern-after","text":"After \"Q\", it is always the case that once \"R\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308Q\u2309;true;\u2308!R\u2309;\u2308R\u2309 \u2227 \u2113 < 50;\u2308!R\u2309;true","title":"MinDurationPattern After"},{"location":"usage/patterns/MinDurationPattern.html#mindurationpattern-between","text":"Between \"Q\" and \"R\", it is always the case that once \"S\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"MinDurationPattern Between"},{"location":"usage/patterns/MinDurationPattern.html#mindurationpattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that once \"S\" becomes satisfied, it holds for at least \"c0\" time units true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;\u2308(!R && S)\u2309 \u2227 \u2113 < 50;\u2308(!R && !S)\u2309;\u2308!R\u2309;true","title":"MinDurationPattern AfterUntil"},{"location":"usage/patterns/PrecedenceChain12Pattern.html","text":"PrecedenceChain12Pattern # PrecedenceChain12Pattern Globally # Globally, it is always the case that if \"S\" holds and is succeeded by \"R\", then \"Q\" previously held \u2308!S\u2309;\u2308R\u2309;true;\u2308Q\u2309;true PrecedenceChain12Pattern Before # Before \"Q\", it is always the case that if \"T\" holds and is succeeded by \"S\", then \"R\" previously held \u2308(!Q && !T)\u2309;\u2308(!Q && (S && !T))\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;true PrecedenceChain12Pattern After # After \"Q\", it is always the case that if \"T\" holds and is succeeded by \"S\", then \"R\" previously held \u2308!T\u2309;\u2308(Q && !T)\u2309;\u2308!T\u2309;\u2308(S && !T)\u2309;true;\u2308R\u2309;true PrecedenceChain12Pattern Between # Between \"Q\" and \"R\", it is always the case that if \"U\" holds and is succeeded by \"T\", then \"S\" previously held \u2308!U\u2309;\u2308(Q && (!R && !U))\u2309;\u2308(!R && !U)\u2309;\u2308(!R && (T && !U))\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;\u2308R\u2309;true PrecedenceChain12Pattern AfterUntil # After \"Q\" until \"R\", it is always the case that if \"U\" holds and is succeeded by \"T\", then \"S\" previously held \u2308!U\u2309;\u2308(Q && (!R && !U))\u2309;\u2308(!R && !U)\u2309;\u2308(!R && (T && !U))\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;true","title":"PrecedenceChain12Pattern"},{"location":"usage/patterns/PrecedenceChain12Pattern.html#precedencechain12pattern","text":"","title":"PrecedenceChain12Pattern"},{"location":"usage/patterns/PrecedenceChain12Pattern.html#precedencechain12pattern-globally","text":"Globally, it is always the case that if \"S\" holds and is succeeded by \"R\", then \"Q\" previously held \u2308!S\u2309;\u2308R\u2309;true;\u2308Q\u2309;true","title":"PrecedenceChain12Pattern Globally"},{"location":"usage/patterns/PrecedenceChain12Pattern.html#precedencechain12pattern-before","text":"Before \"Q\", it is always the case that if \"T\" holds and is succeeded by \"S\", then \"R\" previously held \u2308(!Q && !T)\u2309;\u2308(!Q && (S && !T))\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;true","title":"PrecedenceChain12Pattern Before"},{"location":"usage/patterns/PrecedenceChain12Pattern.html#precedencechain12pattern-after","text":"After \"Q\", it is always the case that if \"T\" holds and is succeeded by \"S\", then \"R\" previously held \u2308!T\u2309;\u2308(Q && !T)\u2309;\u2308!T\u2309;\u2308(S && !T)\u2309;true;\u2308R\u2309;true","title":"PrecedenceChain12Pattern After"},{"location":"usage/patterns/PrecedenceChain12Pattern.html#precedencechain12pattern-between","text":"Between \"Q\" and \"R\", it is always the case that if \"U\" holds and is succeeded by \"T\", then \"S\" previously held \u2308!U\u2309;\u2308(Q && (!R && !U))\u2309;\u2308(!R && !U)\u2309;\u2308(!R && (T && !U))\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"PrecedenceChain12Pattern Between"},{"location":"usage/patterns/PrecedenceChain12Pattern.html#precedencechain12pattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that if \"U\" holds and is succeeded by \"T\", then \"S\" previously held \u2308!U\u2309;\u2308(Q && (!R && !U))\u2309;\u2308(!R && !U)\u2309;\u2308(!R && (T && !U))\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;true","title":"PrecedenceChain12Pattern AfterUntil"},{"location":"usage/patterns/PrecedenceChain21Pattern.html","text":"PrecedenceChain21Pattern # PrecedenceChain21Pattern Globally # Globally, it is always the case that if \"S\" holds, then \"R\" previously held and was preceded by \"Q\" \u2308!R\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308S\u2309;true","title":"PrecedenceChain21Pattern"},{"location":"usage/patterns/PrecedenceChain21Pattern.html#precedencechain21pattern","text":"","title":"PrecedenceChain21Pattern"},{"location":"usage/patterns/PrecedenceChain21Pattern.html#precedencechain21pattern-globally","text":"Globally, it is always the case that if \"S\" holds, then \"R\" previously held and was preceded by \"Q\" \u2308!R\u2309;\u2308(!Q && R)\u2309;\u2308!Q\u2309;\u2308S\u2309;true","title":"PrecedenceChain21Pattern Globally"},{"location":"usage/patterns/PrecedencePattern.html","text":"PrecedencePattern # PrecedencePattern Globally # Globally, it is always the case that if \"R\" holds, then \"Q\" previously held \u2308!Q\u2309;\u2308R\u2309;true PrecedencePattern Before # Before \"Q\", it is always the case that if \"S\" holds, then \"R\" previously held \u2308(!Q && !R)\u2309;\u2308(!Q && S)\u2309;true PrecedencePattern After # After \"Q\", it is always the case that if \"S\" holds, then \"R\" previously held true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308S\u2309;true PrecedencePattern Between # Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" previously held true;\u2308(Q && (!R && !S))\u2309;\u2308(!R && !S)\u2309;\u2308(!R && (!S && T))\u2309;\u2308!R\u2309;\u2308R\u2309;true PrecedencePattern AfterUntil # After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" previously held true;\u2308(Q && (!R && !S))\u2309;\u2308(!R && !S)\u2309;\u2308(!R && T)\u2309;true","title":"PrecedencePattern"},{"location":"usage/patterns/PrecedencePattern.html#precedencepattern","text":"","title":"PrecedencePattern"},{"location":"usage/patterns/PrecedencePattern.html#precedencepattern-globally","text":"Globally, it is always the case that if \"R\" holds, then \"Q\" previously held \u2308!Q\u2309;\u2308R\u2309;true","title":"PrecedencePattern Globally"},{"location":"usage/patterns/PrecedencePattern.html#precedencepattern-before","text":"Before \"Q\", it is always the case that if \"S\" holds, then \"R\" previously held \u2308(!Q && !R)\u2309;\u2308(!Q && S)\u2309;true","title":"PrecedencePattern Before"},{"location":"usage/patterns/PrecedencePattern.html#precedencepattern-after","text":"After \"Q\", it is always the case that if \"S\" holds, then \"R\" previously held true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308S\u2309;true","title":"PrecedencePattern After"},{"location":"usage/patterns/PrecedencePattern.html#precedencepattern-between","text":"Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" previously held true;\u2308(Q && (!R && !S))\u2309;\u2308(!R && !S)\u2309;\u2308(!R && (!S && T))\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"PrecedencePattern Between"},{"location":"usage/patterns/PrecedencePattern.html#precedencepattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that if \"T\" holds, then \"S\" previously held true;\u2308(Q && (!R && !S))\u2309;\u2308(!R && !S)\u2309;\u2308(!R && T)\u2309;true","title":"PrecedencePattern AfterUntil"},{"location":"usage/patterns/ResponseChain21Pattern.html","text":"ResponseChain21Pattern # ResponseChain21Pattern Before # Before \"Q\", it is always the case that if \"U\" holds and is succeeded by \"T\", then \"S\" eventually holds after \"R\" \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !T)\u2309;\u2308Q\u2309;true ResponseChain21Pattern Between # Between \"Q\" and \"R\", it is always the case that if \"V\" holds and is succeeded by \"U\", then \"T\" eventually holds after \"S\" true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308(!R && !U)\u2309;\u2308R\u2309;true","title":"ResponseChain21Pattern"},{"location":"usage/patterns/ResponseChain21Pattern.html#responsechain21pattern","text":"","title":"ResponseChain21Pattern"},{"location":"usage/patterns/ResponseChain21Pattern.html#responsechain21pattern-before","text":"Before \"Q\", it is always the case that if \"U\" holds and is succeeded by \"T\", then \"S\" eventually holds after \"R\" \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308!Q\u2309;\u2308(!Q && R)\u2309;\u2308(!Q && !T)\u2309;\u2308Q\u2309;true","title":"ResponseChain21Pattern Before"},{"location":"usage/patterns/ResponseChain21Pattern.html#responsechain21pattern-between","text":"Between \"Q\" and \"R\", it is always the case that if \"V\" holds and is succeeded by \"U\", then \"T\" eventually holds after \"S\" true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308!R\u2309;\u2308(!R && S)\u2309;\u2308(!R && !U)\u2309;\u2308R\u2309;true","title":"ResponseChain21Pattern Between"},{"location":"usage/patterns/ResponsePattern.html","text":"ResponsePattern # ResponsePattern Globally # Globally, it is always the case that if \"R\" holds, then \"Q\" eventually holds true;\u2308(!Q && R)\u2309;\u2308!Q\u2309;true ResponsePattern Before # Before \"Q\", it is always the case that if \"S\" holds, then \"R\" eventually holds \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308(!Q && !R)\u2309;\u2308Q\u2309;true ResponsePattern Between # Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" eventually holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308(!R && !S)\u2309;\u2308R\u2309;true","title":"ResponsePattern"},{"location":"usage/patterns/ResponsePattern.html#responsepattern","text":"","title":"ResponsePattern"},{"location":"usage/patterns/ResponsePattern.html#responsepattern-globally","text":"Globally, it is always the case that if \"R\" holds, then \"Q\" eventually holds true;\u2308(!Q && R)\u2309;\u2308!Q\u2309;true","title":"ResponsePattern Globally"},{"location":"usage/patterns/ResponsePattern.html#responsepattern-before","text":"Before \"Q\", it is always the case that if \"S\" holds, then \"R\" eventually holds \u2308!Q\u2309;\u2308(!Q && (!R && S))\u2309;\u2308(!Q && !R)\u2309;\u2308Q\u2309;true","title":"ResponsePattern Before"},{"location":"usage/patterns/ResponsePattern.html#responsepattern-between","text":"Between \"Q\" and \"R\", it is always the case that if \"T\" holds, then \"S\" eventually holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && (!S && T))\u2309;\u2308(!R && !S)\u2309;\u2308R\u2309;true","title":"ResponsePattern Between"},{"location":"usage/patterns/TogglePattern.html","text":"TogglePattern # TogglePattern Globally # Globally, it is always the case that if \"Q\" holds then \"R\" toggles \"S\" true;\u2308(Q && R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;true","title":"TogglePattern"},{"location":"usage/patterns/TogglePattern.html#togglepattern","text":"","title":"TogglePattern"},{"location":"usage/patterns/TogglePattern.html#togglepattern-globally","text":"Globally, it is always the case that if \"Q\" holds then \"R\" toggles \"S\" true;\u2308(Q && R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;true","title":"TogglePattern Globally"},{"location":"usage/patterns/TogglePatternDelayed.html","text":"TogglePatternDelayed # TogglePatternDelayed Globally # Globally, it is always the case that if \"Q\" holds then \"R\" toggles \"S\" at most \"c0\" time units later true;\u2308(Q && R)\u2309;\u2308!R\u2309 \u2227 \u2113 \u2265 50;\u2308(!R && !S)\u2309;true","title":"TogglePatternDelayed"},{"location":"usage/patterns/TogglePatternDelayed.html#togglepatterndelayed","text":"","title":"TogglePatternDelayed"},{"location":"usage/patterns/TogglePatternDelayed.html#togglepatterndelayed-globally","text":"Globally, it is always the case that if \"Q\" holds then \"R\" toggles \"S\" at most \"c0\" time units later true;\u2308(Q && R)\u2309;\u2308!R\u2309 \u2227 \u2113 \u2265 50;\u2308(!R && !S)\u2309;true","title":"TogglePatternDelayed Globally"},{"location":"usage/patterns/UniversalityPattern.html","text":"UniversalityPattern # UniversalityPattern Globally # Globally, it is always the case that \"Q\" holds true;\u2308!Q\u2309;true UniversalityPattern Before # Before \"Q\", it is always the case that \"R\" holds \u2308!Q\u2309;\u2308(!Q && !R)\u2309;true UniversalityPattern After # After \"Q\", it is always the case that \"R\" holds true;\u2308Q\u2309;true;\u2308!R\u2309;true UniversalityPattern Between # Between \"Q\" and \"R\", it is always the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true UniversalityPattern AfterUntil # After \"Q\" until \"R\", it is always the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;true","title":"UniversalityPattern"},{"location":"usage/patterns/UniversalityPattern.html#universalitypattern","text":"","title":"UniversalityPattern"},{"location":"usage/patterns/UniversalityPattern.html#universalitypattern-globally","text":"Globally, it is always the case that \"Q\" holds true;\u2308!Q\u2309;true","title":"UniversalityPattern Globally"},{"location":"usage/patterns/UniversalityPattern.html#universalitypattern-before","text":"Before \"Q\", it is always the case that \"R\" holds \u2308!Q\u2309;\u2308(!Q && !R)\u2309;true","title":"UniversalityPattern Before"},{"location":"usage/patterns/UniversalityPattern.html#universalitypattern-after","text":"After \"Q\", it is always the case that \"R\" holds true;\u2308Q\u2309;true;\u2308!R\u2309;true","title":"UniversalityPattern After"},{"location":"usage/patterns/UniversalityPattern.html#universalitypattern-between","text":"Between \"Q\" and \"R\", it is always the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;\u2308!R\u2309;\u2308R\u2309;true","title":"UniversalityPattern Between"},{"location":"usage/patterns/UniversalityPattern.html#universalitypattern-afteruntil","text":"After \"Q\" until \"R\", it is always the case that \"S\" holds true;\u2308(Q && !R)\u2309;\u2308!R\u2309;\u2308(!R && !S)\u2309;true","title":"UniversalityPattern AfterUntil"}]}